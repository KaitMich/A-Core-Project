[
  {
    "text": "[ 40 ] Learning Machine learning is the study of programs that can improve their performance on a given task automatically. [ 41 ] It has been a part of AI from the beginning. [ e ] There are several kinds of machine learning. Unsupervised learning analyzes a stream of data and finds patterns and makes predictions without any other guidance. [ 44 ] Supervised learning requires labeling the training data with the expected answers, and comes in two main varieties: classification (where the program must learn to predict what category the input belongs in) and regression (where the program must deduce a numeric function based on numeric input). [ 45 ] In reinforcement learning , the agent is rewarded for good responses and punished for bad ones. The agent learns to choose responses that are classified as \"good\". [ 46 ] Transfer learning is when the knowledge gained from one problem is applied to a new problem. [ 47 ]",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:56:36.945731",
    "symbols_found": 1,
    "id": "FOLLOW_HYBRID_1748228196945",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:56:36.945731",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:56:36.945731",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "[ 71 ] Simple exhaustive searches [ 72 ] are rarely sufficient for most real-world problems: the search space (the number of places to search) quickly grows to astronomical numbers . The result is a search that is too slow or never completes. [ 15 ] \" Heuristics \" or \"rules of thumb\" can help prioritize choices that are more likely to reach a goal. [ 73 ] Adversarial search is used for game-playing programs, such as chess or Go. It searches through a tree of possible moves and countermoves, looking for a winning position. [ 74 ] Local search Illustration of gradient descent for 3 different starting points; two parameters (represented by the plan coordinates) are adjusted in order to minimize the loss function (the height) Local search uses mathematical optimization to find a solution to a problem. It begins with some form of guess and refines it incrementally.",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:56:36.978787",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748228196978",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:56:36.978787",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:56:36.978787",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "[ 133 ] Through the lens of the Hippocratic Oath , medical professionals are ethically compelled to use AI, if applications can more accurately diagnose and treat patients. [ 134 ] [ 135 ] For medical research, AI is an important tool for processing and integrating big data . This is particularly important for organoid and tissue engineering development which use microscopy imaging as a key technique in fabrication. [ 136 ] It has been suggested that AI can overcome discrepancies in funding allocated to different fields of research. [ 136 ] [ 137 ] New AI tools can deepen the understanding of biomedically relevant pathways. For example, AlphaFold 2 (2021) demonstrated the ability to approximate, in hours rather than months, the 3D structure of a protein . [ 138 ] In 2023, it was reported that AI-guided drug discovery helped find a class of antibiotics capable of killing two different types of drug-resistant bacteria.",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:56:37.097751",
    "symbols_found": 1,
    "id": "FOLLOW_HYBRID_1748228197098",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:56:37.098923",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:56:37.098923",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "[ 159 ] When natural language is used to describe mathematical problems, converters can transform such prompts into a formal language such as Lean to define mathematical tasks. Some models have been developed to solve challenging problems and reach good results in benchmark tests, others to serve as educational tools in mathematics. [ 160 ] Topological deep learning integrates various topological approaches. Finance Finance is one of the fastest growing sectors where applied AI tools are being deployed: from retail online banking to investment advice and insurance, where automated \"robot advisers\" have been in use for some years. [ 161 ] According to Nicolas Firzli, director of the World Pensions & Investments Forum , it may be too early to see the emergence of highly innovative AI-informed financial products and services.",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:56:37.120892",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748228197120",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:56:37.120892",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:56:37.120892",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "Using machine learning, AI agents can adapt to new situations and optimise their behaviour for their designated tasks. [ 185 ] [ 186 ] [ 187 ] Sexuality Applications of AI in this domain include AI-enabled menstruation and fertility trackers that analyze user data to offer prediction, [ 188 ] AI-integrated sex toys (e.g., teledildonics ), [ 189 ] AI-generated sexual education content, [ 190 ] and AI agents that simulate sexual and romantic partners (e.g., Replika ). [ 191 ] AI is also used for the production of non-consensual deepfake pornography , raising significant ethical and legal concerns. [ 192 ] AI technologies have also been used to attempt to identify online gender-based violence and online sexual grooming of minors. [ 193 ] [ 194 ] Other industry-specific tasks There are also thousands of successful AI applications used to solve specific problems for specific industries or institutions.",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:56:37.145426",
    "symbols_found": 1,
    "id": "FOLLOW_HYBRID_1748228197146",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:56:37.146418",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:56:37.146418",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "[ 225 ] Nvidia CEO Jen-Hsun Huang said nuclear power is a good option for the data centers. [ 226 ] In September 2024, Microsoft announced an agreement with Constellation Energy to re-open the Three Mile Island nuclear power plant to provide Microsoft with 100% of all electric power produced by the plant for 20 years. Reopening the plant, which suffered a partial nuclear meltdown of its Unit 2 reactor in 1979, will require Constellation to get through strict regulatory processes which will include extensive safety scrutiny from the US Nuclear Regulatory Commission . If approved (this will be the first ever US re-commissioning of a nuclear plant), over 835 megawatts of power – enough for 800,000 homes – of energy will be produced. The cost for re-opening and upgrading is estimated at $1.6 billion (US) and is dependent on tax breaks for nuclear power contained in the 2022 US Inflation Reduction Act .",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:56:37.244919",
    "symbols_found": 1,
    "id": "FOLLOW_HYBRID_1748228197245",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:56:37.245528",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:56:37.245528",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "This process condenses extensive datasets into a more compact set of representative points. Particularly beneficial in image and signal processing , k-means clustering aids in data reduction by replacing groups of data points with their centroids, thereby preserving the core information of the original data while significantly decreasing the required storage space. [ 32 ] Large language models (LLMs) are also efficient lossless data compressors on some data sets, as demonstrated by DeepMind 's research with the Chinchilla 70B model. Developed by DeepMind, Chinchilla 70B effectively compressed data, outperforming conventional methods such as Portable Network Graphics (PNG) for images and Free Lossless Audio Codec (FLAC) for audio. It achieved compression of image and audio data to 43.4% and 16.4% of their original sizes, respectively.",
    "source_url": "https://en.wikipedia.org/wiki/Machine_learning",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:56:53.957306",
    "symbols_found": 1,
    "id": "FOLLOW_HYBRID_1748228213957",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:56:53.957306",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:56:53.957306",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "Much of the confusion between these two research communities (which do often have separate conferences and separate journals, ECML PKDD being a major exception) comes from the basic assumptions they work with: in machine learning, performance is usually evaluated with respect to the ability to reproduce known knowledge, while in knowledge discovery and data mining (KDD) the key task is the discovery of previously unknown knowledge. Evaluated with respect to known knowledge, an uninformed (unsupervised) method will easily be outperformed by other supervised methods, while in a typical KDD task, supervised methods cannot be used due to the unavailability of training data. Machine learning also has intimate ties to optimisation : Many learning problems are formulated as minimisation of some loss function on a training set of examples.",
    "source_url": "https://en.wikipedia.org/wiki/Machine_learning",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:56:53.979450",
    "symbols_found": 1,
    "id": "FOLLOW_HYBRID_1748228213979",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:56:53.979450",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:56:53.979450",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "The signal each neuron outputs is calculated from this number, according to its activation function . The behavior of the network depends on the strengths (or weights ) of the connections between neurons. A network is trained by modifying these weights through empirical risk minimization or backpropagation in order to fit some preexisting dataset. [ 5 ] The term deep neural network refers to neural networks that have more than three layers, typically including at least two hidden layers in addition to the input and output layers. Neural networks are used to solve problems in artificial intelligence , and have thereby found applications in many disciplines, including predictive modeling , adaptive control , facial recognition , handwriting recognition , general game playing , and generative AI .",
    "source_url": "https://en.wikipedia.org/wiki/Neural_network",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:57:03.925802",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748228223925",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:57:03.925802",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:57:03.925802",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "pp. 153– 328. ISBN 978-0199773893 . ^ a b Rosenblatt, F. (1958). \"The Perceptron: A Probabilistic Model For Information Storage And Organization In The Brain\". Psychological Review . 65 (6): 386– 408. CiteSeerX 10.1.1.588.3775 . doi : 10.1037/h0042519 . PMID 13602029 . S2CID 12781225 . ^ Bishop, Christopher M. (August 17, 2006). Pattern Recognition and Machine Learning . New York: Springer. ISBN 978-0-387-31073-2 . ^ Vapnik, Vladimir N.; Vapnik, Vladimir Naumovich (1998). The nature of statistical learning theory (Corrected 2nd print. ed.). New York Berlin Heidelberg: Springer. ISBN 978-0-387-94559-0 . ^ Bain (1873). Mind and Body: The Theories of Their Relation . New York: D. Appleton and Company. ^ James (1890). The Principles of Psychology . New York: H. Holt and Company. ^ Hebb, D.O. (1949). The Organization of Behavior . New York: Wiley & Sons. ^ McCulloch, W; Pitts, W (1943). \"A Logical Calculus of Ideas Immanent in Nervous Activity\" . Bulletin of Mathematical Biophysics .",
    "source_url": "https://en.wikipedia.org/wiki/Neural_network",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:57:04.068481",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748228224069",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:57:04.069480",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:57:04.069480",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "\"A Logical Calculus of Ideas Immanent in Nervous Activity\" . Bulletin of Mathematical Biophysics . 5 (4): 115– 133. doi : 10.1007/BF02478259 . Archived from the original on May 17, 2024 . Retrieved February 17, 2024 . Retrieved from \" https://en.wikipedia.org/w/index.php?title=Neural_network&oldid=1286760457 \" Category : Neural networks Hidden categories: Articles with short description Short description matches Wikidata Use mdy dates from April 2025 Use American English from April 2025 All Wikipedia articles written in American English Broad-concept articles Neural network Add topic",
    "source_url": "https://en.wikipedia.org/wiki/Neural_network",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:57:04.086653",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748228224086",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:57:04.086653",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:57:04.086653",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "[ 96 ] [ 9 ] In 2006, publications by Geoff Hinton , Ruslan Salakhutdinov , Osindero and Teh [ 97 ] [ 98 ] deep belief networks were developed for generative modeling. They are trained by training one restricted Boltzmann machine, then freezing it and training another one on top of the first one, and so on, then optionally fine-tuned using supervised backpropagation. [ 99 ] They could model high-dimensional probability distributions, such as the distribution of MNIST images , but convergence was slow. [ 100 ] [ 101 ] [ 102 ] The impact of deep learning in industry began in the early 2000s, when CNNs already processed an estimated 10% to 20% of all the checks written in the US, according to Yann LeCun. [ 103 ] Industrial applications of deep learning to large-scale speech recognition started around 2010.",
    "source_url": "https://en.wikipedia.org/wiki/Deep_learning",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:57:09.551340",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748228229551",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:57:09.552344",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:57:09.552344",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Jlwoodwa ( talk | contribs ) at 23:48, 14 September 2024 (Undid revision 1245766465 by Jlwoodwa ( talk ): probably doesn't require frequent maintenance) . The present address (URL) is a permanent link to this version. Revision as of 23:48, 14 September 2024 by Jlwoodwa ( talk | contribs ) (Undid revision 1245766465 by Jlwoodwa ( talk ): probably doesn't require frequent maintenance)",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Algorithms_and_data_structures&oldid=1245766542",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:57:16.400356",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748228236401",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:57:16.401356",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:57:16.401356",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "= v {\\displaystyle \\gcd(0,v)=v} , gcd ( 2 u , v ) = gcd ( u , v ) {\\displaystyle \\gcd(2u,v)=\\gcd(u,v)} if v {\\displaystyle v} is odd, etc.",
    "source_url": "https://en.wikipedia.org/wiki/Binary_GCD_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:57:18.146589",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748228238146",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:57:18.146589",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:57:18.146589",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "\\displaystyle O(n\\log n)} Division Two n {\\displaystyle n} -digit numbers One n {\\displaystyle n} -digit number Schoolbook long division O ( n 2 ) {\\displaystyle O{\\mathord {\\left(n^{2}\\right)}}} Burnikel–Ziegler Divide-and-Conquer Division [ 5 ] O ( M ( n ) log ⁡ n ) {\\displaystyle O(M(n)\\log n)} Newton–Raphson division O ( M ( n ) ) {\\displaystyle O(M(n)) } Square root One n {\\displaystyle n} -digit number One n / 2 {\\displaystyle n/2} -digit number Newton's method O ( M ( n ) ) {\\displaystyle O(M(n))",
    "source_url": "https://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T02:57:42.444067",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748228262444",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T02:57:42.444067",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T02:57:42.444067",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "[ 40 ] Learning Machine learning is the study of programs that can improve their performance on a given task automatically. [ 41 ] It has been a part of AI from the beginning. [ e ] There are several kinds of machine learning. Unsupervised learning analyzes a stream of data and finds patterns and makes predictions without any other guidance. [ 44 ] Supervised learning requires labeling the training data with the expected answers, and comes in two main varieties: classification (where the program must learn to predict what category the input belongs in) and regression (where the program must deduce a numeric function based on numeric input). [ 45 ] In reinforcement learning , the agent is rewarded for good responses and punished for bad ones. The agent learns to choose responses that are classified as \"good\". [ 46 ] Transfer learning is when the knowledge gained from one problem is applied to a new problem. [ 47 ]",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:05.726780",
    "symbols_found": 1,
    "id": "FOLLOW_HYBRID_1748229425726",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:05.726780",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:05.726780",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "[ 71 ] Simple exhaustive searches [ 72 ] are rarely sufficient for most real-world problems: the search space (the number of places to search) quickly grows to astronomical numbers . The result is a search that is too slow or never completes. [ 15 ] \" Heuristics \" or \"rules of thumb\" can help prioritize choices that are more likely to reach a goal. [ 73 ] Adversarial search is used for game-playing programs, such as chess or Go. It searches through a tree of possible moves and countermoves, looking for a winning position. [ 74 ] Local search Illustration of gradient descent for 3 different starting points; two parameters (represented by the plan coordinates) are adjusted in order to minimize the loss function (the height) Local search uses mathematical optimization to find a solution to a problem. It begins with some form of guess and refines it incrementally.",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:05.750814",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748229425750",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:05.750814",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:05.750814",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "[ 133 ] Through the lens of the Hippocratic Oath , medical professionals are ethically compelled to use AI, if applications can more accurately diagnose and treat patients. [ 134 ] [ 135 ] For medical research, AI is an important tool for processing and integrating big data . This is particularly important for organoid and tissue engineering development which use microscopy imaging as a key technique in fabrication. [ 136 ] It has been suggested that AI can overcome discrepancies in funding allocated to different fields of research. [ 136 ] [ 137 ] New AI tools can deepen the understanding of biomedically relevant pathways. For example, AlphaFold 2 (2021) demonstrated the ability to approximate, in hours rather than months, the 3D structure of a protein . [ 138 ] In 2023, it was reported that AI-guided drug discovery helped find a class of antibiotics capable of killing two different types of drug-resistant bacteria.",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:05.900314",
    "symbols_found": 1,
    "id": "FOLLOW_HYBRID_1748229425900",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:05.900743",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:05.900743",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "[ 159 ] When natural language is used to describe mathematical problems, converters can transform such prompts into a formal language such as Lean to define mathematical tasks. Some models have been developed to solve challenging problems and reach good results in benchmark tests, others to serve as educational tools in mathematics. [ 160 ] Topological deep learning integrates various topological approaches. Finance Finance is one of the fastest growing sectors where applied AI tools are being deployed: from retail online banking to investment advice and insurance, where automated \"robot advisers\" have been in use for some years. [ 161 ] According to Nicolas Firzli, director of the World Pensions & Investments Forum , it may be too early to see the emergence of highly innovative AI-informed financial products and services.",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:05.923182",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748229425923",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:05.923182",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:05.923182",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "Using machine learning, AI agents can adapt to new situations and optimise their behaviour for their designated tasks. [ 185 ] [ 186 ] [ 187 ] Sexuality Applications of AI in this domain include AI-enabled menstruation and fertility trackers that analyze user data to offer prediction, [ 188 ] AI-integrated sex toys (e.g., teledildonics ), [ 189 ] AI-generated sexual education content, [ 190 ] and AI agents that simulate sexual and romantic partners (e.g., Replika ). [ 191 ] AI is also used for the production of non-consensual deepfake pornography , raising significant ethical and legal concerns. [ 192 ] AI technologies have also been used to attempt to identify online gender-based violence and online sexual grooming of minors. [ 193 ] [ 194 ] Other industry-specific tasks There are also thousands of successful AI applications used to solve specific problems for specific industries or institutions.",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:05.966109",
    "symbols_found": 1,
    "id": "FOLLOW_HYBRID_1748229425966",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:05.966109",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:05.966109",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "[ 225 ] Nvidia CEO Jen-Hsun Huang said nuclear power is a good option for the data centers. [ 226 ] In September 2024, Microsoft announced an agreement with Constellation Energy to re-open the Three Mile Island nuclear power plant to provide Microsoft with 100% of all electric power produced by the plant for 20 years. Reopening the plant, which suffered a partial nuclear meltdown of its Unit 2 reactor in 1979, will require Constellation to get through strict regulatory processes which will include extensive safety scrutiny from the US Nuclear Regulatory Commission . If approved (this will be the first ever US re-commissioning of a nuclear plant), over 835 megawatts of power – enough for 800,000 homes – of energy will be produced. The cost for re-opening and upgrading is estimated at $1.6 billion (US) and is dependent on tax breaks for nuclear power contained in the 2022 US Inflation Reduction Act .",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:06.044666",
    "symbols_found": 1,
    "id": "FOLLOW_HYBRID_1748229426044",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:06.044666",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:06.044666",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "This process condenses extensive datasets into a more compact set of representative points. Particularly beneficial in image and signal processing , k-means clustering aids in data reduction by replacing groups of data points with their centroids, thereby preserving the core information of the original data while significantly decreasing the required storage space. [ 32 ] Large language models (LLMs) are also efficient lossless data compressors on some data sets, as demonstrated by DeepMind 's research with the Chinchilla 70B model. Developed by DeepMind, Chinchilla 70B effectively compressed data, outperforming conventional methods such as Portable Network Graphics (PNG) for images and Free Lossless Audio Codec (FLAC) for audio. It achieved compression of image and audio data to 43.4% and 16.4% of their original sizes, respectively.",
    "source_url": "https://en.wikipedia.org/wiki/Machine_learning",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:21.642633",
    "symbols_found": 1,
    "id": "FOLLOW_HYBRID_1748229441643",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:21.643642",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:21.643642",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "Much of the confusion between these two research communities (which do often have separate conferences and separate journals, ECML PKDD being a major exception) comes from the basic assumptions they work with: in machine learning, performance is usually evaluated with respect to the ability to reproduce known knowledge, while in knowledge discovery and data mining (KDD) the key task is the discovery of previously unknown knowledge. Evaluated with respect to known knowledge, an uninformed (unsupervised) method will easily be outperformed by other supervised methods, while in a typical KDD task, supervised methods cannot be used due to the unavailability of training data. Machine learning also has intimate ties to optimisation : Many learning problems are formulated as minimisation of some loss function on a training set of examples.",
    "source_url": "https://en.wikipedia.org/wiki/Machine_learning",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:21.685356",
    "symbols_found": 1,
    "id": "FOLLOW_HYBRID_1748229441685",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:21.685356",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:21.685356",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "The signal each neuron outputs is calculated from this number, according to its activation function . The behavior of the network depends on the strengths (or weights ) of the connections between neurons. A network is trained by modifying these weights through empirical risk minimization or backpropagation in order to fit some preexisting dataset. [ 5 ] The term deep neural network refers to neural networks that have more than three layers, typically including at least two hidden layers in addition to the input and output layers. Neural networks are used to solve problems in artificial intelligence , and have thereby found applications in many disciplines, including predictive modeling , adaptive control , facial recognition , handwriting recognition , general game playing , and generative AI .",
    "source_url": "https://en.wikipedia.org/wiki/Neural_network",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:31.335841",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748229451335",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:31.335841",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:31.335841",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "pp. 153– 328. ISBN 978-0199773893 . ^ a b Rosenblatt, F. (1958). \"The Perceptron: A Probabilistic Model For Information Storage And Organization In The Brain\". Psychological Review . 65 (6): 386– 408. CiteSeerX 10.1.1.588.3775 . doi : 10.1037/h0042519 . PMID 13602029 . S2CID 12781225 . ^ Bishop, Christopher M. (August 17, 2006). Pattern Recognition and Machine Learning . New York: Springer. ISBN 978-0-387-31073-2 . ^ Vapnik, Vladimir N.; Vapnik, Vladimir Naumovich (1998). The nature of statistical learning theory (Corrected 2nd print. ed.). New York Berlin Heidelberg: Springer. ISBN 978-0-387-94559-0 . ^ Bain (1873). Mind and Body: The Theories of Their Relation . New York: D. Appleton and Company. ^ James (1890). The Principles of Psychology . New York: H. Holt and Company. ^ Hebb, D.O. (1949). The Organization of Behavior . New York: Wiley & Sons. ^ McCulloch, W; Pitts, W (1943). \"A Logical Calculus of Ideas Immanent in Nervous Activity\" . Bulletin of Mathematical Biophysics .",
    "source_url": "https://en.wikipedia.org/wiki/Neural_network",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:31.492339",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748229451492",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:31.492339",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:31.492339",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "\"A Logical Calculus of Ideas Immanent in Nervous Activity\" . Bulletin of Mathematical Biophysics . 5 (4): 115– 133. doi : 10.1007/BF02478259 . Archived from the original on May 17, 2024 . Retrieved February 17, 2024 . Retrieved from \" https://en.wikipedia.org/w/index.php?title=Neural_network&oldid=1286760457 \" Category : Neural networks Hidden categories: Articles with short description Short description matches Wikidata Use mdy dates from April 2025 Use American English from April 2025 All Wikipedia articles written in American English Broad-concept articles Neural network Add topic",
    "source_url": "https://en.wikipedia.org/wiki/Neural_network",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:31.521895",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748229451521",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:31.521895",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:31.521895",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "[ 96 ] [ 9 ] In 2006, publications by Geoff Hinton , Ruslan Salakhutdinov , Osindero and Teh [ 97 ] [ 98 ] deep belief networks were developed for generative modeling. They are trained by training one restricted Boltzmann machine, then freezing it and training another one on top of the first one, and so on, then optionally fine-tuned using supervised backpropagation. [ 99 ] They could model high-dimensional probability distributions, such as the distribution of MNIST images , but convergence was slow. [ 100 ] [ 101 ] [ 102 ] The impact of deep learning in industry began in the early 2000s, when CNNs already processed an estimated 10% to 20% of all the checks written in the US, according to Yann LeCun. [ 103 ] Industrial applications of deep learning to large-scale speech recognition started around 2010.",
    "source_url": "https://en.wikipedia.org/wiki/Deep_learning",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:36.943104",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748229456943",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:36.943104",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:36.943104",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article includes a list of general references , but it lacks sufficient corresponding inline citations . Please help to improve this article by introducing more precise citations. ( September 2016 ) ( Learn how and when to remove this message ) This article relies excessively on references to",
    "source_url": "https://en.wikipedia.org/wiki/Hilltop_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:46.510120",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748229466510",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:46.510120",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:46.510120",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Addbot ( talk | contribs ) at 15:38, 27 March 2013 ( Bot: Migrating 2 interwiki links, now provided by Wikidata on d:q8235199 ) . The present address (URL) is a permanent link to this version. Revision as of 15:38, 27 March 2013 by Addbot ( talk | contribs ) ( Bot: Migrating 2 interwiki links, now provided by Wikidata on d:q8235199 ) ( diff ) ← Previous revision | Latest revision (d",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Algorithms_and_data_structures_stubs&oldid=547280383",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:17:49.813790",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748229469813",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:17:49.813790",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:17:49.813790",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "Jump to content From Wikipedia, the free encyclopedia Abstract calculator This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article contains instructions, advice, or how-to content . Please help rewrite the content so that it is more encyclopedic or move it to Wikiversity , Wikibooks , or Wikivoyage . ( August 2020 ) This article is written like a research paper or a scientific journal . Please",
    "source_url": "https://en.wikipedia.org/wiki/Post%E2%80%93Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:18:14.149219",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748229494149",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:18:14.149219",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:18:14.149219",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) The topic of this article may not meet Wikipedia's general notability guideline . Please help to demonstrate the notability of the topic by citing reliable secondary sources that are independent of the topic and provide significant coverage of it beyond a mere trivial mention. If notability cannot",
    "source_url": "https://en.wikipedia.org/wiki/Raita_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:18:14.895182",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748229494895",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:18:14.895182",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:18:14.895182",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by YiFeiBot ( talk | contribs ) at 18:46, 6 May 2025 (Bot: Migrating 1 langlinks, now provided by Wikidata on d:q16002499 ) . The present address (URL) is a permanent link to this version. Revision as of 18:46, 6 May 2025 by YiFeiBot ( talk | contribs ) (Bot: Migrating 1 langlinks, now provided by Wikidata on d:q16002499 ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revisi",
    "source_url": "https://en.wikipedia.org/w/index.php?title=List_of_terms_relating_to_algorithms_and_data_structures&oldid=1289141319",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:18:22.073989",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748229502073",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:18:22.074990",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:18:22.074990",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "As GCD is commutative ( gcd ( u , v ) = gcd ( v , u ) {\\displaystyle \\gcd(u,v)=\\gcd(v,u)} ), those identities still apply if the operands are swapped: gcd ( 0 , v ) = v {\\displaystyle \\gcd(0,v)=v} , gcd ( 2 u , v ) = gcd ( u , v ) {\\displaystyle \\gcd(2u,v)=\\gcd(u,v)} if v {\\displaystyle v} is odd, etc.",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Binary_GCD_algorithm&oldid=1272402879",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:18:43.826019",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748229523826",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:18:43.826019",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:18:43.826019",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "text": "\\displaystyle O(n\\log n)} Division Two n {\\displaystyle n} -digit numbers One n {\\displaystyle n} -digit number Schoolbook long division O ( n 2 ) {\\displaystyle O{\\mathord {\\left(n^{2}\\right)}}} Burnikel–Ziegler Divide-and-Conquer Division [ 5 ] O ( M ( n ) log ⁡ n ) {\\displaystyle O(M(n)\\log n)} Newton–Raphson division O ( M ( n ) ) {\\displaystyle O(M(n)) } Square root One n {\\displaystyle n} -digit number One n / 2 {\\displaystyle n/2} -digit number Newton's method O ( M ( n ) ) {\\displaystyle O(M(n))",
    "source_url": "https://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence": 0.0,
    "phase": 1,
    "timestamp": "2025-05-26T03:18:51.020997",
    "symbols_found": 0,
    "id": "FOLLOW_HYBRID_1748229531020",
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T03:18:51.020997",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T03:18:51.020997",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Artificial_intelligence_1_1748282894826_5340",
    "text": "[ 40 ] Learning Machine learning is the study of programs that can improve their performance on a given task automatically. [ 41 ] It has been a part of AI from the beginning. [ e ] There are several kinds of machine learning. Unsupervised learning analyzes a stream of data and finds patterns and makes predictions without any other guidance. [ 44 ] Supervised learning requires labeling the training data with the expected answers, and comes in two main varieties: classification (where the program must learn to predict what category the input belongs in) and regression (where the program must deduce a numeric function based on numeric input). [ 45 ] In reinforcement learning , the agent is rewarded for good responses and punished for bad ones. The agent learns to choose responses that are classified as \"good\". [ 46 ] Transfer learning is when the knowledge gained from one problem is applied to a new problem. [ 47 ]",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:08:14.826590",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:08:14.826590",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:08:14.826590",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Artificial_intelligence_1_1748282894854_5919",
    "text": "[ 71 ] Simple exhaustive searches [ 72 ] are rarely sufficient for most real-world problems: the search space (the number of places to search) quickly grows to astronomical numbers . The result is a search that is too slow or never completes. [ 15 ] \" Heuristics \" or \"rules of thumb\" can help prioritize choices that are more likely to reach a goal. [ 73 ] Adversarial search is used for game-playing programs, such as chess or Go. It searches through a tree of possible moves and countermoves, looking for a winning position. [ 74 ] Local search Illustration of gradient descent for 3 different starting points; two parameters (represented by the plan coordinates) are adjusted in order to minimize the loss function (the height) Local search uses mathematical optimization to find a solution to a problem. It begins with some form of guess and refines it incrementally.",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:08:14.854746",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:08:14.854746",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:08:14.854746",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Artificial_intelligence_1_1748282894965_3509",
    "text": "[ 133 ] Through the lens of the Hippocratic Oath , medical professionals are ethically compelled to use AI, if applications can more accurately diagnose and treat patients. [ 134 ] [ 135 ] For medical research, AI is an important tool for processing and integrating big data . This is particularly important for organoid and tissue engineering development which use microscopy imaging as a key technique in fabrication. [ 136 ] It has been suggested that AI can overcome discrepancies in funding allocated to different fields of research. [ 136 ] [ 137 ] New AI tools can deepen the understanding of biomedically relevant pathways. For example, AlphaFold 2 (2021) demonstrated the ability to approximate, in hours rather than months, the 3D structure of a protein . [ 138 ] In 2023, it was reported that AI-guided drug discovery helped find a class of antibiotics capable of killing two different types of drug-resistant bacteria.",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:08:14.965504",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:08:14.965504",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:08:14.965504",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Artificial_intelligence_1_1748282894994_4363",
    "text": "[ 159 ] When natural language is used to describe mathematical problems, converters can transform such prompts into a formal language such as Lean to define mathematical tasks. Some models have been developed to solve challenging problems and reach good results in benchmark tests, others to serve as educational tools in mathematics. [ 160 ] Topological deep learning integrates various topological approaches. Finance Finance is one of the fastest growing sectors where applied AI tools are being deployed: from retail online banking to investment advice and insurance, where automated \"robot advisers\" have been in use for some years. [ 161 ] According to Nicolas Firzli, director of the World Pensions & Investments Forum , it may be too early to see the emergence of highly innovative AI-informed financial products and services.",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:08:14.994814",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:08:14.994814",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:08:14.994814",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Artificial_intelligence_1_1748282895030_3102",
    "text": "Using machine learning, AI agents can adapt to new situations and optimise their behaviour for their designated tasks. [ 185 ] [ 186 ] [ 187 ] Sexuality Applications of AI in this domain include AI-enabled menstruation and fertility trackers that analyze user data to offer prediction, [ 188 ] AI-integrated sex toys (e.g., teledildonics ), [ 189 ] AI-generated sexual education content, [ 190 ] and AI agents that simulate sexual and romantic partners (e.g., Replika ). [ 191 ] AI is also used for the production of non-consensual deepfake pornography , raising significant ethical and legal concerns. [ 192 ] AI technologies have also been used to attempt to identify online gender-based violence and online sexual grooming of minors. [ 193 ] [ 194 ] Other industry-specific tasks There are also thousands of successful AI applications used to solve specific problems for specific industries or institutions.",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:08:15.030527",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:08:15.030527",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:08:15.030527",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Artificial_intelligence_1_1748282895111_3024",
    "text": "[ 225 ] Nvidia CEO Jen-Hsun Huang said nuclear power is a good option for the data centers. [ 226 ] In September 2024, Microsoft announced an agreement with Constellation Energy to re-open the Three Mile Island nuclear power plant to provide Microsoft with 100% of all electric power produced by the plant for 20 years. Reopening the plant, which suffered a partial nuclear meltdown of its Unit 2 reactor in 1979, will require Constellation to get through strict regulatory processes which will include extensive safety scrutiny from the US Nuclear Regulatory Commission . If approved (this will be the first ever US re-commissioning of a nuclear plant), over 835 megawatts of power – enough for 800,000 homes – of energy will be produced. The cost for re-opening and upgrading is estimated at $1.6 billion (US) and is dependent on tax breaks for nuclear power contained in the 2022 US Inflation Reduction Act .",
    "source_url": "https://en.wikipedia.org/wiki/Artificial_intelligence",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:08:15.111315",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:08:15.111315",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:08:15.111315",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Machine_learning_1_1748282909553_6963",
    "text": "This process condenses extensive datasets into a more compact set of representative points. Particularly beneficial in image and signal processing , k-means clustering aids in data reduction by replacing groups of data points with their centroids, thereby preserving the core information of the original data while significantly decreasing the required storage space. [ 32 ] Large language models (LLMs) are also efficient lossless data compressors on some data sets, as demonstrated by DeepMind 's research with the Chinchilla 70B model. Developed by DeepMind, Chinchilla 70B effectively compressed data, outperforming conventional methods such as Portable Network Graphics (PNG) for images and Free Lossless Audio Codec (FLAC) for audio. It achieved compression of image and audio data to 43.4% and 16.4% of their original sizes, respectively.",
    "source_url": "https://en.wikipedia.org/wiki/Machine_learning",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:08:29.553528",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:08:29.553528",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:08:29.553528",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Machine_learning_1_1748282909581_3907",
    "text": "Much of the confusion between these two research communities (which do often have separate conferences and separate journals, ECML PKDD being a major exception) comes from the basic assumptions they work with: in machine learning, performance is usually evaluated with respect to the ability to reproduce known knowledge, while in knowledge discovery and data mining (KDD) the key task is the discovery of previously unknown knowledge. Evaluated with respect to known knowledge, an uninformed (unsupervised) method will easily be outperformed by other supervised methods, while in a typical KDD task, supervised methods cannot be used due to the unavailability of training data. Machine learning also has intimate ties to optimisation : Many learning problems are formulated as minimisation of some loss function on a training set of examples.",
    "source_url": "https://en.wikipedia.org/wiki/Machine_learning",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:08:29.581564",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:08:29.581564",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:08:29.581564",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Neural_network_1_1748282913576_9135",
    "text": "The signal each neuron outputs is calculated from this number, according to its activation function . The behavior of the network depends on the strengths (or weights ) of the connections between neurons. A network is trained by modifying these weights through empirical risk minimization or backpropagation in order to fit some preexisting dataset. [ 5 ] The term deep neural network refers to neural networks that have more than three layers, typically including at least two hidden layers in addition to the input and output layers. Neural networks are used to solve problems in artificial intelligence , and have thereby found applications in many disciplines, including predictive modeling , adaptive control , facial recognition , handwriting recognition , general game playing , and generative AI .",
    "source_url": "https://en.wikipedia.org/wiki/Neural_network",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:08:33.576375",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:08:33.576375",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:08:33.576375",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Neural_network_1_1748282913734_4064",
    "text": "pp. 153– 328. ISBN 978-0199773893 . ^ a b Rosenblatt, F. (1958). \"The Perceptron: A Probabilistic Model For Information Storage And Organization In The Brain\". Psychological Review . 65 (6): 386– 408. CiteSeerX 10.1.1.588.3775 . doi : 10.1037/h0042519 . PMID 13602029 . S2CID 12781225 . ^ Bishop, Christopher M. (August 17, 2006). Pattern Recognition and Machine Learning . New York: Springer. ISBN 978-0-387-31073-2 . ^ Vapnik, Vladimir N.; Vapnik, Vladimir Naumovich (1998). The nature of statistical learning theory (Corrected 2nd print. ed.). New York Berlin Heidelberg: Springer. ISBN 978-0-387-94559-0 . ^ Bain (1873). Mind and Body: The Theories of Their Relation . New York: D. Appleton and Company. ^ James (1890). The Principles of Psychology . New York: H. Holt and Company. ^ Hebb, D.O. (1949). The Organization of Behavior . New York: Wiley & Sons. ^ McCulloch, W; Pitts, W (1943). \"A Logical Calculus of Ideas Immanent in Nervous Activity\" . Bulletin of Mathematical Biophysics .",
    "source_url": "https://en.wikipedia.org/wiki/Neural_network",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:08:33.734729",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:08:33.734729",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:08:33.734729",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Neural_network_1_1748282913771_6743",
    "text": "\"A Logical Calculus of Ideas Immanent in Nervous Activity\" . Bulletin of Mathematical Biophysics . 5 (4): 115– 133. doi : 10.1007/BF02478259 . Archived from the original on May 17, 2024 . Retrieved February 17, 2024 . Retrieved from \" https://en.wikipedia.org/w/index.php?title=Neural_network&oldid=1286760457 \" Category : Neural networks Hidden categories: Articles with short description Short description matches Wikidata Use mdy dates from April 2025 Use American English from April 2025 All Wikipedia articles written in American English Broad-concept articles Neural network Add topic",
    "source_url": "https://en.wikipedia.org/wiki/Neural_network",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:08:33.771947",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:08:33.773472",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:08:33.773472",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Deep_learning_1_1748282919272_4709",
    "text": "[ 96 ] [ 9 ] In 2006, publications by Geoff Hinton , Ruslan Salakhutdinov , Osindero and Teh [ 97 ] [ 98 ] deep belief networks were developed for generative modeling. They are trained by training one restricted Boltzmann machine, then freezing it and training another one on top of the first one, and so on, then optionally fine-tuned using supervised backpropagation. [ 99 ] They could model high-dimensional probability distributions, such as the distribution of MNIST images , but convergence was slow. [ 100 ] [ 101 ] [ 102 ] The impact of deep learning in industry began in the early 2000s, when CNNs already processed an estimated 10% to 20% of all the checks written in the US, according to Yann LeCun. [ 103 ] Industrial applications of deep learning to large-scale speech recognition started around 2010.",
    "source_url": "https://en.wikipedia.org/wiki/Deep_learning",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:08:39.272288",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:08:39.272288",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:08:39.272288",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Algorithms_and_data_structures&oldid=1245766542_1_1748282925527_6783",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Jlwoodwa ( talk | contribs ) at 23:48, 14 September 2024 (Undid revision 1245766465 by Jlwoodwa ( talk ): probably doesn't require frequent maintenance) . The present address (URL) is a permanent link to this version. Revision as of 23:48, 14 September 2024 by Jlwoodwa ( talk | contribs ) (Undid revision 1245766465 by Jlwoodwa ( talk ): probably doesn't require frequent maintenance)",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Algorithms_and_data_structures&oldid=1245766542",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:08:45.527619",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:08:45.527619",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:08:45.527619",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Binary_GCD_algorithm_1_1748282941455_6858",
    "text": "= v {\\displaystyle \\gcd(0,v)=v} , gcd ( 2 u , v ) = gcd ( u , v ) {\\displaystyle \\gcd(2u,v)=\\gcd(u,v)} if v {\\displaystyle v} is odd, etc.",
    "source_url": "https://en.wikipedia.org/wiki/Binary_GCD_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:09:01.455907",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:09:01.455907",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:09:01.455907",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Computational_complexity_of_mathematical_operations_1_1748282949219_3592",
    "text": "\\displaystyle O(n\\log n)} Division Two n {\\displaystyle n} -digit numbers One n {\\displaystyle n} -digit number Schoolbook long division O ( n 2 ) {\\displaystyle O{\\mathord {\\left(n^{2}\\right)}}} Burnikel–Ziegler Divide-and-Conquer Division [ 5 ] O ( M ( n ) log ⁡ n ) {\\displaystyle O(M(n)\\log n)} Newton–Raphson division O ( M ( n ) ) {\\displaystyle O(M(n)) } Square root One n {\\displaystyle n} -digit number One n / 2 {\\displaystyle n/2} -digit number Newton's method O ( M ( n ) ) {\\displaystyle O(M(n))",
    "source_url": "https://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:09:09.219567",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:09:09.219567",
        "weights": {
          "static": 0.6,
          "dynamic": 0.4
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:09:09.219567",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_electronic_circuit_1_1748285038756_5238",
    "text": "Jump to content From Wikipedia, the free encyclopedia Not to be confused with Printed circuit board . A printed electronic circuit ( PEC ) was an ancestor of the hybrid integrated circuit (IC). PECs were common in tube (valve) equipment from the 1940s through the 1970s. Brands [ edit ] Couplate was the Centralab trademark , whilst Sprague called them BulPlates. Aerovox used the generic PEC. [ 1 ] [ 2 ] Difference from hybrid integrated circuits [ edit ] PECs contained only resistors and capacitors arranged in circuits to simplify construction of tube equipment. Also, their voltage ratings were suitable for tubes. Later, hybrid ICs contained transistors , and often monolithic integrated circuits . Their voltage ratings were suitable for the transistors they contained. [ 3 ] References [ edit ] ^ \"Vintage Components: The PEC, a.k.a. Couplate or BulPlate\" . The DHTS Store . Retrieved 2018-06-06 . ^ Allied Radio Catalog 150 (1956)",
    "source_url": "https://en.wikipedia.org/wiki/Printed_electronic_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:43:58.756129",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:43:58.756129",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:43:58.756129",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_electronic_circuit_1_1748285038785_4329",
    "text": "Couplate or BulPlate\" . The DHTS Store . Retrieved 2018-06-06 . ^ Allied Radio Catalog 150 (1956) Allied Radio Company, Chicago, pp.123 ^ \"Printed circuits\" (PDF) . www.dhtechservices.com . This electronics-related article is a stub . You can help Wikipedia by expanding it . v t e Retrieved from \" https://en.wikipedia.org/w/index.php?title=Printed_electronic_circuit&oldid=949474255 \" Categories : Electronic circuits Electronics stubs Hidden category: All stub articles Printed electronic circuit Add topic",
    "source_url": "https://en.wikipedia.org/wiki/Printed_electronic_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:43:58.785356",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:43:58.785356",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:43:58.785356",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Three-dimensional_integrated_circuit_1_1748285041958_6791",
    "text": "Jump to content From Wikipedia, the free encyclopedia Integrated circuit composed of several vertically stacked chips A three-dimensional integrated circuit ( 3D IC ) is a MOS (metal-oxide semiconductor) integrated circuit (IC) manufactured by stacking as many as 16 or more ICs and interconnecting them vertically using, for instance, through-silicon vias (TSVs) or Cu-Cu connections, [ 1 ] [ 2 ] so that they behave as a single device to achieve performance improvements at reduced power and smaller footprint than conventional two dimensional processes. The 3D IC is one of several 3D integration schemes that exploit the z-direction to achieve electrical performance benefits in microelectronics and nanoelectronics . 3D integrated circuits can be classified by their level of interconnect hierarchy at the global ( package ), intermediate (bond pad) and local ( transistor ) level.",
    "source_url": "https://en.wikipedia.org/wiki/Three-dimensional_integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:44:01.958829",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:44:01.964824",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:44:01.964824",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Three-dimensional_integrated_circuit_1_1748285042053_9610",
    "text": "The interposer may be made of silicon, and is under the dies it connects together. A design can be split into several dies, and then mounted on the interposer with micro bumps. [ 7 ] [ 8 ] [ 9 ] 3D ICs can be divided into 3D Stacked ICs (3D SIC), which refers to advanced packaging techniques [ 10 ] [ 11 ] [ 12 ] stacking IC chips using TSV interconnects, and monolithic 3D ICs, which use fab processes to realize 3D interconnects at the local levels of the on-chip wiring hierarchy as set forth by the ITRS, this results in direct vertical interconnects between device layers. The first examples of a monolithic approach are seen in Samsung 's 3D V-NAND devices. [ 13 ] As of the 2010s, 3D IC packages are widely used for NAND flash memory in mobile devices . [ 14 ] One master die and three slave dies 3D SiCs [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Three-dimensional_integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:44:02.053482",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:44:02.054491",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:44:02.054491",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Three-dimensional_integrated_circuit_1_1748285042172_5491",
    "text": "CEA-Leti also developed monolithic 3D IC approaches, called sequential 3D IC. In 2014, the French research institute introduced its CoolCube™, a low-temperature process flow that provides a true path to 3DVLSI. [ 16 ] At Stanford University, researchers designed monolithic 3D ICs using carbon nanotube (CNT) structures vs. silicon using a wafer-scale low temperature CNT transfer processes that can be done at 120 °C. [ 17 ] Manufacturing technologies for 3D SiCs [ edit ] There are several methods for 3D IC design, including recrystallization and wafer bonding methods. There are two major types of wafer bonding, Cu-Cu connections (copper-to-copper connections between stacked ICs, used in TSVs) [ 18 ] [ 19 ] and through-silicon via (TSV). 3D ICs with TSVs may use solder microbumps, small solder balls as an interface between two individual dies in a 3D IC.",
    "source_url": "https://en.wikipedia.org/wiki/Three-dimensional_integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:44:02.172221",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:44:02.172221",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:44:02.172221",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Three-dimensional_integrated_circuit_1_1748285042226_8622",
    "text": "[ 20 ] As of 2014, a number of memory products such as High Bandwidth Memory (HBM) and the Hybrid Memory Cube have been launched that implement 3D IC stacking with TSVs. There are a number of key stacking approaches being implemented and explored. These include die-to-die, die-to-wafer, and wafer-to-wafer. Die-to-Die Electronic components are built on multiple die, which are then aligned and bonded. Thinning and TSV creation may be done before or after bonding. One advantage of die-to-die is that each component die can be tested first, so that one bad die does not ruin an entire stack. [ 21 ] Moreover, each die in the 3D IC can be binned beforehand, so that they can be mixed and matched to optimize power consumption and performance (e.g. matching multiple dice from the low power process corner for a mobile application). Die-to-Wafer Electronic components are built on two semiconductor wafers.",
    "source_url": "https://en.wikipedia.org/wiki/Three-dimensional_integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:44:02.226354",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:44:02.226473",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:44:02.226473",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Three-dimensional_integrated_circuit_1_1748285042259_1251",
    "text": "Die-to-Wafer Electronic components are built on two semiconductor wafers. One wafer is diced; the singulated dice are aligned and bonded onto die sites of the second wafer. As in the wafer-on-wafer method, thinning and TSV creation are performed either before or after bonding. Additional die may be added to the stacks before dicing. [ 22 ] Wafer-to-Wafer Electronic components are built on two or more semiconductor wafers , which are then aligned, bonded, and diced into 3D ICs. Each wafer may be thinned before or after bonding. Vertical connections are either built into the wafers before bonding or else created in the stack after bonding. These \" through-silicon vias \" (TSVs) pass through the silicon substrate(s) between active layers and/or between an active layer and an external bond pad. Wafer-to-wafer bonding can reduce yields, since if any 1 of N chips in a 3D IC are defective, the entire 3D IC will be defective.",
    "source_url": "https://en.wikipedia.org/wiki/Three-dimensional_integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:44:02.259475",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:44:02.260559",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:44:02.260559",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Three-dimensional_integrated_circuit_1_1748285042283_6476",
    "text": "Moreover, the wafers must be the same size, but many exotic materials (e.g. III-Vs) are manufactured on much smaller wafers than CMOS logic or DRAM (typically 300 mm), complicating heterogeneous integration. Benefits [ edit ] While traditional CMOS scaling processes improves signal propagation speed, scaling from current manufacturing and chip-design technologies is becoming more difficult and costly, in part because of power-density constraints, and in part because interconnects do not become faster while transistors do. [ 23 ] 3D ICs address the scaling challenge by stacking 2D dies and connecting them in the 3rd dimension. This promises to speed up communication between layered chips, compared to planar layout. [ 24 ] 3D ICs promise many significant benefits, including: Footprint More functionality fits into a small space.",
    "source_url": "https://en.wikipedia.org/wiki/Three-dimensional_integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:44:02.283562",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:44:02.283562",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:44:02.283562",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lean_manufacturing_1_1748285047803_1527",
    "text": "[ 7 ] The two experts were the first to apply these newly developed statistical models to improve efficiencies in many of America's largest military manufacturers during WWII. However, Deming and Shewhart failed to convince other US manufacturers to apply these \"radical\" methods. After the war, Deming was assigned to participate in the Reconstruction of Japan by General Douglas MacArthur . Deming participated as a manufacturing consultant for Japan's struggling heavy industries, which included Toyota and Mitsubishi . Unlike what they experienced in the US, Deming found the Japanese very receptive to learning and applying these new efficiency methods. Many of the manufacturing methods first introduced by Deming in Japan, and later innovated by Japanese companies, are what we now call Lean Manufacturing. Japanese manufacturers still recognize Deming for his contributions to modern Japanese efficiency practices by awarding the best manufacturers in the world the Deming Prize .",
    "source_url": "https://en.wikipedia.org/wiki/Lean_manufacturing",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:44:07.803604",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:44:07.803604",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:44:07.803604",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lean_manufacturing_1_1748285047880_2516",
    "text": "Thus, the Japanese \"leaned out\" their processes. \"They built smaller factories ... in which the only materials housed in the factory were those on which work was currently being done. In this way, inventory levels were kept low, investment in in-process inventories was at a minimum, and the investment in purchased natural resources was quickly turned around so that additional materials were purchased.\" Plenert goes on to explain Toyota's key role in developing this lean or just-in-time production methodology. [ 12 ] American industrialists recognized the threat of cheap offshore labor to American workers during the 1910s and explicitly stated the goal of what is now called lean manufacturing as a countermeasure.",
    "source_url": "https://en.wikipedia.org/wiki/Lean_manufacturing",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:44:07.880252",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:44:07.880252",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:44:07.880252",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Hilltop_algorithm_1_1748285059298_1873",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article includes a list of general references , but it lacks sufficient corresponding inline citations . Please help to improve this article by introducing more precise citations. ( September 2016 ) ( Learn how and when to remove this message ) This article relies excessively on references to",
    "source_url": "https://en.wikipedia.org/wiki/Hilltop_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:44:19.298910",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:44:19.300913",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:44:19.300913",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Algorithms_and_data_structures_stubs&oldid=547280383_1_1748285062462_4230",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Addbot ( talk | contribs ) at 15:38, 27 March 2013 ( Bot: Migrating 2 interwiki links, now provided by Wikidata on d:q8235199 ) . The present address (URL) is a permanent link to this version. Revision as of 15:38, 27 March 2013 by Addbot ( talk | contribs ) ( Bot: Migrating 2 interwiki links, now provided by Wikidata on d:q8235199 ) ( diff ) ← Previous revision | Latest revision (d",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Algorithms_and_data_structures_stubs&oldid=547280383",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:44:22.462727",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:44:22.462727",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:44:22.462727",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Post%E2%80%93Turing_machine_1_1748285086566_8817",
    "text": "Jump to content From Wikipedia, the free encyclopedia Abstract calculator This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article contains instructions, advice, or how-to content . Please help rewrite the content so that it is more encyclopedic or move it to Wikiversity , Wikibooks , or Wikivoyage . ( August 2020 ) This article is written like a research paper or a scientific journal . Please",
    "source_url": "https://en.wikipedia.org/wiki/Post%E2%80%93Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:44:46.566806",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:44:46.566806",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:44:46.566806",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Raita_algorithm_1_1748285087601_1248",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) The topic of this article may not meet Wikipedia's general notability guideline . Please help to demonstrate the notability of the topic by citing reliable secondary sources that are independent of the topic and provide significant coverage of it beyond a mere trivial mention. If notability cannot",
    "source_url": "https://en.wikipedia.org/wiki/Raita_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:44:47.601430",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:44:47.601430",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:44:47.601430",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=List_of_terms_relating_to_algorithms_and_data_structures&oldid=1289141319_1_1748285094007_7812",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by YiFeiBot ( talk | contribs ) at 18:46, 6 May 2025 (Bot: Migrating 1 langlinks, now provided by Wikidata on d:q16002499 ) . The present address (URL) is a permanent link to this version. Revision as of 18:46, 6 May 2025 by YiFeiBot ( talk | contribs ) (Bot: Migrating 1 langlinks, now provided by Wikidata on d:q16002499 ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revisi",
    "source_url": "https://en.wikipedia.org/w/index.php?title=List_of_terms_relating_to_algorithms_and_data_structures&oldid=1289141319",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:44:54.007654",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:44:54.007654",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:44:54.007654",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Computational_complexity_of_mathematical_operations_1_1748285109846_1469",
    "text": "\\displaystyle O(n\\log n)} Division Two n {\\displaystyle n} -digit numbers One n {\\displaystyle n} -digit number Schoolbook long division O ( n 2 ) {\\displaystyle O{\\mathord {\\left(n^{2}\\right)}}} Burnikel–Ziegler Divide-and-Conquer Division [ 5 ] O ( M ( n ) log ⁡ n ) {\\displaystyle O(M(n)\\log n)} Newton–Raphson division O ( M ( n ) ) {\\displaystyle O(M(n)) } Square root One n {\\displaystyle n} -digit number One n / 2 {\\displaystyle n/2} -digit number Newton's method O ( M ( n ) ) {\\displaystyle O(M(n))",
    "source_url": "https://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T18:45:09.846969",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T18:45:09.847093",
        "weights": {
          "static": 0.769,
          "dynamic": 0.231
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T18:45:09.847093",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_electronic_circuit_1_1748286006199_1718",
    "text": "Jump to content From Wikipedia, the free encyclopedia Not to be confused with Printed circuit board . A printed electronic circuit ( PEC ) was an ancestor of the hybrid integrated circuit (IC). PECs were common in tube (valve) equipment from the 1940s through the 1970s. Brands [ edit ] Couplate was the Centralab trademark , whilst Sprague called them BulPlates. Aerovox used the generic PEC. [ 1 ] [ 2 ] Difference from hybrid integrated circuits [ edit ] PECs contained only resistors and capacitors arranged in circuits to simplify construction of tube equipment. Also, their voltage ratings were suitable for tubes. Later, hybrid ICs contained transistors , and often monolithic integrated circuits . Their voltage ratings were suitable for the transistors they contained. [ 3 ] References [ edit ] ^ \"Vintage Components: The PEC, a.k.a. Couplate or BulPlate\" . The DHTS Store . Retrieved 2018-06-06 . ^ Allied Radio Catalog 150 (1956)",
    "source_url": "https://en.wikipedia.org/wiki/Printed_electronic_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:06.199529",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:06.199529",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:06.199529",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_electronic_circuit_1_1748286006214_4854",
    "text": "Couplate or BulPlate\" . The DHTS Store . Retrieved 2018-06-06 . ^ Allied Radio Catalog 150 (1956) Allied Radio Company, Chicago, pp.123 ^ \"Printed circuits\" (PDF) . www.dhtechservices.com . This electronics-related article is a stub . You can help Wikipedia by expanding it . v t e Retrieved from \" https://en.wikipedia.org/w/index.php?title=Printed_electronic_circuit&oldid=949474255 \" Categories : Electronic circuits Electronics stubs Hidden category: All stub articles Printed electronic circuit Add topic",
    "source_url": "https://en.wikipedia.org/wiki/Printed_electronic_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:06.214532",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:06.214532",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:06.214532",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Three-dimensional_integrated_circuit_1_1748286010055_1313",
    "text": "Jump to content From Wikipedia, the free encyclopedia Integrated circuit composed of several vertically stacked chips A three-dimensional integrated circuit ( 3D IC ) is a MOS (metal-oxide semiconductor) integrated circuit (IC) manufactured by stacking as many as 16 or more ICs and interconnecting them vertically using, for instance, through-silicon vias (TSVs) or Cu-Cu connections, [ 1 ] [ 2 ] so that they behave as a single device to achieve performance improvements at reduced power and smaller footprint than conventional two dimensional processes. The 3D IC is one of several 3D integration schemes that exploit the z-direction to achieve electrical performance benefits in microelectronics and nanoelectronics . 3D integrated circuits can be classified by their level of interconnect hierarchy at the global ( package ), intermediate (bond pad) and local ( transistor ) level.",
    "source_url": "https://en.wikipedia.org/wiki/Three-dimensional_integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:10.055756",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:10.056756",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:10.056756",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Three-dimensional_integrated_circuit_1_1748286010158_5847",
    "text": "The interposer may be made of silicon, and is under the dies it connects together. A design can be split into several dies, and then mounted on the interposer with micro bumps. [ 7 ] [ 8 ] [ 9 ] 3D ICs can be divided into 3D Stacked ICs (3D SIC), which refers to advanced packaging techniques [ 10 ] [ 11 ] [ 12 ] stacking IC chips using TSV interconnects, and monolithic 3D ICs, which use fab processes to realize 3D interconnects at the local levels of the on-chip wiring hierarchy as set forth by the ITRS, this results in direct vertical interconnects between device layers. The first examples of a monolithic approach are seen in Samsung 's 3D V-NAND devices. [ 13 ] As of the 2010s, 3D IC packages are widely used for NAND flash memory in mobile devices . [ 14 ] One master die and three slave dies 3D SiCs [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Three-dimensional_integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:10.158287",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:10.158287",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:10.158287",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Three-dimensional_integrated_circuit_1_1748286010248_4988",
    "text": "CEA-Leti also developed monolithic 3D IC approaches, called sequential 3D IC. In 2014, the French research institute introduced its CoolCube™, a low-temperature process flow that provides a true path to 3DVLSI. [ 16 ] At Stanford University, researchers designed monolithic 3D ICs using carbon nanotube (CNT) structures vs. silicon using a wafer-scale low temperature CNT transfer processes that can be done at 120 °C. [ 17 ] Manufacturing technologies for 3D SiCs [ edit ] There are several methods for 3D IC design, including recrystallization and wafer bonding methods. There are two major types of wafer bonding, Cu-Cu connections (copper-to-copper connections between stacked ICs, used in TSVs) [ 18 ] [ 19 ] and through-silicon via (TSV). 3D ICs with TSVs may use solder microbumps, small solder balls as an interface between two individual dies in a 3D IC.",
    "source_url": "https://en.wikipedia.org/wiki/Three-dimensional_integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:10.248643",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:10.248643",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:10.248643",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Three-dimensional_integrated_circuit_1_1748286010276_3309",
    "text": "[ 20 ] As of 2014, a number of memory products such as High Bandwidth Memory (HBM) and the Hybrid Memory Cube have been launched that implement 3D IC stacking with TSVs. There are a number of key stacking approaches being implemented and explored. These include die-to-die, die-to-wafer, and wafer-to-wafer. Die-to-Die Electronic components are built on multiple die, which are then aligned and bonded. Thinning and TSV creation may be done before or after bonding. One advantage of die-to-die is that each component die can be tested first, so that one bad die does not ruin an entire stack. [ 21 ] Moreover, each die in the 3D IC can be binned beforehand, so that they can be mixed and matched to optimize power consumption and performance (e.g. matching multiple dice from the low power process corner for a mobile application). Die-to-Wafer Electronic components are built on two semiconductor wafers.",
    "source_url": "https://en.wikipedia.org/wiki/Three-dimensional_integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:10.276641",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:10.276641",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:10.276641",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Three-dimensional_integrated_circuit_1_1748286010303_5525",
    "text": "Die-to-Wafer Electronic components are built on two semiconductor wafers. One wafer is diced; the singulated dice are aligned and bonded onto die sites of the second wafer. As in the wafer-on-wafer method, thinning and TSV creation are performed either before or after bonding. Additional die may be added to the stacks before dicing. [ 22 ] Wafer-to-Wafer Electronic components are built on two or more semiconductor wafers , which are then aligned, bonded, and diced into 3D ICs. Each wafer may be thinned before or after bonding. Vertical connections are either built into the wafers before bonding or else created in the stack after bonding. These \" through-silicon vias \" (TSVs) pass through the silicon substrate(s) between active layers and/or between an active layer and an external bond pad. Wafer-to-wafer bonding can reduce yields, since if any 1 of N chips in a 3D IC are defective, the entire 3D IC will be defective.",
    "source_url": "https://en.wikipedia.org/wiki/Three-dimensional_integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:10.303641",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:10.303641",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:10.303641",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Three-dimensional_integrated_circuit_1_1748286010326_1937",
    "text": "Moreover, the wafers must be the same size, but many exotic materials (e.g. III-Vs) are manufactured on much smaller wafers than CMOS logic or DRAM (typically 300 mm), complicating heterogeneous integration. Benefits [ edit ] While traditional CMOS scaling processes improves signal propagation speed, scaling from current manufacturing and chip-design technologies is becoming more difficult and costly, in part because of power-density constraints, and in part because interconnects do not become faster while transistors do. [ 23 ] 3D ICs address the scaling challenge by stacking 2D dies and connecting them in the 3rd dimension. This promises to speed up communication between layered chips, compared to planar layout. [ 24 ] 3D ICs promise many significant benefits, including: Footprint More functionality fits into a small space.",
    "source_url": "https://en.wikipedia.org/wiki/Three-dimensional_integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:10.326644",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:10.326644",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:10.326644",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lean_manufacturing_1_1748286015759_6539",
    "text": "[ 7 ] The two experts were the first to apply these newly developed statistical models to improve efficiencies in many of America's largest military manufacturers during WWII. However, Deming and Shewhart failed to convince other US manufacturers to apply these \"radical\" methods. After the war, Deming was assigned to participate in the Reconstruction of Japan by General Douglas MacArthur . Deming participated as a manufacturing consultant for Japan's struggling heavy industries, which included Toyota and Mitsubishi . Unlike what they experienced in the US, Deming found the Japanese very receptive to learning and applying these new efficiency methods. Many of the manufacturing methods first introduced by Deming in Japan, and later innovated by Japanese companies, are what we now call Lean Manufacturing. Japanese manufacturers still recognize Deming for his contributions to modern Japanese efficiency practices by awarding the best manufacturers in the world the Deming Prize .",
    "source_url": "https://en.wikipedia.org/wiki/Lean_manufacturing",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:15.759725",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:15.759725",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:15.759725",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lean_manufacturing_1_1748286015830_5554",
    "text": "Thus, the Japanese \"leaned out\" their processes. \"They built smaller factories ... in which the only materials housed in the factory were those on which work was currently being done. In this way, inventory levels were kept low, investment in in-process inventories was at a minimum, and the investment in purchased natural resources was quickly turned around so that additional materials were purchased.\" Plenert goes on to explain Toyota's key role in developing this lean or just-in-time production methodology. [ 12 ] American industrialists recognized the threat of cheap offshore labor to American workers during the 1910s and explicitly stated the goal of what is now called lean manufacturing as a countermeasure.",
    "source_url": "https://en.wikipedia.org/wiki/Lean_manufacturing",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:15.830319",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:15.830381",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:15.830381",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_circuit_board_1_1748286023177_5504",
    "text": "[ 1 ] PCBs are used to connect or \"wire\" components to one another in an electronic circuit . Electrical components may be fixed to conductive pads on the outer layers, generally by soldering , which both electrically connects and mechanically fastens the components to the board. Another manufacturing process adds vias , metal-lined drilled holes that enable electrical interconnections between conductive layers, to boards with more than a single side. Printed circuit boards are used in nearly all electronic products today. Alternatives to PCBs include wire wrap and point-to-point construction , both once popular but now rarely used. PCBs require additional design effort to lay out the circuit, but manufacturing and assembly can be automated. Electronic design automation software is available to do much of the work of layout. Mass-producing circuits with PCBs is cheaper and faster than with other wiring methods, as components are mounted and wired in one operation.",
    "source_url": "https://en.wikipedia.org/wiki/Printed_circuit_board",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:23.177912",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:23.178710",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:23.178710",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_circuit_board_1_1748286023271_1381",
    "text": "Development of the methods used in modern printed circuit boards started early in the 20th century. In 1903, a German inventor, Albert Hanson, described flat foil conductors laminated to an insulating board, in multiple layers. Thomas Edison experimented with chemical methods of plating conductors onto linen paper in 1904. Arthur Berry in 1913 patented a print-and- etch method in the UK, and in the United States Max Schoop obtained a patent [ 5 ] to flame-spray metal onto a board through a patterned mask. Charles Ducas in 1925 patented a method of electroplating circuit patterns. [ 6 ] Predating the printed circuit invention, and similar in spirit, was John Sargrove 's 1936–1947 Electronic Circuit Making Equipment (ECME) that sprayed metal onto a Bakelite plastic board. The ECME could produce three radio boards per minute.",
    "source_url": "https://en.wikipedia.org/wiki/Printed_circuit_board",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:23.271082",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:23.271082",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:23.271082",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_circuit_board_1_1748286023383_6540",
    "text": "Post-war developments [ edit ] In 1948, the US released the invention for commercial use. Printed circuits did not become commonplace in consumer electronics until the mid-1950s, after the Auto-Sembly process was developed by the United States Army. At around the same time in the UK work along similar lines was carried out by Geoffrey Dummer , then at the RRDE . Motorola was an early leader in bringing the process into consumer electronics, announcing in August 1952 the adoption of \"plated circuits\" in home radios after six years of research and a $1M investment. [ 10 ] Motorola soon began using its trademarked term for the process, PLAcir, in its consumer radio advertisements. [ 11 ] Hallicrafters released its first \"foto-etch\" printed circuit product, a clock-radio, on November 1, 1952. [ 12 ] Even as circuit boards became available, the point-to-point chassis construction method remained in common use in industry (such as TV and hi-fi sets) into at least the late 1960s.",
    "source_url": "https://en.wikipedia.org/wiki/Printed_circuit_board",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:23.383250",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:23.383250",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:23.383250",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_circuit_board_1_1748286023419_6780",
    "text": "Printed circuit boards were introduced to reduce the size, weight, and cost of parts of the circuitry. In 1960, a small consumer radio receiver might be built with all its circuitry on one circuit board, but a TV set would probably contain  one or more circuit boards. Originally, every electronic component had wire leads , and a PCB had holes drilled for each wire of each component. The component leads were then inserted through the holes and soldered to the copper PCB traces. This method of assembly is called through-hole construction . In 1949, Moe Abramson and Stanislaus F. Danko of the United States Army Signal Corps developed the Auto-Sembly process in which component leads were inserted into a copper foil interconnection pattern and dip soldered . The patent they obtained in 1956 was assigned to the U.S. Army. [ 13 ] With the development of board lamination and etching techniques, this concept evolved into the standard printed circuit board fabrication process in use today.",
    "source_url": "https://en.wikipedia.org/wiki/Printed_circuit_board",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:23.419250",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:23.419250",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:23.419250",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Integrated_circuit_1_1748286029806_8696",
    "text": "[ 14 ] He gave many symposia publicly to propagate his ideas and unsuccessfully attempted to build such a circuit in 1956. Between 1953 and 1957, Sidney Darlington and Yasuo Tarui ( Electrotechnical Laboratory ) proposed similar chip designs where several transistors could share a common active area, but there was no electrical isolation to separate them from each other. [ 11 ] The monolithic integrated circuit chip was enabled by the inventions of the planar process by Jean Hoerni and p–n junction isolation by Kurt Lehovec . Hoerni's invention was built on Carl Frosch and Lincoln Derick's work on surface protection and passivation by silicon dioxide masking and predeposition, [ 15 ] [ 16 ] [ 17 ] as well as Fuller, Ditzenberger's and others work on the diffusion of impurities into silicon. [ 18 ] [ 19 ] [ 20 ] [ 21 ] [ 22 ]",
    "source_url": "https://en.wikipedia.org/wiki/Integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:29.806425",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:29.806425",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:29.806425",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Integrated_circuit_1_1748286029856_8416",
    "text": "Newly employed by Texas Instruments , Kilby recorded his initial ideas concerning the integrated circuit in July 1958, successfully demonstrating the first working example of an integrated circuit on 12 September 1958. [ 26 ] In his patent application of 6 February 1959, [ 27 ] Kilby described his new device as \"a body of semiconductor material … wherein all the components of the electronic circuit are completely integrated\". [ 28 ] The first customer for the new invention was the US Air Force . [ 29 ] Kilby won the 2000 Nobel Prize in physics for his part in the invention of the integrated circuit. [ 30 ] However, Kilby's invention was not a true monolithic integrated circuit chip since it had external gold-wire connections, which would have made it difficult to mass-produce. [ 31 ] Half a year after Kilby, Robert Noyce at Fairchild Semiconductor invented the first true monolithic IC chip.",
    "source_url": "https://en.wikipedia.org/wiki/Integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:29.856423",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:29.856423",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:29.856423",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Integrated_circuit_1_1748286030057_5066",
    "text": "These devices were developed in the late 1980s [ 58 ] and are used in a variety of commercial and military applications. Examples include DLP projectors , inkjet printers , and accelerometers and MEMS gyroscopes used to deploy automobile airbags . Since the early 2000s, the integration of optical functionality ( optical computing ) into silicon chips has been actively pursued in both academic research and in industry resulting in the successful commercialization of silicon based integrated optical transceivers combining optical devices (modulators, detectors, routing) with CMOS based electronics. [ 59 ] Photonic integrated circuits that use light such as Lightelligence's PACE (Photonic Arithmetic Computing Engine) also being developed, using the emerging field of physics known as photonics . [ 60 ] Integrated circuits are also being developed for sensor applications in medical implants or other bioelectronic devices.",
    "source_url": "https://en.wikipedia.org/wiki/Integrated_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:30.057893",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:30.057893",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:30.057893",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Electronic_circuit_1_1748286035990_7428",
    "text": "[ 1 ] Circuits can be constructed of discrete components connected by individual pieces of wire, but today it is much more common to create interconnections by photolithographic techniques on a laminated substrate (a printed circuit board or PCB) and solder the components to these interconnections to create a finished circuit. In an integrated circuit or IC, the components and interconnections are formed on the same substrate, typically a semiconductor such as doped silicon or (less commonly) gallium arsenide . [ 2 ] An electronic circuit can usually be categorized as an analog circuit , a digital circuit , or a mixed-signal circuit (a combination of analog circuits and digital circuits). The most widely used semiconductor device in electronic circuits is the MOSFET (metal–oxide–semiconductor field-effect transistor ). [ 3 ] Analog circuits [ edit ] Main article:",
    "source_url": "https://en.wikipedia.org/wiki/Electronic_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:35.990711",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:35.991703",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:35.991703",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Electronic_circuit_1_1748286036038_3968",
    "text": "[ 3 ] Analog circuits [ edit ] Main article: Analogue electronics A circuit diagram representing an analog circuit, in this case a simple amplifier Analog electronic circuits are those in which current or voltage may vary continuously with time to correspond to the information being represented. A simple schematic showing wires, a resistor, and a battery The basic components of analog circuits are wires, resistors, capacitors, inductors, diodes , and transistors . Analog circuits are very commonly represented in schematic diagrams , in which wires are shown as lines, and each component has a unique symbol. Analog circuit analysis employs Kirchhoff's circuit laws : all the currents at a node (a place where wires meet), and the voltage around a closed loop of wires is 0. Wires are usually treated as ideal zero-voltage interconnections; any resistance or reactance is captured by explicitly adding a parasitic element, such as a discrete resistor or inductor.",
    "source_url": "https://en.wikipedia.org/wiki/Electronic_circuit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:36.038466",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:36.038466",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:36.038466",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Algorithms_and_data_structures&oldid=1245766542_1_1748286038607_9316",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Jlwoodwa ( talk | contribs ) at 23:48, 14 September 2024 (Undid revision 1245766465 by Jlwoodwa ( talk ): probably doesn't require frequent maintenance) . The present address (URL) is a permanent link to this version. Revision as of 23:48, 14 September 2024 by Jlwoodwa ( talk | contribs ) (Undid revision 1245766465 by Jlwoodwa ( talk ): probably doesn't require frequent maintenance)",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Algorithms_and_data_structures&oldid=1245766542",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:38.607077",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:38.607077",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:38.607077",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Binary_GCD_algorithm_1_1748286040522_6543",
    "text": "= v {\\displaystyle \\gcd(0,v)=v} , gcd ( 2 u , v ) = gcd ( u , v ) {\\displaystyle \\gcd(2u,v)=\\gcd(u,v)} if v {\\displaystyle v} is odd, etc.",
    "source_url": "https://en.wikipedia.org/wiki/Binary_GCD_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:00:40.522257",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:00:40.522257",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:00:40.522257",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lean_manufacturing_1_1748286330756_1087",
    "text": "[ 7 ] The two experts were the first to apply these newly developed statistical models to improve efficiencies in many of America's largest military manufacturers during WWII. However, Deming and Shewhart failed to convince other US manufacturers to apply these \"radical\" methods. After the war, Deming was assigned to participate in the Reconstruction of Japan by General Douglas MacArthur . Deming participated as a manufacturing consultant for Japan's struggling heavy industries, which included Toyota and Mitsubishi . Unlike what they experienced in the US, Deming found the Japanese very receptive to learning and applying these new efficiency methods. Many of the manufacturing methods first introduced by Deming in Japan, and later innovated by Japanese companies, are what we now call Lean Manufacturing. Japanese manufacturers still recognize Deming for his contributions to modern Japanese efficiency practices by awarding the best manufacturers in the world the Deming Prize .",
    "source_url": "https://en.wikipedia.org/wiki/Lean_manufacturing",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:05:30.756465",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:05:30.756465",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:05:30.756465",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lean_manufacturing_1_1748286330830_1703",
    "text": "Thus, the Japanese \"leaned out\" their processes. \"They built smaller factories ... in which the only materials housed in the factory were those on which work was currently being done. In this way, inventory levels were kept low, investment in in-process inventories was at a minimum, and the investment in purchased natural resources was quickly turned around so that additional materials were purchased.\" Plenert goes on to explain Toyota's key role in developing this lean or just-in-time production methodology. [ 12 ] American industrialists recognized the threat of cheap offshore labor to American workers during the 1910s and explicitly stated the goal of what is now called lean manufacturing as a countermeasure.",
    "source_url": "https://en.wikipedia.org/wiki/Lean_manufacturing",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:05:30.830213",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:05:30.830538",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:05:30.830538",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_electronics_1_1748286334178_9578",
    "text": "Jump to content From Wikipedia, the free encyclopedia Electronic devices created by various printing methods Not to be confused with Printed circuit board . Gravure printing of electronic structures on paper Printed electronics is a set of printing methods used to create electrical devices on various substrates. Printing typically uses common printing equipment suitable for defining patterns on material, such as screen printing , flexography , gravure , offset lithography , and inkjet . By electronic-industry standards, these are low-cost processes. Electrically functional electronic or optical inks are deposited on the substrate, creating active or passive devices, such as thin film transistors , capacitors, coils, and resistors .",
    "source_url": "https://en.wikipedia.org/wiki/Printed_electronics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:05:34.178608",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:05:34.179608",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:05:34.179608",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_electronics_1_1748286334202_5930",
    "text": "Some researchers expect printed electronics to facilitate widespread, very low-cost, low-performance electronics for applications such as flexible displays , smart labels , decorative and animated posters, and active clothing that do not require high performance. [ 1 ] The term printed electronics is often related [ by whom? ] to organic electronics or plastic electronics , in which one or more inks are composed of carbon-based compounds. [ 2 ] [ need quotation to verify ] These other terms refer to the ink material, which can be deposited by solution-based, vacuum-based, or other processes. Printed electronics, in contrast, specifies the process, and, subject to the specific requirements of the printing process selected, can utilize any solution-based material. This includes organic semiconductors , inorganic semiconductors , metallic conductors, nanoparticles , and nanotubes . The solution usually consist of filler materials dispersed in a suitable solvent.",
    "source_url": "https://en.wikipedia.org/wiki/Printed_electronics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:05:34.202741",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:05:34.203742",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:05:34.203742",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_electronics_1_1748286334234_2768",
    "text": "The solution usually consist of filler materials dispersed in a suitable solvent. The most commonly used solvents include ethanol, xylene, Dimethylformamide (DMF), Dimethyl sulfoxide (DMSO), toluene and water, whereas, the most common conductive fillers include silver nanoparticles, silver flakes, carbon black, graphene, carbon nanotubes, conductive polymers (such as polyaniline and polypyrrole), and metal powders (such as copper or nickel). Considering the environmental impacts of the organic solvents, researchers are now focused on developing printable inks using water. [ 3 ] [ 4 ] [ 5 ] For the preparation of printed electronics nearly all industrial printing methods are employed. Similar to conventional printing, printed electronics applies ink layers one atop another. [ 6 ] So the coherent development of printing methods and ink materials are the field's essential tasks. [ 7 ] The most important benefit of printing is low-cost volume fabrication.",
    "source_url": "https://en.wikipedia.org/wiki/Printed_electronics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:05:34.234741",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:05:34.234741",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:05:34.234741",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_electronics_1_1748286334344_2339",
    "text": "The selection of the printing method used is determined by requirements concerning printed layers, by the properties of printed materials as well as economic and technical considerations of the final printed products. Printing technologies divide between sheet-based and roll-to-roll -based approaches. Sheet-based inkjet and screen printing are best for low-volume, high-precision work. Gravure , offset and flexographic printing are more common for high-volume production, such as solar cells, reaching 10,000 square meters per hour (m 2 /h). [ 9 ] [ 11 ] While offset and flexographic printing are mainly used for inorganic [ 12 ] [ 13 ] and organic [ 14 ] [ 15 ] conductors (the latter also for dielectrics), [ 16 ] gravure printing is especially suitable for quality-sensitive layers like organic semiconductors and semiconductor/dielectric-interfaces in transistors, due to high layer quality.",
    "source_url": "https://en.wikipedia.org/wiki/Printed_electronics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:05:34.344502",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:05:34.344502",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:05:34.344502",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_electronics_1_1748286334376_7533",
    "text": "[ 16 ] If high resolution is needed, gravure is also suitable for inorganic [ 17 ] and organic [ 18 ] conductors. Organic field-effect transistors and integrated circuits can be prepared completely by means of mass-printing methods. [ 16 ] Inkjet printing [ edit ] Inkjets are flexible and versatile, and can be set up with relatively low effort. [ 19 ] However, inkjets offer lower throughput of around 100 m 2 /h and lower resolution (ca. 50 μm). [ 9 ] It is well suited for low- viscosity , soluble materials like organic semiconductors. With high-viscosity materials, like organic dielectrics, and  dispersed particles, like inorganic metal inks, difficulties due to nozzle clogging occur. Because ink is deposited via droplets, thickness and dispersion homogeneity is reduced. Using many nozzles simultaneously and pre-structuring the substrate allows improvements in productivity and resolution, respectively.",
    "source_url": "https://en.wikipedia.org/wiki/Printed_electronics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:05:34.376638",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:05:34.376638",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:05:34.376638",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_electronics_1_1748286334414_2839",
    "text": "However, in the latter case non-printing methods must be employed for the actual patterning step. [ 20 ] Inkjet printing is preferable for organic semiconductors in organic field-effect transistors (OFETs) and organic light-emitting diodes (OLEDs), but also OFETs completely prepared by this method have been demonstrated. [ 21 ] Frontplanes [ 22 ] and backplanes [ 23 ] of OLED-displays, integrated circuits, [ 24 ] organic photovoltaic cells (OPVCs) [ 25 ] and other devices can be prepared with inkjets. Screen printing [ edit ] Screen printing is appropriate for fabricating electrics and electronics due to its ability to produce patterned, thick layers from paste-like materials. This method can produce conducting lines from inorganic materials (e.g. for circuit boards and antennas), but also insulating and passivating layers, whereby layer thickness is more important than high resolution. Its 50 m 2 /h throughput and 100 μm resolution are similar to inkjets.",
    "source_url": "https://en.wikipedia.org/wiki/Printed_electronics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:05:34.414875",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:05:34.414875",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:05:34.414875",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_electronics_1_1748286334495_9022",
    "text": "The droplets are entrained in a gas stream and delivered to the print head. Here, an annular flow of clean gas is introduced around the aerosol stream to focus the droplets into a tightly collimated beam of material. The combined gas streams exit the print head through a converging nozzle that compresses the aerosol stream to a diameter as small as 10 μm. The jet of droplets exits the print head at high velocity (~50 meters/second) and impinges upon the substrate. Electrical interconnects, passive and active components [ 30 ] are formed by moving the print head, equipped with a mechanical stop/start shutter, relative to the substrate. The resulting patterns can have features ranging from 10 μm wide, with layer thicknesses from tens of nanometers to >10 μm. [ 31 ] A wide nozzle print head enables efficient patterning of millimeter size electronic features and surface coating applications. All printing occurs without the use of vacuum or pressure chambers.",
    "source_url": "https://en.wikipedia.org/wiki/Printed_electronics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:05:34.495287",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:05:34.495287",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:05:34.495287",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Printed_electronics_1_1748286334516_4188",
    "text": "All printing occurs without the use of vacuum or pressure chambers. The high exit velocity of the jet enables a relatively large separation between the print head and the substrate, typically 2–5 mm. The droplets remain tightly focused over this distance, resulting in the ability to print conformal patterns over three dimensional substrates. Despite the high velocity, the printing process is gentle; substrate damage does not occur and there is generally minimal splatter or overspray from the droplets. [ 32 ] Once patterning is complete, the printed ink typically requires post treatment to attain final electrical and mechanical properties. Post-treatment is driven more by the specific ink and substrate combination than by the printing process.",
    "source_url": "https://en.wikipedia.org/wiki/Printed_electronics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:05:34.516360",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:05:34.516360",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:05:34.516360",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Design_for_lean_manufacturing_1_1748286337437_8470",
    "text": "[ 6 ] Design for lean manufacturing was first coined by Womack, Jones, and Roos after studying the differences between conventional development at American automotive companies and lean methods at Japanese automobile producers. [ 7 ] While lean manufacturing focuses on optimization of the production stream and removal of wastes (commonly referred to as muda , mura , and muri ) once the value stream has been created, Lean Design ® (Munro & Associates) concerns itself with methods and techniques to create a lean solution from the start, resulting in more value and fewer wastes across the value stream. [ 8 ] Lean design ® seeks to optimize the development process through rapid learning cycles to build and test multiple concepts early.",
    "source_url": "https://en.wikipedia.org/wiki/Design_for_lean_manufacturing",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:05:37.437747",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:05:37.448748",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:05:37.448748",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Hilltop_algorithm_1_1748286343069_5046",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article includes a list of general references , but it lacks sufficient corresponding inline citations . Please help to improve this article by introducing more precise citations. ( September 2016 ) ( Learn how and when to remove this message ) This article relies excessively on references to",
    "source_url": "https://en.wikipedia.org/wiki/Hilltop_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:05:43.069527",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:05:43.069527",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:05:43.069527",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Algorithms_and_data_structures_stubs&oldid=547280383_1_1748286344882_1832",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Addbot ( talk | contribs ) at 15:38, 27 March 2013 ( Bot: Migrating 2 interwiki links, now provided by Wikidata on d:q8235199 ) . The present address (URL) is a permanent link to this version. Revision as of 15:38, 27 March 2013 by Addbot ( talk | contribs ) ( Bot: Migrating 2 interwiki links, now provided by Wikidata on d:q8235199 ) ( diff ) ← Previous revision | Latest revision (d",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Algorithms_and_data_structures_stubs&oldid=547280383",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:05:44.882184",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:05:44.882184",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:05:44.882184",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Post%E2%80%93Turing_machine_1_1748286362540_5023",
    "text": "Jump to content From Wikipedia, the free encyclopedia Abstract calculator This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article contains instructions, advice, or how-to content . Please help rewrite the content so that it is more encyclopedic or move it to Wikiversity , Wikibooks , or Wikivoyage . ( August 2020 ) This article is written like a research paper or a scientific journal . Please",
    "source_url": "https://en.wikipedia.org/wiki/Post%E2%80%93Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:06:02.540539",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:06:02.540539",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:06:02.540539",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Raita_algorithm_1_1748286363438_7780",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) The topic of this article may not meet Wikipedia's general notability guideline . Please help to demonstrate the notability of the topic by citing reliable secondary sources that are independent of the topic and provide significant coverage of it beyond a mere trivial mention. If notability cannot",
    "source_url": "https://en.wikipedia.org/wiki/Raita_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:06:03.438664",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:06:03.439663",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:06:03.439663",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=List_of_terms_relating_to_algorithms_and_data_structures&oldid=1289141319_1_1748286368201_8463",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by YiFeiBot ( talk | contribs ) at 18:46, 6 May 2025 (Bot: Migrating 1 langlinks, now provided by Wikidata on d:q16002499 ) . The present address (URL) is a permanent link to this version. Revision as of 18:46, 6 May 2025 by YiFeiBot ( talk | contribs ) (Bot: Migrating 1 langlinks, now provided by Wikidata on d:q16002499 ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revisi",
    "source_url": "https://en.wikipedia.org/w/index.php?title=List_of_terms_relating_to_algorithms_and_data_structures&oldid=1289141319",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:06:08.201576",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:06:08.201934",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:06:08.201934",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_introductiontosy00bass.pdf_1_1748286714436_3105",
    "text": ">\nstream\n\u0000\u0000\u0000\fjP  \r\n�\n\u0000\u0000\u0000\u0018ftypjpx \u0000\u0000\u0000\u0000jpx jp2 \u0000\u0000\u0000\u0012rreq\u0001��\u0000\u0001\u0000-�\u0000\u0000\u0000\u0000\u0000-jp2h\u0000\u0000\u0000\u0016ihdr\u0000\u0000\u0003j\u0000\u0000\u0002G\u0000\u0003\u0007\u0007\u0000\u0000\u0000\u0000\u0000\u000fcolr\u0001\u0000\u0001\u0000\u0000\u0000\u0010\u0000\u0000\u0000\u0000jp2c�O�Q\u0000/\u0000\u0000\u0000\u0000\u0002G\u0000\u0000\u0003j\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002G\u0000\u0000\u0003j\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0003\u0007\u0001\u0001\u0007\u0001\u0001\u0007\u0001\u0001�\\\u0000#Bp�@w@w@]8�8�8s0�0�0�)\u0019)\u0019)d � � ��]\u0000$\u0001Bp\\@ @ @\u00078,8,8\u001b0U0U0b(�(�)\u0003 � � `�]\u0000$\u0002Bq�ARARA59_9_9M1�1�1�*\u0004*\u0004*V!�!�!��R\u0000\f\u0000\u0001\u0000\u0001\u0001\u0005\u0004\u0004\u0000\u0000�d\u0000\u000f\u0000\u0001LWF_JP2_204��\u0000\n\u0000\u0000\u0000\u0000\n�\u0000\u0001����\u0006�\u0000\u0014\u0000\\��v�{gi�}sI2�%\u001f0�H����6| Q�F��\u0010��\u0013Y�<�\u0007\u0003�wN�e9�\u001el\u001f�Z铈`�\u001f�. �����b��gh�\"~�%\u001f0�H����6| Q�F��\u0010��\u0013Y���cpiSM�e9�\u001el\u001f�Z铈`�\u001f�.������k�\rB�4�(�Q�\n���K�sg�\u0005\u001b�l�A\bZ�5�\u00079&h� �%`\u0012���\u001f�Z铈`�\u001f�.������k�\rB�4�(�Q�\n���K�sg�\u0005\u001b�l�A\bZ�5��\n�Ȃ\\��J�\u001e��ak�N!�l~8��+��\u0007ٯt5\n\\�L�l=�^PLj�\u0017>�\u0005�^�8+��K�Y-%.l52���\u001f�\b&���r�0Mkz�.G�f�\u000fSK\u000f��\u0006?#�z�pcW�$�u\u00062��\u0004,���<�k\u0017~\u000fH��Kqn�G�ʭ.���oe\bN��(�z.�p��3���\r�\"���]Τ�Ϣ9���qsf�d�\u0016��<�V���::�kE?{�Sm$�v�\u001e��i��\u001e\"���'(�r \u0005\u0002�l$�\u0006��L����\r�'�^�QYύYJ�\u0018\u001c>�\u0010�>�y\u000b\u0007_6جuA�H����o�Kt�3�\u0016Sľ��!��㱥\u0010��\f\u0006N\u001b�y\u0004˿\u0012+͞C��k��0z�|�C��\r�F\u001f.",
    "source_url": "https://archive.org/download/introductiontosy00bass/introductiontosy00bass.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:11:54.436780",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:11:54.436780",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:11:54.436780",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_introductiontosy00bass.pdf_1_1748286714459_6891",
    "text": "B'x�\u0001�S\u000ew��c��cǃ$23H\u0007\t�R�p��?����\nendstream\nendobj\n\n6 0 obj\n<<\n  /Type /Page\n  /Contents 7 0 R\n  /Parent 975 0 R",
    "source_url": "https://archive.org/download/introductiontosy00bass/introductiontosy00bass.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:11:54.459318",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:11:54.459318",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:11:54.459318",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_introductiontosy00bass.pdf_1_1748286714638_5731",
    "text": "��Ոo[7t��\u001f���ft\u0014\u0018-��\u0015�!�:���\u000fL�\u0014؈�b�/��o�I\"��O\u0007\u0013�x�d4r�L��\b}\u0001חv��5��\"\bg\u000b\u0004d\u0004ny�9���D6�}a ;kZ$���7��.\u0016z��%qh\u000f�f��\\�\u0019��s�$K�6�I.t\n[����/�D��Ш�-�I�]�aL��5�\u0012�\u000f����;g��1\u0011cD*^ʭ��\"��k���m\u0003i\u00039��@�8���%9���<POM���F@��\u0011\u0002B�d�r��\u0014�\u0000;wt\u001d��ƪsV�ҧ\b*��\u001e�\u0004y��{^=i�Z�v��3=.}�UC��5�o\u001d\u0003)}��4o��jکq&\f�2\u001cU�6�f݆��Ra\u00177@r\u001b9�o�k�~<3\u001e3�\u000b�zbǏ&����\u0012�̘F�\u000e���,�4\u0018�n����h�\u0015�1N\u0016t��b\u001dG���\u0005t�\u0012\u0013'e�)\u001c��J�Mi\u0015���4�VگsB �s\u001eM����:�_j佻\u001d��|������N$�7��B\u0012�/9\tm)�\u0006��f`�\u0013�t\t��?\u0003�\u0004zѢ9\u0019R�S��3��\u001e]\u0016��d�%P�&G��1�a�����J|�\u0019\n:,�j�h��/�S�[h��\u001e�DQYwx��\n\u0000b�\u0003_������HdJ\u0018U�����`���M0�9���j�څ\u00123\u0001]��\u0013��TPq\u000e�|���[qF��j� ]��W�����Ţ�O���\u001a\u0012S�,�5��\u0004����\u000f��/\u0012�A}�(\\��\u0003���焿5Cu�x\u000b_\u0003fGпt�k�����b-��O{�~*��W\t?\u0012��f\u0013'�x��=3��FFNz��s;@���\u001c���\u00065z�\f;�\u0000��{.�X9N�����\u0011�Ie�u\u001f�\t�������U�\u0005�������րc�_x�̩T�@\u0004��+��9�\u000128�@\u0019�=�b%�\u0011z��\u00071��F�>\u0005G\f�ʉW���o��Nj\u0016|E,���a�r�E\u001d��\u0014��\u000b4�[}��\u001a���!m˪���`\u0019n�.z�Dz�\u001d9��#__\u0002ʌ�r8���d\u0007��4�I��%eXx�p��݇�Y9\u0000N�M��p�Qx�\u0016ݾ�L�Z�ɯ\u0019��\u0014sɻ\u0013�/A��$��MWcEfU�\u00031R9�R��==��=�\r+�r��u���",
    "source_url": "https://archive.org/download/introductiontosy00bass/introductiontosy00bass.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:11:54.638161",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:11:54.638161",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:11:54.638161",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_introductiontosy00bass.pdf_1_1748286714707_3837",
    "text": "�\fb�v0�L���\u0003��'�47_%�\u001d������\u0004:5��\u0019r\u0018\u0010̾)Du\u0015��m�\u001b�[b#�\u001a\u0001m� Ԯ�Q��=�\u0004�I�\u0001�9��\u0010�(X�1-�w�\u0003\u0003\u0004[z�-9�9\u0001�����|��\u001b蹄cc;\u0014�xֿ�¬�\u0016\u0017�.�uU>�b�;���:[�\"�ǘ�aǛ\u001e\u0010d���d_2S�YQS�\b�Q��j\u0002A[���wd\u001e�~\u0016�\u000b\u0016L\u001f�\u0005��O!2]��\\M�����gn+Y\u001f0b�2��;A���+������s��\",&\u0006w��]�i�����r/b��<\u0005�\"�\r`�\r�s\u000e.���f��q@��i\"�lQ�xST��\u0018\u0003\u001c\u0001�-��D�\u001f�P���|��p\u0011(�c�G��\t_��\u001e\u001bA��\u001d'�\u0010p1�N�:G�#O�@�C]�\u0007���?҅����.",
    "source_url": "https://archive.org/download/introductiontosy00bass/introductiontosy00bass.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:11:54.707773",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:11:54.708766",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:11:54.708766",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_introductiontosy00bass.pdf_1_1748286714832_8333",
    "text": "d�2'���?��\u0000\u0000\u0000\u0004&\u0000\u0001\u0000\u0000\n�\u0000\u0000\u0006�\u0000\u0000\n�\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0003���\u0002����\u0001ԙ��-�ޟ�F:�\u000b�-ޔ�fQu-܋7>�;�\u0013�\u0000^�\r��ò���.\u0018�\u0011���sh�Ƞ\u0007\u0001�p;�B�Wȯ�>v�zA_x�ڪ`�O�\f�pU�\u0018�\u001b�]�en\u0004���Nv��zg9U\u000f\u0014�P�\fY\u001b2�T\u001d�ڨ�LS�̶\u0007|0R/��R\f��n���\u0013��珘$e��o�O\u001c\u0006[*�&4Hڝ��&�k����h鋕�׬��(Q�W5\u0015\u0011�+\u0010\u0006��A�\u0012mrG�*�k\u001cf�yA�L�\u0015�\u0005�q��Pճi\u000f\u0016�u:\f�e�3;l�E���~�\b�0��V�܁��)��d�<\u001a��]�a�-\u001e]>�ݔ�n�Z�f�y\u0018 5C$\u0017|T�`V\u001b�{�\"�9��>\u000e����Tc6\u001a�\\�6L������[��O�$o��\u001baZ��Q��]\u000f\u0014�X��c�&4bu��Yn�#rG�#|�R��}��J�a\u0017Y��\u000b��\u0017�=�,O\u0003$m5����%y������D|s,l\u0003`�>���a\u001c7���\b�c�7Q\u0019\u0016�\u001c6��̇\u0011w�'�\u0012g�\"��iO�0���\u0016�����\u0003��\u0010�m���`�aG t���z��U�e�5��Ēg���=^ƈ���I#�ʛ�\u0007\u001a:�O\u001am���/\u000e @�@�~�-�%��\u0016\u001d��o��]����W�'�T���վ�l�p�b\"�fv�2v�7��\rk�q������\u0003��}�`�\u0014:������\u0007�\u000f\tm``\u000e���F�",
    "source_url": "https://archive.org/download/introductiontosy00bass/introductiontosy00bass.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:11:54.833525",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:11:54.833525",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:11:54.833525",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_introductiontosy00bass.pdf_1_1748286714933_1100",
    "text": "�9(�\u0002[���\u001d��\u001d�-\\[����\u0005��\u001a\u0019�W\t�8�\"c�p�m�L\n�hd��H&2���L���1=��VG+������\u001e�\u001d��UJT1U��>K���\u0007��G��)\u00101C'���\nUt�{��,����$7��\u001f\u0010v>tgn�y�j�$�\u001a��\u001dx'���\u000bC�K$>\t-\r2(jV̲k�dBdH����� /�f}�Fۢ]\u0019R�\u0010�'�y��\b��p�ǽ��\u0000��'Ɋ����\u0013.�Nk\u000b���>\u0001��jȆ�7$�=0��1+gʮ��k�`J\u0019Br���^�q�v݀����T��!.�^\u0003&���0��_U�>gm��T\u001c��;I˽�B�'FU�\u000f̀�\u000f#l��\u001akh��b��8�\u0018)\u000f�Q0����\u001b\u00158����\u001f}�\b�|Z�K+\u0000��Ǘ��\u0010\u0002\u0006���\u001e�橆\\�f6\u0002��\u0000�$��s`�\\�\"��'\u001b-\u0011(���OCrұ6s�`:w���\u001d��\u0005_���~��O�/u\u000fu�w�P���\u001e���M����\u0014to\u000e�+K�ޱ[\u001eկ����w���E��:\u000f+[����M�X\u0000����M��]��\u0002\u0006es�\"o�S��o�",
    "source_url": "https://archive.org/download/introductiontosy00bass/introductiontosy00bass.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:11:54.933295",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:11:54.934287",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:11:54.934287",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_introductiontosy00bass.pdf_1_1748286715090_3144",
    "text": "��w�Iq�\rC��|\u0012���P��Q|�:�ksI����:]��* ��r\u0019���.܊Bl\u0002\r�o7��^�\u001b\u0001!U�\u0001qo�`�`>�\n�A�\u0012)\"\u0017e\u0013�\u0005X\u001879��^S\bM��\u0013p�smY��\u0003�\u001eV�n��L�&�'�ON��3�@xg]պ>�]g�݌`�\u001dL���:!lYP�\u001f`�\u0001δ\u0011\u0005)ˏ]�\u0018�\u001ee/�$m�\u0016m\b/1z��-�<��옸�\u0017n�ޔ0\u001f�hF�{���|f��X\u001b}M��U\u0007g���-�\b�\u0012�\u001d�ŭ�6U�\b�.Ad䜸\u0005pJm?�\u001ḟ*��\n�󎻻'��������Y�A\u001d�\u0000M�@\u0000M,�q�\"Z��\u0019��7+\u000f����\u0010#\u0016Ƣ�\u001d��U�\u001c��\u001aVa���\u0005��nC\\��\"�Д����zh\u0004�-7K\u0010�\u0006��M1\u0015�X�EI\u0006g��r�\u001f\r\u0018�\u001b�\u0012�\u0012&\\��g5\\\u0003�À/\u000f����\b\nm#�u����𾷚\u0007\u0005�Y\u0018[��|�P��֠\u000f�5�ʎ>\nh�\r�1�sjK���eT�×/씽'l~��펀��mW�#gi�W����W�����?�\u000e�ښu\"\u000e\n�\u000bT�Q����ټ�, �\"Ld��3.uLh딾��\u001f���\f��]p\u0011..]X+�}f9~�mH�Y3���̪髾�D5��/\\�N:m�\u0019=�,L�}����|�(!�-12�0e��s�u��_���\u0015�[�p��sU�>x5�\u001c��\u0016���?��\u0000\u0000\u0000\u0003\u0006 \u0002\u0001\u0000\u0000\u000e�\u0000\u0000\u0006�\u0000\u0000\n�\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0001\u001e����\u0000\u0000\u0004\r�\u0007qJ�ߎɬr�����6\u0007ց�4@�y/�iΜפ�\u001a���\r�Q`L�?��Ҧ\u0017P\u0006�\u001f\u001e�6\u000e\u001a\u001d\r1Kؔ\u001f�ؘ\u001c\"h�<���\u0007�Q\u0006��+d\u0006\u0006��w�d�\u001f���\u0010�\u0004#9y�f�����\u001e��]:�rR͝+Tw��\t�NJOǾ\u001884~;��*\u0017-f~\t#B��˧\"��nHY�����7���\u0017�\u0006��~\u0017�V)�j��\u0019˵�渢2a�X����fX�Y\u0006˥\b/:g�1�!\u001e]�\bpD�¬C�c��=\u0013S�k���Z*\\���y�lU\"��\rlӉ\u0001",
    "source_url": "https://archive.org/download/introductiontosy00bass/introductiontosy00bass.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:11:55.090336",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:11:55.091385",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:11:55.091385",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_introductiontosy00bass.pdf_1_1748286715231_7016",
    "text": "mlw@m�S���J!*X�z�\n��\u0004��\u0014\u000e\u0014&��\u001a��-���'����8P�l\u0005�\u0000�\u000b���\u0000´.�M�����\u0004�Є2\u0019u�\u0003e\u0007�\u0007��EM�t�\tS��l5ڽAx\"�F\u0011�\b�y߈\u001c�yɣ�5ρ2�lf�����H�\r �����\u0004\u000eD>O�Y\u0019Zc���72�<�jF��l\u0017X�^�\u001d�\u0006��?R�y���\u0000��K\t\"t�hչO\u001e,��R\u0016�.D��'�\u0012s��)1k?X\u0006�Դ,�\u0013�J\u0014G\u000b�\u000e\u0016�\"'���\\���_�\u0019��rk�n\b�\u0012UP�Y#�\u000fQ`\u001f�6\u0001�U\u0000�\u0003�)v�]v<H��y�\u001cP\u0019�\u0005\u000b\u0015J`�N��r+�\u001b�3�8e��T{#����o���z.}�ߘ\u0003�\u000f{�n����X��0\u0007\u0010����\u001ei����I����w@�b�\u0012CR]�tT\f�Ff\u0000�2������ \b�\u0006]\u001c\u0005\u001e2�P+�_ݏ�\u0007R�\u000e�9 |Q\u0014ܜ���Q����(��6�\u0004�Ξ�ɲ�C��&��\u000f<\u0018�K��t��,�����\u001d�j�#$w�\u001b�`V��fHq�Ow��\u0013\u0007�\u001d*LK��\u000e��)o�v�:dl2!��n\u0011CG`�\b��\f\u0007K��\u001b\u0001��3��]���\u0001�l��&\u000f\u0005��\u0007\u0017��\u0015y\u0014�'aHl� �d�#,�U�\t\u0015��Ti��@zW�\u0011\u000b��h\b~�\u001f��IP��C����q9��x��3�1X�\u0005�pL�k\u0001坛�\u0017�9C�}�<�-W�VI�t���.�\u001eɜr\u0019ӡ�oV��â��\u0002W\u001e�F�S\u0000a�a�1�L\u0007���\r�ێ\u0002�ο����)�|��աJl3�I&U�-*D�«��R�2�2�i\bZ2���\u0011�I�S���\u0005\u0005�:\u0005��u4PL\u0012,\u0018\u000b� J]od�{���z����",
    "source_url": "https://archive.org/download/introductiontosy00bass/introductiontosy00bass.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:11:55.231346",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:11:55.232339",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:11:55.232339",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_introductiontosy00bass.pdf_1_1748286715361_2641",
    "text": "2�U]�ˡvRi��$�2\\B\u0018�nR?\u0011*�\r`��\n1�u\u0018��.��O[8S���\u0017\u0015\u00163��F��ܵ���s\\\u0019ru+[g�\rq��':9�8�A\u000bul����VN�wm�\u001c����\u001fC�G�A�e\u0007fT;�-��\u0004%����'��tZa\u000f�d#�$_�.����h)\u0013f�\u0019U��(\u001e�c\u0013�K&\r�o+�Ͷ��M�\u0013�R爠-\u001b�0�r��\u0015�L�Ϩ�S�h����v���$:K�\u0004p]�ڣ�&FT\u0013%1M?��t\u0013�\u0004c��'���\u0005�)�\u001c\u001em�� �Be<�~#�zf\u0010�\u0001F��\u0016\u0002f�q �\"h�t-�)-\t�\u0002;�+N~ �|�=@Yc��\u001c^aj��\u0000��\u0016T�]^�\u0012\u001eË���]µ\u0007Z\u0013�Z��\f�\u000ei��y'��X\u0001\u0018��\\��\"�M*\u0000fx6Q�S\u0006��C'j� ey�v\u00069BF}��g{?5\u000e\u0019�y���1\u0014�/@�0��0���ٜ�罸�9�%�ݑ�\u0017\u0016\fhe��1�\tC[�vS�Z��78�)�U(\u000bf�\u0007����<{.ƈ\u0004m�j\u0010\u00077�[k�`ѱ��J���}�(T�Hy���\by�a\u001b�B{��0�\u0007��$`��B2��\u0015+=�i�\u0017�\u0019%b\u0014���מ\u0003\u001c\u0018��\u001b�\u0001��b�P�D��)�7�C���W�\u0017\u0017�(!m:���$Al�[�g\"��G[[�$�q���\u0005u^���v�c0|�\t�{����^I\u001b�\u0013nz�����.(\u0007����7�\u0000�\u00005�#z�\u001f�<���K�]ٱCш:ߚJ ���YW\rT� n��pt��w�2��w���\u0007�`(׀��\u0016��b���\u0001�>�WD�S޼/",
    "source_url": "https://archive.org/download/introductiontosy00bass/introductiontosy00bass.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:11:55.361118",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:11:55.361118",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:11:55.361118",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_introductiontosy00bass.pdf_1_1748286715554_4633",
    "text": "�D�U49w�\u001c�A���|���2\\\t'\u0011+�\u0010{`\u0001$��>�{\u0007�/�M\u0011�\bZH\u001c�*\u0005�������`�3�Ԙ��\u001c�rd�B�g65��S\u000f�Jƪ��\"�aWx1B�¾�(ӚM�6gY�^66z�G�C�\u0005\u0013q��2���-�~\u000f\t\u0001�[`X�ܣFd�|,\u0003'\u001d��\u0012\u0017�&\u000eE�\u001fy��z��K#�[q&þg���f�T�\u000eK�0\r�,��e}>Ü�\r҇E\\�ID2�#\t��\u000b�`~c�a�r\u000bSP�a\u0013�\u001e���EM��|��Fg�,��\u000ejI��d�H馫�gʴs��5�+\u001f+o\"_\u000b�������s�vj�\u0007\u0012\u000e��Z�Uo��A�KK̂o�|Q�{5)�\"\rF\u000f8����(h��@��[�\u000f�&�\u00187W�\u000e'�\u0013G\u0015@j���\b�\f9���  �A��M�\u0011���(o��^o|�\u0016Uǽ��H�Ӓ\u0004�F\u0005�ޓa\u0000V�?���MMAb����EΑ\u0013\\ɟB\u0005�S�[�K�*��<�\f*(\b)�\u000b�Lg1Y\t|1�0o��\u0013*ΨVy��֡e:�A(\u001e\u000e=~�͹�\u001dr�*^-� \r����[�p�\u0014_��\u001c�zӏ�\u001a�W�\u001c�b[p�-F�?-\u0012�;�T��FlcTQ��\u001f���@�\"\u001e@\\�x�՚~�[\"_������+���6x3lH\u0017b�\u0010��?{�I��\u000f\rڊ{,\u001e�@�\u0004$z�2`m|�ֶ��ſ��&�\f\u001f��\u001a�K>Z��\u000b)m�k郣�E�R����0�\u000e� 0�����|���,s�BM\u000bn��3\f����\u0014�!��R:\u0000��E�\u0007T:�\u000f\u0007\u0007,\u001d;9lp�p\\�F���\u0002\u0004�\u0002�ͧBSm�MJ��c���#�o�|�\u000bm,�-���\r�u���;�\u0011���)K�,|^�rOH6\nN�@\u000e�I�͖i��=\u001e3���6��@�њ�\u0002|)�R^��j\u0003\u0017�hl��^\\#ǀR�_s�2�)\n�V�P޵�u2�\u0018m\u0019��\u0013쬉�G+�����]�f\u0013t\u001e|oՃA\u0013!�zP�卥�D�*j� �z\u0001�\u0000VK��\u0002�H\u0019�9\u0000@w\u0001X���Sy�����6��g�{��z���m��\u001dÌ�\u0003\u001e8�H���:����\u001e�H�t���l�\n�G�~�hg\u0005p�S�0�ݞ�܅g�moU�d7��\b�-N���9�]ʾ16���AG�S�GQ\"\t#�E�{f_\u0012�\u0013W7��Vo�]kt����\u0019��jB뎝���\u0015jf�:#�V\u0010#jkt�",
    "source_url": "https://archive.org/download/introductiontosy00bass/introductiontosy00bass.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:11:55.554858",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:11:55.555851",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:11:55.555851",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sentential%20Logic.pdf_1_1748286795865_4094",
    "text": "ގ�Ґ�\u0018�i\u0019�I>ۥ����o���\u00045�M�2��-I23[�wz1�\\Ǿ�YR^��-�dq�d��^��\u0018�����\u0006}Pݓk��\u0018{\u0012ҡ�\b��C;�p\u0016qb/��$;+y����:�mVFo$�N�Mڸ\u0011������ i�\u001e��k�b3��Yv�X�4qRV��I`\u001f��ΫWW��k�ћ�G\u0012��\u0015��F���4���\u0006�u��]�\u0019�\u000b��L2g\u0014/�� �]G�A�\u000f����Ǯ��\u0018j��w�\u0007���/�ݦ��#I�\t\u001e��wn��C�B\u0017I͙�T/\u0005���\u0006\u001a)f=��@��'j��!mT\u0016�9�g�o�\u0015 �@��^������\u0016\u0010�\u00155T\fP\u001afM\"`�%|j\u0012A\u0015��D�hq^�쉺\u0018�u�ߦ8�b\u00183 \u0007�)���V\t\u001b�={��nB�\u001b�?\n����a�L��|;��x�<��צP3���,)\u001cZG:��:Q�;�/\u0017�[��ޮ\u0012�U#�\u001f\f�\u0016ln�Q��\u0003�����i�\u0016��\u000b:�S\u0000��P���\u0014�J�I\u0018`x\u0019��\u0016Iĝ� N��y�W�q2����\u001f�\u0010�n����v������m�\u0018�ݫ+�u_����C�\u001d���\tՅw݇S����F#0yX7\b\u001c�ό-Χ�\u001e���E�*\u0012<]L��\u0013 QE>j��Ց��e�Wmt\u0010�\u001407�\u000f\u0017\b��\u0005�>�ذEx�3�x�?Z��y\u0016�G���`%F�a�����R2�\u0014��z&>8�=\u000b���%�P2�r�\u0017n�mx�l0\u000fk�a\t�;\u001e\u0010��)�3Κ^���Rp��R\f�]��\u001f�HyR�2m6m�����f��/��\u000f\u001al\f�\nendstream\nendobj\n186 0 obj\n<<\n/Type /Page\n/Contents 187 0 R\n/Resources 185 0 R\n/MediaBox [0 0 612 792]\n/Parent 184 0 R\n>>\nendobj\n188 0 obj\n<<\n/D [186 0 R /XYZ 120.813 697.09 null]\n>>\nendobj\n5 0 obj\n<<\n/D [186 0 R /XYZ 121.813 662.741 null]\n>>\nendobj\n185 0 obj\n<<\n /ColorSpace 3 0 R /Pattern 2 0 R /ExtGState 1 0 R \n/Font",
    "source_url": "https://www.csusb.edu/sites/default/files/Sentential%20Logic.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:15.865649",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:15.865649",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:15.865649",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sentential%20Logic.pdf_1_1748286795988_1378",
    "text": "R /F30 314 0 R >>\n/ProcSet [ /PDF /Text ]\n>>\nendobj\n376 0 obj\n<<\n/Length 1370      \n/Filter /FlateDecode\n>>\nstream\nx��Z�n�H\u0010}�W�R\u001e��=}�oO��\u001dG��$���&;#b���\r\u0016��j�~��/`\u001ccBp�Rd�\tt�9Uu��\u000bl<\u001aظ:�}|�iH(6\bF\u001akb�\u001f\fB\tR�\u0019B\t$07�S�y��ݩգ\u001c�\u0003�\u000ec�{�\u0017�K��\u001f��Bow�8C\u0018.��ѿ=�Kn;���\u0018q\u0003#\u0005m����(���,�O!I%K��1N��\u0002\u001a6R�e���� �8\u001b�\u0011C\"-q6���\u0006C�Hz+���\u0016�q\u0002}�o\u001b[��a\u001c=e0\u001f�0k\\�߇�E9\u0000q2���;����#��\u0019�\"\u0005�����g���\u00187�\"6�\"u��\u0001�\f.\u0010���\u0011���\u0003�<9���Q�L\u0000\u001d\t���а\u0011�2�e��-��\u000f=�\u0019��:\u000f\u001e�� ���rYb0c�񗳔�2O�І\u0004��T�\u001eA8G�s3��H\u0006�d�0���\u0016ᦛM:���]��ˈz�Y��C�V\u001d�6���\u0016�r%̍�f o\u0017.`\u0007;�0rEO��\u0005�}\u0010\u0006%lb���\"��\\��Uc��\u00173��W\b��\u0011��%1&����x~Ɍke�|��y�.1\u0010�wo��0���eY\u001e��$\u0011�C\u001e��|��\u0016�m�1��5\f&�4\u000e�]�'�G��!�,\u001c��\"qd6\u0000�m-ܥ�)\u001f�\u0006��&�Z�\t��Ǭӑ\u001b'�Õ�\f`\u0011˄\u001f>�,p��pok�8�l�_C��i\u0010���[�,��`%���t\u0017iY�%?��Ws\u0000~G(k\u0014bCK��E\u0012f\u0002r�\t,�K�~�/��d�\u0007��gΎ�هC����\"7w\u0019m-�ۚ��~�\u0002\u001c6\u0006/\u0004��R\u0005$Rju�77I_��Q�\u0006\r���m\t��\u0014l�pQ&)G�*)�o��\u0010�䚛�*�a�Da�Ub�8b���lD`C�\u001a��,�j-ºu��o��wސw�\u0011�v14k�~�\u0015��~\u0014\u0006�xR�;�'�]��{��?��\u0000�`�ew�HÕ����N<\u0010\u0013v\u001dwW����\u001c\u0016dݔv�\u0014g��~�\u0015�/y;��Դ3�\"�w�U�u)�7��>�Q�}\u0003���-\u001b�@���\u0014\n�-4�nJ�@���ע��3�_\u0012\u001b)������?w��?���\u0016I�ّ����\n�\u0013��m(��K�eW���|��\u0016\u0017��M�\u001f~�d�-���]m��?���6���jB;��t���V��\u001d���ڌ�Љ��0��s�e?gU\u0014\\��\u001e.",
    "source_url": "https://www.csusb.edu/sites/default/files/Sentential%20Logic.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:15.988349",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:15.989341",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:15.989341",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sentential%20Logic.pdf_1_1748286796059_9259",
    "text": "�\u0003m�\"%�H\u0019b\u0001?4�9\u0006�/�����d���,�\u0013\u001c5�\u0012Z8\n-�\u0000�ڟ:��d\t\u001dZ(�\u000fNN�.\u001dw����q�i5j�+\u001c��0�@*g,���ξrSY�Ϧ�啭klz�a�{\"�q�+:\u0018n\u001a��\u00061s0��5+\u0004��\u0007S״��s]k���崱���e(�\u00010�J賖��f�C�E(Ѡd\b��մ�Ʈ�m���*�b�\u0013�=�s뾷����\r�u��\u0002�yU2���c�:��\u0013\u0007q\u001d\u001aQV#E�Dȥ\r\u000e���FH&\u0007\u0012�\u0019o^�kj�N��6\u001c_�{o��/_�Eg�H&к�C�F�b���M��L�86+sM�Ǭ��'��\t\u0003\u001e�p�XX0��6������\u0004Υn�\u0005-����&䕄�7�x\u0004��&\t~\u0019�G\"�\u001c��\u0012z\\�\b\u0014��q(��@t�<\u000eEpo���!岶���\r�\u001f�DK�\fx� \u00054��@Ӈ.0\f\ttlG`\u0019���\u0002\u000b�M@k+�5����f�\u001d��7P���N`:f��\u0001�1#��U��\u0013 �^@F7��sQ\f�\u0004��u�\u001a\rUI\u0002��\u00129�9���7�z\u000b(��TMx�h�\"��5��e��\u0017) ��^`y�E7I\u0002�S<�N��\u0017\u0017���\nendstream\nendobj\n513 0",
    "source_url": "https://www.csusb.edu/sites/default/files/Sentential%20Logic.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:16.059904",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:16.060068",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:16.060068",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sentential%20Logic.pdf_1_1748286796115_7023",
    "text": "R /ExtGState 1 0 R \n/Font << /F120 210 0 R /F69 182 0 R >>\n/ProcSet [ /PDF /Text ]\n>>\nendobj\n579 0 obj\n<<\n/Length 1907      \n/Filter /FlateDecode\n>>\nstream\nx��XKs�6\u0010��W�7�c1\u0000A�ћ�j�f�L�v���@K��\tEx������b\u0017\u0014I˱��\u0017a\u0001B�>��\u0016��n<��������72\u0014�\u0014A&2魶�\fe�J��i\u001c�B{���������돋e��/��R����狗��h���T�?w��b�\u0007\r�_�\"���o��.__]-�\\�}�&���)\u001d\u0007\t�'h')q�3�\u001a��[*\u001d\u0006\u0011�u�� \r\u0015�~-�0��a��\fD\b\u001f�DO�(Б\u0017k\u0019$i������Ծi@O0���;�̖�nW��5Ue\u0016�������ڢ�z]�g؏��B�\u0012~$����̿�\u0015�\foQvܶ�A��\u000eN��B\n? �Z\u001e.",
    "source_url": "https://www.csusb.edu/sites/default/files/Sentential%20Logic.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:16.115590",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:16.115739",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:16.115739",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sentential%20Logic.pdf_1_1748286796191_4086",
    "text": "/Page\n/Contents 641 0 R\n/Resources 639 0 R\n/MediaBox [0 0 612 792]\n/Parent 618 0 R\n/Annots [ 638 0 R ]\n>>\nendobj\n638 0 obj\n<<\n/Type /Annot\n/Subtype /Link\n/Border[0 0 0]/H/I/C[1 0 0]\n/Rect [146.891 139.052 162.043 150.802]\n/A << /S /GoTo /D (LV) >>\n>>\nendobj\n642 0 obj\n<<\n/D [640 0 R /XYZ 120.813 697.09 null]\n>>\nendobj\n643 0 obj\n<<\n/D [640 0 R /XYZ 121.813 615.866 null]\n>>\nendobj\n644 0 obj\n<<\n/D [640 0 R /XYZ 121.813 547.26 null]\n>>\nendobj\n319 0 obj\n<<\n/D [640 0 R /XYZ 126.908 334.291 null]\n>>\nendobj\n645 0 obj\n<<\n/D [640 0 R /XYZ 126.908 320.064 null]\n>>\nendobj\n646 0 obj\n<<\n/D [640 0 R /XYZ 121.813 197.018 null]\n>>\nendobj\n647 0 obj\n<<\n/D [640 0 R /XYZ 124.54 182.791 null]\n>>\nendobj\n639 0 obj\n<<\n /ColorSpace 3 0 R /Pattern 2 0 R /ExtGState 1 0 R \n/Font << /F120 210 0 R /F69 182 0 R /F93 189 0 R /F73 183 0 R >>\n/ProcSet [ /PDF /Text ]\n>>\nendobj\n652 0 obj\n<<\n/Length 2440      \n/Filter",
    "source_url": "https://www.csusb.edu/sites/default/files/Sentential%20Logic.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:16.191350",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:16.191601",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:16.191601",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sentential%20Logic.pdf_1_1748286796212_1664",
    "text": "Hu�\u0016MO�w<�=\u0018�ߝ#�XC�\u001eʥ\u0013\"��\u0015EgQ���˔n�T��\u001b��)\u0002\u0014\n�FCt�C���+�4\\��y�~CtE{\f\u0002�%����hy3NQ��)&�c�zH3��\u0004C�?3�)��\u001a�¦��9�\u001a�����w�\u0012���X���-��\"ژ\u0003�p�e�(��H\n���f��XMF��\u001f��\u001be\nendstream\nendobj\n705 0",
    "source_url": "https://www.csusb.edu/sites/default/files/Sentential%20Logic.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:16.212607",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:16.212607",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:16.212607",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sentential%20Logic.pdf_1_1748286796305_1257",
    "text": "�\"R�.Rϸ8<\u0019F\u001d\u0006?\u0018B�\u0017�{\u001f��c�D��mx1\u001b�݃���}WI\u0003l��?�\u0012�^]t\b\u0017�Y�i܅�W4!�o�D�sE҈�S��v�r���\u0005��]�ݔ���\u000e��'��1]�W���smO񅧋��\u000f��il]���a$�0�;����.׻�#��wyGP��K~X��ꓒ�y7�<\u0006X\u001eC\u0019\"�t��0\u0012\u000eb�-!'p�\u0003I\u001f�ߞF~w���$R ˎw$�\u0001\u001b�\r~T�XI-\u0018�n��Dz�{�J\u0012�eKf�1_\u000e�/Ӗ���\u001fn3�Jx�\u001c�,H\u0014P��x's��QQ}�\u0017{\u0013�d�ޒ\u000f����>�2y9�\u0004�0�jj9��2p�gp�\u0007a���d���\u001c+����e�㠩�1�|�\u001c\t؎�\u001f\u0001�Q�)'\u0003À+QJo���᷻���S�a�m��N�t\u000fk�\u0001K�u6�g몾G�6��T�\u0017��e8d0W�\u000e��zy��ʪS�����z\u0003\u000bXb��4�@�\u0005��K�$��gԤ#r��W�0G�'_\u0010\u0006�I\u001eK���\u001a&\u0005=���\u0017+7Pф��\u0007\bA�\"�V_[���M�����\u0019º���W^�I��)<)�!_=Q����T*������t�nڿ\u0001�\u0017d�v��ވ���+/���/H��\u0001���'�����/�g�\u0002ptѹ\nendstream\nendobj\n777 0",
    "source_url": "https://www.csusb.edu/sites/default/files/Sentential%20Logic.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:16.305999",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:16.306488",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:16.306488",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sentential%20Logic.pdf_1_1748286796335_3536",
    "text": "obj\n<<\n /ColorSpace 3 0 R /Pattern 2 0 R /ExtGState 1 0 R \n/Font << /F120 210 0 R /F69 182 0 R /F93 189 0 R /F27 378 0 R /F28 829 0 R /F30 314 0 R /F297 685 0 R /F306 686 0 R /F73 183 0 R /F29 848 0 R /F31 313 0 R >>\n/ProcSet [ /PDF /Text ]\n>>\nendobj\n854 0 obj\n<<\n/Length 2896      \n/Filter",
    "source_url": "https://www.csusb.edu/sites/default/files/Sentential%20Logic.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:16.335499",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:16.335499",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:16.335499",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sentential%20Logic.pdf_1_1748286796412_6726",
    "text": "/Page\n/Contents 924 0 R\n/Resources 922 0 R\n/MediaBox [0 0 612 792]\n/Parent 884 0 R\n/Annots [ 900 0 R 901 0 R 902 0 R 903 0 R 914 0 R 915 0 R 916 0 R 917 0 R 918 0 R 919 0 R 920 0 R 921 0 R ]\n>>\nendobj\n900 0 obj\n<<\n/Type /Annot\n/Subtype /Link\n/Border[0 0 0]/H/I/C[1 0 0]\n/Rect [388.781 649.599 400.43 659.612]\n/A << /S /GoTo /D (fr) >>\n>>\nendobj\n901 0 obj\n<<\n/Type /Annot\n/Subtype /Link\n/Border[0 0 0]/H/I/C[1 0 0]\n/Rect [381.088 611.332 392.737 621.344]\n/A << /S /GoTo /D (fr) >>\n>>\nendobj\n902 0 obj\n<<\n/Type /Annot\n/Subtype /Link\n/Border[0 0 0]/H/I/C[1 0 0]\n/Rect [412.632 573.064 424.281 583.077]\n/A << /S /GoTo /D (fr) >>\n>>\nendobj\n903 0 obj\n<<\n/Type /Annot\n/Subtype /Link\n/Border[0 0 0]/H/I/C[1 0 0]\n/Rect [440.137 534.797 451.786 545.159]\n/A << /S /GoTo /D (fr) >>\n>>\nendobj\n914 0 obj\n<<\n/Type /Annot\n/Subtype /Link\n/Border[0 0 0]/H/I/C[1 0 0]\n/Rect [135.064 511.228 147.355 520.725]\n/A << /S /GoTo /D (e9:1) >>\n>>\nendobj\n915 0 obj\n<<\n/Type /Annot\n/Subtype /Link\n/Border[0 0",
    "source_url": "https://www.csusb.edu/sites/default/files/Sentential%20Logic.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:16.412025",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:16.412025",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:16.412025",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sentential%20Logic.pdf_1_1748286796554_5218",
    "text": "\u0001�x2[���e\u0010&��y�o~�7\u0002΍<��\u0014Bi��)���\u0000�v&�>\u0001\n�\u0006���\u0017�\te\r���D��_\u001b�>gL\u0004!��<�0a�\u0006V�\u0004��(�\u0015싍�ƴ���R��o\u001e��ݨ\u0006iH\u0017�pq\u001c��1A�#4�\u0012�_���?��p\u0005�\u0007,��]\u001ap��@i�i\u001eh٩�\u0018U� JZ�܏�\u0015��\u0013\u0006-�\r\u001aq�`�sl��� 8��\b\u0019�\u001fG���z\u0002\u001c\u0018q�Y��\u0011\u0000\u0011�\u0015~Y5\u0018h!�\u0010�8�:�u��\u0004�gck�����g��@��\u0018��kC^Ja\fd\u000e._I\u000b'\u0018�\u0014\u0005�\u0010�h).$\u000e>���f���MS�UW\b�}q�ޑ�1��1(V�+��tD\u0013_�\u0000>\"��s!ML��\u0001\u0016�bڥ�&Y\u0004~�}��&�+���]\u0013Ғ���&'B���s&!��ND�­]c��<[Va\u000f�\u001c�<�\u0017C�}���\u0015�.!v7�o�u#řX�\u0019��\"\u0016\u0003�e�\t�xJE\u0004T\n\u0017������D��2~΀I�dP\u0016g�2�Ġ�L\u0004e�ԓ\u0010�X�\u0006�k\u0004�%��:�\u0011_v\u0018�z}�\u001c�Y�>]�����=\u001e�Q�\n�~�F\u0002�,\u0006�\u0010QA�H\rH�}��loR��I��k<��\u000f\r�w\r�\u0001��?\u0003��r�-�>`\u0004f]�{\u001a���|\u0015c�p��Et\u0015vU��6�\u0007\u000e����L�!�f�\"}&]�3r`0��.\f�*|!/��!]���l�\u0011Yn�\u001a��f'�\u001aJ\\a\u001b��A˛�z��\u000e�\u0002�\u0018��wٺ1/�ߔ�|Y��\u0002��# �\u0013�M�E�.���\u0006y\u0014���ڷ~\u0006w�6�^�&7�_z�0�\rݰ{�\u0014�Fm�\u001cy�O�3ն�̴�v��S�\tz��68�i�RO\u0016�Ov\u000e�ҽ�6��k������j\u0018�(���C^���\u0011P��f �~�s�s���\u0005\u0018w�53��\u0016\u0019���i�\u0013\u0016h(s�\b���\u001ff5���7����f\u001fB�):\u0018B���\u0007#\u0017,~\t��~�9��x8ra� �l��;P9\u000f\u0012\u0016=\u000bHg\u0001^D���\u0000",
    "source_url": "https://www.csusb.edu/sites/default/files/Sentential%20Logic.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:16.554713",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:16.554713",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:16.554713",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_18sec3_3.pdf_1_1748286815048_3522",
    "text": "obj\r<< /Filter /FlateDecode /Length 987 0 R >> \rstream\r\nH��VMO\u001b1\u0010�ﯘ�F�ff�]\u0001\u0012\t��\u0001��=F��\"�P�\"�¡����#6�I��u�����nZ\u00050�5�]sz6k�?�������\th����ɬ�v�~�E �\u0016\r*D��}\u0002��\u000e(�������?\u0001\u0007�\u0002�\u0000�Uӎf��\f�\fy\u00156��N\u0019�4��p�_|ϙjt�*\u001a]�/�@�\u001dx��n�l1g~3�6RjbV��p�J�I'�wU��KX�7W�\u0006��#��\r��ȣ\n�VD����\u0017K�\u0017�S��d\u0015;\u001f�]_D(�ҩ�e�\u0012w�\u000e렌ኺ\f5�\u0018Mż��N���w'V�m��hK��K��\u0006�\u0017wi$e1�j�X<�Qq���. �\u00135�p.\u0014�����qFE�y�ґ�Z��\u0003�'\r��4����\u000fi�-�'�;\u0015�x�\u0019�m�\t��&\r��P\u0007���蹵���Y�E�\u0002V�Z�%V�c��k��=y\u0001\u0013�u\u0014v⿭�d�r�&HIh:���U\u000f&2֧�SA�/���BL\u0004�\bYG\u001f�А�\u001a\u001bꂋؘ���4\u0003���8}��5 c�Bb]a�\u0019c2�.Z{~������ʹX�\b��ჭ�j��ur��\t�dB�o+�\u001c�=i~��جG�/����z-T�WX��\u0016�+�\u0007���ie���\u001eL�1\u000ea�;1Ɛ>�U5<�\u0000-Ƣ�А��NL�\b�t\u0013�g\u0018�=�ZA�e��\u0016��\u0003��[�L6�ގ^=��I�\u001c\u001e\u001f�\u0007��\u0007\u0007\u001c�!����'\u000e���P�Y�y���W\"\"�WD!���\u0005ӽ\u0017�I�Иn�]��#\u001d�a�c�Bq�\u0002\f\u0000�\u001fd\u001f\rendstream\rendobj\r989 0 obj\r700 \rendobj\r990 0 obj\r<< /Filter /FlateDecode /Length 32377 /Length1 49736 >> \rstream\r\nH�\\U\u000btMW\u001a���Ϲ7�z?�b�&W\"$�D=CI%7B<�-��� \u000f��P:Z4�X�W��Z������ҡ�iâSU�~�zL��\fcT;,�=_2�Y�o����Ͽ������\u0010\u0000�1\u0007\u001aY\u0003\u0006'���\u001c�\f8P��������IgʀO�\u0002rc��b���.",
    "source_url": "https://jcsites.juniata.edu/faculty/wang/logic/18sec3_3.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:35.048701",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:35.048701",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:35.048701",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_18sec3_3.pdf_1_1748286815117_6279",
    "text": ">��\u0019��}�>V{Iu\u000fR9�����\u0019r7�=���x��e�v�^�rH-ֆ\u0014]�.�}��6�r�̄2h�X2�u�m��\u0002���GO��7}Ȳ�!z\u0015k%�ߕ\u0019�בh?\u0002�\u0000eY\u0001ewV�2�^F\u001e��:��\u0016·_��h��P\u001b'ϝ\u001f��0v��M�`'��XF\u0007\\}�\u00051�}�\\�yz���C�M�(�swrIJ��w�|\u0006r\u001c)�T���<WA��L\u0006�a[R�s\u0003��2?����\u001c��x�\u0006��\u001bi���i\u001a?��Γ��49�e2��8�\u00146�9������*ϓ��;��ϔ)�C4�\u001e�ޗ��\u0019js�50\u0013�C���=�{\u0018��9s���z�j\u0017��v��m�׬��4�?�S�4+y�\u00158��㤟��T\u001e����}��|�\u001dD\u000e���\u0018�?�B\u0013�k�n�%��s�g�\u0012��4��X��|zZ�L$p.",
    "source_url": "https://jcsites.juniata.edu/faculty/wang/logic/18sec3_3.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:35.117884",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:35.117884",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:35.117884",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_18sec3_3.pdf_1_1748286815174_3669",
    "text": "v�O��˖�j\u0001\u000bîu�1��܌��4f�\\u\u0004%q\u0012��\u000b�$fC�܂@�.����\u00076�\u001b�57w\u001c^���<�\u001f\b�ܼ\u001f�y\u000f������/^��Ğ�?\u0005\f���\u0002�:Z�PWnx��@�\u001d@8�$\u0016�\u0000`�N�\t��\u001f\u0004N:c\u001e��pې>\u0016�;b�\u0005���঑���[;���J�N~cy��\u001f��~��<�\u000f5��]zr�\u0011��?\f���HB�tA'�.z8Q�Q�Q8\u0011#�Ng58�\u0019\u00075�t�Vw�{�͹��\u001c�\"k��X\u0015y\u0014@A�&�f�,\\�\u001du���\u00182<�\u0004H�(\u001c\f�碤�\u0017��oP��M!����5��7�?�@`d��Ht�����S�}'����0�\"�C\r�G���\u001b�C",
    "source_url": "https://jcsites.juniata.edu/faculty/wang/logic/18sec3_3.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:35.174905",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:35.175899",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:35.175899",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_18sec3_3.pdf_1_1748286815338_2566",
    "text": "(\u0001/\u0011E��w�|tǕ\u001b�\nO�߶\\ o\fh�\u0019{�q�V�ށ4|��\\�/JG4�\u001e|�t�tutp�\u001c4����^UWjr�Nt%�,L*\u0013\u0005\u0001ؗ\"7C7�T���$v�5�6�҃>\u001c\t�@\u001dЅ��}�\u000f��w\u0005��=�!(\u0004N%/����ȍ��\n\u001c���C���\u001b�:>/^JN&o��'�&\u00169��Y�襮QnLo\u0013�MU�u��\u0005\u0007�Y�\u0002\nK\u001c\"�l&ԬF���kâ(`��� ��\u0000��7h�^G?ES��WiL#ně���(�z���b��\f�tl��}�#�nJ�-������`\t\u000e^a\u001a@i�n�n�\u001a�:��8��z\r��\u0011�0�jPK$TU�*�Lͫr\u001eN�E�Ȳ�'Ennv{�b�L脸\u001e�y\u000f�7S\u0004f*Q`��V�v��M��C|8\u0019Je��O\u0016Y�͠��\u000e�g\u0000-4\u0006��\u001e�\u0014=e����s�F�y��{0jϓ6�7n/�\u00189>���ӌ�\u0018\u0017T���L0\be��?=�@�\r��\u0015M\u0004��^z���\u0004L~�\u001bY�++�L����\u001d{�\"��\u001a�Yb��z�싍O�~\fP����[.��?\u0011)�;�a�߇�/��\u0011N\u001e���FK4�\u0018oP��Z��\u0005\u001b(d�H(�M�A\u001b�[\u001b'`�2ݰ��Cq�-�-�-�-\\�֤5��T����k�5�Y���|w�;=�;l(�\n�C�BbX3�aXSƔ5�|\u0019_֗#X����?��b��c�\u0018nѤ�i�O\u0007�d��V�V��\r�M\u001b����\t\u001f\u000f<�2|�khw���=\u001b�7g6g7�67lZd�\f�����B�@cS,�����\u0006�S���\u000f�é)����T�F�Z�b\u000eua�\u0012�\u000f\u0018^\u0000��h�Z��r�뼜������>������\b��h�\u001b��1n�D��*\u0004�$UHuTH���\b(~!\u000b�G 2\u0001!�IY'���\u0015\u0002�KֻV�:�\u000bW�\u0011�!�To���0)ߗ��(+r��>���\u001c��Ă4�\rX��\u001c\\�&��L�$�����,1��]��Q\\W\u001c�{�3�\u001d����Y�ӳ\u000f���ewm�Y�Q�y�Ħu\u0015��\u0016K<�`\u0012l�\"\u00105l[\u0012�T\u0002TMP[9jS\\�*\u0010��\tQC�J\u0015\u0012���KT�\u0014$D[�V��P�uϝ%\u0011�z=��c5{t�9���/O�z�J\u0003��\u0010�\u0001R:�$�M)�^�|^\u0004�E�JH�\\|�\u0016�[\fޓ�Imb�J��",
    "source_url": "https://jcsites.juniata.edu/faculty/wang/logic/18sec3_3.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:35.338653",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:35.338854",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:35.338854",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_18sec3_3.pdf_1_1748286815489_1396",
    "text": "\u0005��d�5+�\u0010@\u0018�''`\"!�V\u0019XU��\u0015�\u0017\nbY�,��X\u0011\t�N}?��}�1��k�i:ט;d\u0010\u0012��J)�\u0004\u001e_Ȧ\u0011\u001b�0\u001f9������U�8�օ#l�\u0002�\u0014�E��\u0002c���Dhp0��0\u0016��S*��*L\u001b��#]LIEC\u001d��P��H�\u0017'�z��{r�_o\u001d�C���ۡ�����\u0006�\u0017ˍtǞ��\u0003�&\u001e��Ȧ���]��[~~Fg�\u000f�uK�P�\u001dx�kD��ƍw��Qی\u0018:@N\u0000\u000f�&rY??���\u000b���#i�+\u0012RI\u0013��&c\u0018-��\u0014+c���IES��]��T�����\u000f��ޝ�]U\f$�4cfm&�+�\u0018�\u001c}�v�\u001b��\tq�7��\u0003��\u0003�.�O��#�e9�c\u000bL�\u001dA6;f~���\\fl\u0014d��\u0012�\u0019�N#�s��MD��O�Jl5�&JĘ{��}�|�2�N�',׉�\u0013\u000b��\u0016\u000f;Ϡp9�\u0010\nSa�2\u0013\f�|��&Q����k��pH\u0018\u0017n\u000b� \u0004~OAjfu\u001e������V��רf���\u0000\f�]\fs�\u0015�\u0001�)���C�\t�\u0014�z \u00190v\u0001㳵���Y��Y�e\u001dfM���_qiv���?��ᦽ�?ڼkb�c�\t��xRC\u0000��=�s�A\u0016�}��;�^=���Q�3\u0013���:p�Xw��'�<�\u0019�\u000b��߁�{\u0017ۇj3���G�\u0000 \u000f��\u0003qX����rJ8\u0015!��.[��\u001c��NS0�pH��\u0015f�\u001d7�½�h0s4�\u0010ñ�8!��� �b\r�\n23$��C���\u001bA\"�\r{a�\u001fEɦX=�Y��!�g�ׯ�@�q��|\u0012��3��ڣ��w��\u0017�NX�\u0001�R(����n��N��6�5+Jj��\u0018�aǈc�1�\u001d���$M2���\r��,᠎\u001d�\u0003���\u0017KHa��ٱR��\\A�1\u0019���� �7��|~A\u0004d$�;ӓ�f\bj(2\u0015����Lx�\u0007|�\u0001\u001f6��P�aPT�A���*�\t\u001fv01���8�\u0003���>03����;�����\u0002�˹���(�)�X\u0006|`2u��\u001d�>�`�ϔ�Mg���\u0004ΣW\u001cb���\u0011�.��i�\u001a\u0007{",
    "source_url": "https://jcsites.juniata.edu/faculty/wang/logic/18sec3_3.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:35.489697",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:35.489697",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:35.489697",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_18sec3_3.pdf_1_1748286815633_7546",
    "text": "�\u0004�\f@+�\nf\u0001\u0006>��hGɁ��q��w\u0007��{��e<1Y\\�\u0012�6��e�G��>W���{�;\u001c��®\b��lp\u0010�<\u0007�v�k���$,%�j��<�L#\u0001j\u001by\u0005�{g+�\u001c\u0013\u001dv�g\u000e���\f�Ҷ6�ݽ���S�\u0003���H{���X������؆�~��H�'\b�!\u000fmk��?n,\u0002��|�ϛ�۰k���+\u000b\u0019�Y&(�O�^1�ue\u001f\u0004\r*��)\u0005U��8����8\b��R'��|4�uG�h/B\u001a�\u0016;G\u0003�]U�\u001cm\u0004�2�!\u0004d��Z����\u0014��8b\t\u0007\u0002\u0001\u000eT�\u0019\u000eE8\u001a��\u0002w��p\u0015Q%x��+42yg����ɥ�\u0006u�U�nR�\u0014�j(�4��\u0007�\u001e�T<��H놖0��au$�6��55i}�CjL<\u0013�����~�a�\u001cͭ��;j��Qh\u0018ag���p�1_#ٍ=���\u0011�N\n�+�^�Ȩ�ڤ\u0018�r̐w�����9��a\rI�1R�d�3Ռ���\u0003Ny\u001e��\u001b�\u001b�k�k��·��]�nxQ6X����W\u0013��i0�NcUG��z��3��&\u0013\u0005(���F���?\b]�u>�i���~��_տJ��^�_\u000e\u001b��)&\u000f�C�����a���\r~6�7��(�R,r\u0015eA\u00004�L6\u000f�\u001f!W��\u0001�X�n�s��2\u0001\u0006�\fǠ���sթ�\fY�a�d��h��a�����x\nA4B�`��w���m�a���}��>��l�/;>�mr�d�]RG��ҦI���\u0001k\u0003�t+��\u0004R\u00124�\u0007-\\�`I��¨\u0004i��*A�\u0010,M���h4�\u0000UbZ+A�\r! �?\u0002��褬��%��|�T\u0004�N��ϟ?ۧ���}��;�۪�.7�Ԗ6\"!��\bB�\u001b�\u001d�_\u001a�U��\u001b\u001a��\u0001n���(���\\�T�B�Ft�b�\u0003�Y6)�l7I�\n��\u000e��{b��\u001f�M�z�cmt���\r\r��8m�0\u000b\u001b\b��Ck+p\u001dh\u000e��\u0015��)I�\u000e�\u0013\u000b�'\u001b\u000eE��\u0010�:�̍H\u0004o�\u0006^�����so�a2i�\u0019�\u0017\u0002��\u0000�5`�I(�t�\bZ�$�\u0002&�0�p�a�\u0001�@xh�FG@�B���\\A\u0015�BUB'ó�Ye61��k��^im\u0000f\u0004�K\u0000y¶P�ޖ�~�T�T�?:��R�T�a,�A.�0\u0012�\u000e���E��:\u0005X�{�q\u001a�t��Q�\u0007 ׅ��\u0005��V7�.��^\u000f���.�N^\u0012�ϊԟŁ\u0015u#����W#���.",
    "source_url": "https://jcsites.juniata.edu/faculty/wang/logic/18sec3_3.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:35.633005",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:35.633998",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:35.633998",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_18sec3_3.pdf_1_1748286815715_4482",
    "text": "\u0017\u001bXYb�\b\u0003\u001e[X.{2\n&@��Z�l�\u0005�BGQ��d)�(E���+�\u0007��0\"�U�+��YY�\nQ�Ӏ\u0004֠q]��\r\u001b7mnFjK�s�[�ڷul߱��+���n�&\u001f/����K���\u0013{Z���t� [8�X\u0006?�\u0010C\u001c�Ў\u000et\"�]��K��I��iw���v�K���y��\u000f���j4���AV�͇��o.V�E\u0019�U<���;�oQ�P��_\n�X\r\u001e{�qY�\u0003�2G�M�\r$��\u0019��PK9�UYG��Ue�ڇU�#yR�\r$_M��R--�����H*s���`�Г�!E��h�\u001aD\u001b�}\u0010\u0019�PK\u0006Gъ�t݃!�2؇1\f���\u0013�z�z�1�\u0005w�G\u0007�'\u000fY\u0010�,��[�\f���9���\u000fρ˺��\u0019{uVr���h��Th��q�����\u0017�\u00115Z��'��3~e�T�\u0007�����,�*�/l�\u0016�\u001a�=a��\"]��ˎ��\u0000����\nendstream\rendobj\r991",
    "source_url": "https://jcsites.juniata.edu/faculty/wang/logic/18sec3_3.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:35.715936",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:35.716200",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:35.716200",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_18sec3_3.pdf_1_1748286815880_3071",
    "text": "[7�{�\u0006�r�Ûx����u\u001cA\u0013>D\u00142�\r�؈:X0�%�C\u001e���\u0014c6�\u0017vp>;�º�\u0010Gљ�ͯ�\b���l����A\u0015��hs\u000e&₲\u0014�1\u001a3�Ŧ�\\kn0_�.\u001c�\u001f�w\u0010\u0002\u001b��Z�����/��\u0016��\u0005\u0017hC��H�(�Y�E��V9I!����3�c\u001e� \u000b-tB8�{\t�R4��t���4�wY�\u000b&�\f[q���paW'�Yf\u000b:s�\u001a��\u0005\u0007p��\u0019��9��m�+f\u001bb���\\O\u0013N�\t黳�7�\u0011S\u0019��\u0018�;U�3>�i��-Q����j����\t\"�\u0007�8��l�O�%\u00162-��+��0�3.����{�D6�Ec�)�ST��r&�8b\u001f�b�3ޛ��yr�!\u0011*Z�Ne�r���\u0019�'\u0012�\u0017�\"ޢ0�T�Y�\u001c��/E��,^\u0010��Fe�r��檟F%�`/nQG\u001a@��[*�Z���i\u000b��i�&���b��!�d�<�\fc�Wf)K�\u0015�*�5����ﯾ[f��\u0002��\u000fK8�M�Ε\u001dA+�1]�eR)�4��8z�i!��?P\u0003��&�r�.���\u0003ݤ�\u0002L\u0016\u0011+�\u001b�.f�yb��&Z�N��Ŀe��&\u001d��L�\u0005������\u000e�K�MiUL�9Y�W_R\u001bԽ��j�%��\\\u0010�>�e睄;�}����\u000e���K��ghc\u0014�\"��w3U�y�sǽ��)���Q\u0002��hFf2UP5�0��h+�\n侟�1J��\r�9Lt\t����'��1LO�\u0012Q-֋\r�I�\u0015?K�\f��e'� ��I�DΖ�e�4�G�\u001f��Q��d*�JW��\u0012�8���de��]��\\U'�'կ,��J�\nK��_�'���\u001ck�u�u������B��wp\u0010���C\u0017�\u0012�\u0007�V�Ub�)q��y2�e��N\u0015\r�R,�&�]��\f\u0016�)\u001bmJ �\u0017Ȫ��ߕ`���b���.8���.��6�մ\u0000\u0007\u0005O���A�����5�\u000bc)�~�&���.�/��RL\u0013��:���=\u0015+�X��T��x�oEOu�%�҉�\"�\u0015�x�� �=\\�@�NR��2�$�Zn�s��V%\u0018��\u001f9�V�_f)mj\u001e��\rX�\u0015�6�`��R�P)$=�8�\"O�Z��������D�i��v\u001f�90Tf�$�;g4��8�\u0010[�6�P�������)v\nM���\u0019�j8��\u0001���",
    "source_url": "https://jcsites.juniata.edu/faculty/wang/logic/18sec3_3.pdf",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:13:35.880354",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:13:35.880354",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:13:35.880354",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_WANSLS_1_1748286907597_2527",
    "text": "q�]����W��ь\u001d\u0005\u0003o��nz\u001bC�\u0013\u0010�-h\\Z\u0002�9J�bUP��\u001dU��\u0019�W�Ep�K�w}\u0014���S�\u001a�{M��V�R\u0007ey\u001d��璓/ㅌ8S��i�Cج�\u001a!�&\u001a��t���R��W��\u001f9¶<b>��\t>����\u000fS�O@*n���Җj�U �\u0015����<\u0016���\u0013-r�mX��\"�7�|EH�MOw���TܫHʝMN�!��j\u001f\u0001�@\u0016\"�x�4�\n�\f�O(�/D\u001f��x.�97=�\u001f���c���\u001c�\r��\u001d�\u0006۱��ck�:x�8h�MK�-�P\u001b@\u0010�l^d���?(��m\u001b�-�F\b���1��n��",
    "source_url": "https://philarchive.org/archive/WANSLS",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:07.597331",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:07.597331",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:07.597331",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_WANSLS_1_1748286907826_3382",
    "text": "3�\u001d\u0011\u00011V\u001c��!�@\u000e\u0004��R\r?�<^n��rKZ\"$d3�J\u0007�\u0001\u00119sXE{�^\u0017\u000f�`�\u000bן�\f��Y4\t[\u0005�>:N��r�\u00185Ơk4�\f�1f\u00100\u0003\\_\u000f~_��\u0013\u0007�\u0003'.\u0019�!��X�N�SU��\u0007��\u0010Du#�I�\u001e7�vz�\u001c�,��\u0018�r]{�t�;�D��;�F=\u0011`�I��M�ȡ�\u0016����ɨ�@\u001dC��(�K���\u0002�.\b+�p�������M���\u0005ra���B��h\u001d����q\u0003���o\u0016�ڷ�r�\\\"�y��D2\u0004B\b>E���'N�؈#l\u0002aӤɄ�u�j�����Á��W�6,�6������g��=�\u001d�3+ʦS�|n\u000b\\S��|u�[c�μ+g�,(-Y�Q=1:�#�9F\fC�t�R��@N?�\u0018\"F�}���Ӻ�6��~%�KI�\u0012\bX����%b$�����11w�1i\u0003��I�\u000e���\u0007gS��\u0014\u0003�\u0014��\u001f)I%ё�\u000fvNZ��\t�\u0016\rV�gf�_���X�v���\\��T�A⁧t{�Q{w��:�@��s���g��}D|�v��Y���;\u001f�\u001f���w����\u001a�굣�d\u0018�\u000by��\u0015p\u0011vg$��VF��=�/Ǖ\u0001_\n��o.2\u0015���J\"/J))%�\u0013�ҙp��!�H�ħ�\u0014-҂-n\u00061SD;�\u000f\u0004���DZt\u0016������.b�\u000f_�.��c�6hUU�2[F;(�\u0002M�Ǘ�\u0017W��W*�|�hk�\u001c)�'��њG\\�����tS�0\u001bAE\u0010���G�\u001c��`\f��h/u\u001e�,ZR-\u0007�O#\u0017�&�\t�$�|\u0013<���G�Ż�Z3(\u001a�<��\u001e�\u0017�Ϳ��\u0006UQ(�Q)\u0019+\u0016#\u0005\"�\t�\u0010\"��Nlg\u0010�=\n�9��M6�Z��˗�U����u|��3�HK}�pD��mQk�\u001a�G��q�*x\u0005�\u0011�I\tψ�|�\u0014��h�(\u0014��\u0002U�Q*�yɗ�J>��� \u0003)̔ҊC���\u0007�G���<;D\r{�.��d�[�&�6qF\u0003ޓ\u001a��ȲnβLg�\u0002_\f��y�\u0014�qy.�\u0001�\u0017�и��X���fF�m0Eb\b�b��\u0005[`\u0013��\n�8�(�\b�23�1\u0004ǎ�����1q\u0016\u0015c9�?|��u�\u0006�&��\u000b�~�\u001f\u0015�L�C��\u0011�M1�W�S|:�\u000eeAf\"_��n�M$�߄\u000f�$��\u000ey�\u001b��ڑ�?;F��λ�&f\u001a��2�\"⧿���1��v�\u0004(�0�\u0005�!��7���t",
    "source_url": "https://philarchive.org/archive/WANSLS",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:07.826072",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:07.826072",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:07.826072",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_WANSLS_1_1748286907999_6852",
    "text": "��79%n�\u000f�,�\u001f�\u001b��ˎD\u000b࿬j���eo��c�`\u0010\u000e\u001a����\"��<��ZY�qkQ�U\u0011\u0015=nҭ��`M��Z�iS��e!fsIF���Q��\u0015�д�\u0013P1��P�M��>$��\b�r��kw��j3L?���kr\u000f\u000eQW�`��1�Q�\u0019�\u001e.M)\u0001��m�ז�\u000e�*\u0006�����B\u001c\u001c0\u001eR�%Z(gO4�\u0016d.\u0007SrQM�n�=������\\��\u0005~Ї.=�r5/�,db9��g�\u0004;\n�/\n�T��M�9TM>W�.#�>ҳ]O�\u0006��(σ(�\u0015\u00168\"�H�S��p������-\u0015V�\u0001�m�\u0012Ւ\u000fZ��rv��Xب�f&,̢\u001dg�\u000e��}>o�6xm����\n+Vhq��\u0010p�X���:�Q�&N#���\u00190JZ9�I-�\t\\�:¥$ux4��n�~f�\u0016���r�j~&f4y��\u0014\u0007\u0005�N��{W�w\u0006�b�\t2�z�\t,\u000e���N�\u0001��ܬ\\\u0017������]�߬�llMu�@7ٚ�E�\u001b(\u0017��l���\b���8�u\u001f����z���\bRr��\u0010R>Ad\re��4.f;�\u001d�Sa4�6�\t\u001c�0\u0002}P�TB`�=�\u0004�tE��em�1�CB�\u0015\u001a\u0019Z��\\_�'\u001av\u001dq\u001f ��\u0004@�dX�����hAW��h�\u0002M�U]�u�Cz���պ��H�K\u0019\u001d��Y�\u0007��in�;;AI�;Ig\u001c�����-5B��Ds��\f\u001f��q�X�0\u0019t��+r��Z�\u0003C���aO\u0003W��� F�\u0018\u001c�ˉ{;\u001b\f���\u0015\u00125̓�.��NeZQi\u0007\u0000a�gY\u001e���r\rC�v��~\u0002��>G.���r}\b\nU��\u001a&�Ԏ%[�[tf\u001a���]b���8͗�)5��j�!�-\"�I��A\u0018N�+�m���\u0011s~-��\u0010�8C�WS�\u0012\u001a�Ԭ%�m\u001ai�\u0010y\u0019�\u0019\u0004�[��0U�qO*��߸�pP�Өsh��f\u0007���Ov�As_���'\t}�>����;�\u0011�[\u0017��!��%����F�W]��S\u0017��!Yh*x\u0007%\u0007(H��\u0018\u0013\u0019\"E�+�q�z��4-���!���\u000bP��nm�\u001fe!HlGjV�YZGMh�\u0012�\u0010�\u0017�BB���G\u0017O�W6�GK�-�mD;#�<:\u0010���**\u0017�m룽l3K[�\u0006��ɝ�/\frXg�V\u0004� ��atI=m�\u0001P/�\b�Xkh�x��6O���/�f \u0018���{)4",
    "source_url": "https://philarchive.org/archive/WANSLS",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:07.999608",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:07.999608",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:07.999608",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_WANSLS_1_1748286908023_5561",
    "text": "<xapG:cyan>100.000000</xapG:cyan>\n                           <xapG:magenta>100.000000</xapG:magenta>\n                           <xapG:yellow>0.000000</xapG:yellow>\n                           <xapG:black>0.000000</xapG:black>\n                        </rdf:li>\n                        <rdf:li rdf:parseType=\"Resource\">\n                           <xapG:swatchName>CMYK Magenta</xapG:swatchName>\n                           <xapG:mode>CMYK</xapG:mode>\n                           <xapG:type>PROCESS</xapG:type>\n                           <xapG:cyan>0.000000</xapG:cyan>\n                           <xapG:magenta>100.000000</xapG:magenta>\n                           <xapG:yellow>0.000000</xapG:yellow>\n                           <xapG:black>0.000000</xapG:black>\n                        </rdf:li>\n                        <rdf:li rdf:parseType=\"Resource\">\n                           <xapG:swatchName>C=15 M=100 Y=90 K=10</xapG:swatchName>\n                           <xapG:mode>CMYK</xapG:mode>",
    "source_url": "https://philarchive.org/archive/WANSLS",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:08.023383",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:08.024383",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:08.024383",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_WANSLS_1_1748286908065_7790",
    "text": "<rdf:li rdf:parseType=\"Resource\">\n                           <xapG:swatchName>C=30 M=0 Y=10 K=0</xapG:swatchName>\n                           <xapG:mode>CMYK</xapG:mode>\n                           <xapG:type>PROCESS</xapG:type>\n                           <xapG:cyan>30.000002</xapG:cyan>\n                           <xapG:magenta>0.000000</xapG:magenta>\n                           <xapG:yellow>10.000002</xapG:yellow>\n                           <xapG:black>0.000000</xapG:black>\n                        </rdf:li>\n                        <rdf:li rdf:parseType=\"Resource\">\n                           <xapG:swatchName>C=60 M=10 Y=5 K=0</xapG:swatchName>\n                           <xapG:mode>CMYK</xapG:mode>\n                           <xapG:type>PROCESS</xapG:type>\n                           <xapG:cyan>60.000004</xapG:cyan>\n                           <xapG:magenta>10.000002</xapG:magenta>\n                           <xapG:yellow>5.000001</xapG:yellow>",
    "source_url": "https://philarchive.org/archive/WANSLS",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:08.065046",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:08.066039",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:08.066039",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_WANSLS_1_1748286908080_2019",
    "text": "/lal&#xA;7o35meVk/QKQ/wC4nzFo8UsOqtGyK8REs0y204VuUbK8ZCmvH3VZN/zhPZeYofLvmOe8S4TQbie2&#xA;OkiXkImlVZRcvEp23BiDMOtKdsUPF/P/AJYkjstE025uIrUeXtUv/Kt7dScuEKLeNd288tATwdLu&#xA;QrReiHbFUXbeV9LhvfOH5YaXq9vr73aW+o+XdStv7ue+sEeQQJQupeW2uJoxxYgvxFcVeSkEEgih&#xA;GxBwq9A80MNY/LfQ9W9T1LjT3W0uiy/GTwNuFDb1SGCytjvSjS/TgVJ/LMDaNbHzLfyNBbSRXFrY&#xA;Wq7S3vrxPbzKv8sASRlkk/2Iqa8VU+/KfQr5bXWPMkUPOf6vNomgRs3AT6nqcLQMFZqJxt7SSWaQ&#xA;sQF+GvXFUks/y38zDzRo2jajZPaxaxdrb2t829rLGsgWWaG4WscsSKeRdGIpvXFX2d/zj4GvvLmv&#xA;ea2h9JPNevX+qWnIgv8AVTIIYVY/5PpNT7++Ksp81/mf5F8p38Nh5g1QWV1NEJ1T0Z5QsLOYxLK0&#xA;UcixIXBHKQgYrTKcVQGu67pWg6Pd6zq04tdNsYzLdXBVnCIOp4oGY/QMVSHSvzY/L/VqCw1USzG6&#xA;hsWtmguI51nudoRJBJGsqK9NpGUJ74ppluKHYqlHmrzd5c8qaUdW8wXq2NiJEhWQq8jPLIaIiRxK&#xA;8jsadFUnFUo/5W3+XY8rT+an1lI9CtrgWdxcyRTxulySq+i0Doswf4wSOGw36b4rTLsVdirsVeI/&#xA;mp/zjvrf5jecX1HUfN01n5bT0TaaKkbzCNljCTFA0qRRs/GvIIeu4xS9m03TrLTNOtdNsYhBY2UM&#xA;dtawgkhIolCIoJJPwqoG+KERirsVdirsVdirsVdirsVdirsVdir5y/5yC8iWlrrd1q10fQ8r+b44&#xA;bPWLuh4WGr21Rp9/IF/",
    "source_url": "https://philarchive.org/archive/WANSLS",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:08.080039",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:08.080039",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:08.080039",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_WANSLS_1_1748286908123_1694",
    "text": "<xapG:black>0.000000</xapG:black>\n                        </rdf:li>\n                        <rdf:li rdf:parseType=\"Resource\">\n                           <xapG:swatchName>C=0 M=95 Y=20 K=0</xapG:swatchName>\n                           <xapG:mode>CMYK</xapG:mode>\n                           <xapG:type>PROCESS</xapG:type>\n                           <xapG:cyan>0.000000</xapG:cyan>\n                           <xapG:magenta>95.000000</xapG:magenta>\n                           <xapG:yellow>19.999998</xapG:yellow>\n                           <xapG:black>0.000000</xapG:black>\n                        </rdf:li>\n                        <rdf:li rdf:parseType=\"Resource\">\n                           <xapG:swatchName>C=25 M=25 Y=40 K=0</xapG:swatchName>\n                           <xapG:mode>CMYK</xapG:mode>\n                           <xapG:type>PROCESS</xapG:type>\n                           <xapG:cyan>25.000000</xapG:cyan>\n                           <xapG:magenta>25.000000</xapG:magenta>",
    "source_url": "https://philarchive.org/archive/WANSLS",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:08.123089",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:08.123089",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:08.123089",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_WANSLS_1_1748286908221_5013",
    "text": "�\\�=�m��zٖ�����AI��\u0014�:�\u001bW�:��N�S��\u001429���T,B\nP�p�Q�p�\"�\u0006W�\u0005?\u0007�߼O�\u0011X{�a�,ٵ]༮&\u0013\u00108�\u001d�\u001ba\u0019�\u0013<���dj��х\u0015x�1J�I�_���C�Y�W2N�XÇ�cw\\�f�H�\u001b7\u001e�z���\u001dTy\u0012��J��\"�f�V]��;\u001aK�;�s>�Z��>�\u001a�F}��_\u001f2�\u001d�\u001b~�'K0b���p�\\�i�adJp<�Yz�:�=$�\n�A�$c\u0007�\f�E�\u0015\r�%�\u0012~`��b���\u0019vga\u0017<{�ų�g8�5�b�\r\u0018/\u0014�\t�����岨3����D\u000b��<��uӖ$jq\u0006��(��PU���/�YK�p�HT�ܛQ�F��J�m�\u000f1�\u0015�Q�������@]�0g��ￜ����aܗ�\u0013��͑��Ƿ\u0011Ҿ��\u0017_��0m\u001aS��ѯ\u0015G\n�����kCgN\u000f~u�?s��doO����cG�R�=�y$�x\u0006w���C_��\u0007�cm��H8\u0014�\u000e�4\u0007�M�>��i\u0010x\u000euq1\u0012�\u001a�\"i�Z$�sXRH����4A!Y�A�'m\u001eu��'EP�H\"cF\ri\u0019�xS�Y�\u0013!!}����!\u0001\u0017\u001e)",
    "source_url": "https://philarchive.org/archive/WANSLS",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:08.221226",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:08.222049",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:08.222049",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748286909469_9207",
    "text": "The inference rules (rules that must apply to an entire line in any proof created) we've learned so far are Modus Ponens, Modus Tollens, Hypothetical Syllogism, Simplification, Conjunction, Dilemma, Disjunctive Syllogism, and Addition. The replacement rules (rules that may apply to only part of a line in any proof created) we've learned are Double Negation, Duplication, Commutation, Association, Contrapostion, DeMorgan's, Biconditional Exchange, Conditional Exchange, Distribution, and Exportation. A summary of the rules is given here: http://www.yuksel.org/e/philosophy/logic/19rules.htm The first problem I was having issues with presents this premise and conclusion (the Pr. indicating that I justify making that line by it being a premise of the given problem, with the conclusion following the slash): 1. (A ⊃ C)",
    "source_url": "https://www.physicsforums.com/threads/symbolic-logic-homework-questions.539453/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:09.469703",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:09.470703",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:09.470703",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748286909503_4846",
    "text": "Pr. / ((A • B) ⊃ C) Since I was told that working backward is a good tactic, I started with the conclusion and noted that, by the exportation rule, it is equivalent to ((A ⊃ (B ⊃ C)). Because B must be added on by the rule of addition, I must be able to prove that either A or C, or maybe ~A/~C is true. I tried using contraposition to get ((A ⊃ (~C ⊃ ~B)), then changing to ((A • ~C) ⊃ ~B), but I'm not sure how to use Modus Tollens and get (A • ~C) by itself since that would require getting ~~B, which can't happen as far as I know without getting one of the other variables anyway. So I'm stuck in a bit of a vicious cycle. Another problem that's giving me issues is: 1. (A ⊃ ~A) Pr. / ~A I thought using conditional exchange would be good here, since you could start from the premise and get (~A v ~~A) or get the same by working backward from the conclusion using Conditional Exchange, and this would be equivalent to (~A v A) due to Double Negation.",
    "source_url": "https://www.physicsforums.com/threads/symbolic-logic-homework-questions.539453/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:09.503721",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:09.503721",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:09.503721",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748286909554_1654",
    "text": "From there I tried DeMorgan's and got ~(A • ~A), but it's sort of \"trapped\" within the tilde even though I know replacement rules can still apply to any individual part (for example, I could still change it to ~(~~A • ~A) by Double Negation). Basically, I need to get A/~A by itself and somehow that should work out a proof that contradicts itself. One other thing, if I may; I completed this problem but am not sure if I'm misusing Conditional Exchange, and if I knew it could maybe help on the previous problem: 1. A                      Pr. / ~(A ⊃ ~B) 2. B                      Pr. 3. ~~A                 DN 1 4. ~~B                 DN 2 5. ~~A • ~~B       Conj. 1, 2 6. ~(~A v ~B)       DeM 5 7. B v ~A              Add. 2 8. ~B                   DS 3, 7 7. ~(A ⊃ ~B)",
    "source_url": "https://www.physicsforums.com/threads/symbolic-logic-homework-questions.539453/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:09.554648",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:09.554910",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:09.554910",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748286909622_5287",
    "text": "TheAlli said: 1. (A ⊃ C) Pr. / ((A • B) ⊃ C) It's a two-liner proof in my head. You need a \"distributive\" law of • over ⊃. That's about it. It's just a lot of hard work getting the rules right in your head, like your first arithmetic courses. I am not going to comment on it too much, you need to rely on the didactical skills of your professors and your own skills here. Not a lot to do except for work your way through all of the exercises. (The \"distributive\" law you need should be obvious to you, probably is a side lemma, and probably can be proven by rewriting ⊃ to another form.) Last edited by a moderator: Oct 13, 2011 Evo Staff Emeritus Science Advisor 24,029 3,323 Please post this in the proper homework section. Similar threads I Syntactic vs semantic logical consequence (entailment)",
    "source_url": "https://www.physicsforums.com/threads/symbolic-logic-homework-questions.539453/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:09.622950",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:09.622950",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:09.622950",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748286909817_6365",
    "text": "Bluesky LinkedIn Share Forums The Lounge General Discussion Hot Threads Pacific Palisades Fire Threatening Santa Monica, California Started by Ivan Seeking Jan 7, 2025 Replies: 125 General Discussion That's Not a Drone! Started by russ_watters Dec 12, 2024 Replies: 67 General Discussion Why cats are smarter than dogs Started by xTheFormlessOnedx Jan 6, 2025 Replies: 41 General Discussion What are the odds?",
    "source_url": "https://www.physicsforums.com/threads/symbolic-logic-homework-questions.539453/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:09.817852",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:09.817852",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:09.817852",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Algorithms_and_data_structures&oldid=1245766542_1_1748286912602_5545",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Jlwoodwa ( talk | contribs ) at 23:48, 14 September 2024 (Undid revision 1245766465 by Jlwoodwa ( talk ): probably doesn't require frequent maintenance) . The present address (URL) is a permanent link to this version. Revision as of 23:48, 14 September 2024 by Jlwoodwa ( talk | contribs ) (Undid revision 1245766465 by Jlwoodwa ( talk ): probably doesn't require frequent maintenance)",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Algorithms_and_data_structures&oldid=1245766542",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:12.602336",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:12.603180",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:12.603180",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Binary_GCD_algorithm_1_1748286914814_6890",
    "text": "= v {\\displaystyle \\gcd(0,v)=v} , gcd ( 2 u , v ) = gcd ( u , v ) {\\displaystyle \\gcd(2u,v)=\\gcd(u,v)} if v {\\displaystyle v} is odd, etc.",
    "source_url": "https://en.wikipedia.org/wiki/Binary_GCD_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:15:14.814285",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:15:14.815286",
        "weights": {
          "static": 0.869,
          "dynamic": 0.131
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:15:14.815286",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748287542077_6995",
    "text": "Apr 11, 2025 Replies 14 Views 2K Trying To Debug A Python File Apr 11, 2025 Replies 11 Views 907 Python Partial pivoting in getting the reduced row echelon form of a matrix Apr 7, 2025 Replies 2 Views 465 Trying To Run A Python File [Solved] Apr 5, 2025 Replies 2 Views 365 Python Simple code example of transforming matrix into upper triangular form Mar 31, 2025 Replies 3 Views 629",
    "source_url": "https://www.physicsforums.com/forums/programming-and-computer-science.165/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:25:42.077601",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:25:42.077601",
        "weights": {
          "static": 0.896,
          "dynamic": 0.104
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:25:42.077601",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748287542210_3976",
    "text": "Nov 13, 2024 Replies 2 Views 944 Industry Embedded Software Development Environments Oct 25, 2024 Replies 4 Views 1K Trying to run a big python job with AWS (EC2), is there a better way? Oct 20, 2024 Replies 7 Views 1K How do programs draw function graphs? Oct 18, 2024 Replies 14 Views 1K Unsolvable python code bug? (finding the difference between two input strings) Sep 24, 2024 Replies 2 Views 2K HTML/CSS Container shrinks at certain screen widths (CSS) Sep 16, 2024 Replies 5 Views 1K User-Defined Functions in Sql Server SSMS Sep 10, 2024 Replies 7 Views 2K Python Help solving a geometrical matching issue with Graph Neural Networks Sep 6, 2024 Replies 1 Views 2K Python Zipping identical iterables Sep 1, 2024 Replies 5 Views 1K HTML/CSS [CSS] Why do my containers shrink at screen widths <347px? Sep 1, 2024 Replies 5 Views 1K Python finchessboardcorners function doesn't work properly on my images Aug 20, 2024 Replies 2 Views 2K Python",
    "source_url": "https://www.physicsforums.com/forums/programming-and-computer-science.165/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:25:42.210499",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:25:42.211103",
        "weights": {
          "static": 0.896,
          "dynamic": 0.104
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:25:42.211103",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748287542347_6831",
    "text": "May 16, 2024 Replies 7 Views 2K Python Most efficient way to randomly choose a word from a file with a list of words May 10, 2024 2 Replies 35 Views 5K C/C++ Parallel processing for loops and pointer defined outside the loop May 9, 2024 Replies 14 Views 2K JavaScript Links from navbar made with React don't work May 6, 2024 Replies 2 Views 2K Fortran Passing variables in FORTRAN May 2, 2024 Replies 25 Views 3K Classifiers, threshold, and ROC curve Apr 30, 2024 Replies 5 Views 2K My Website For Creating Interactive Visuals Linked To Equations Apr 19, 2024 Replies 4 Views 2K JavaScript Error logging in: onLoginSuccess is not a function Apr 18, 2024 Replies 8 Views 2K Python Building a homemade Long Short Term Memory with FSMs Apr 7, 2024 Replies 2 Views 2K Git, staging and committing files Mar 31, 2024 Replies 20 Views 3K HTML/CSS Is it possible to use js variables in html while using Puppeteer? Mar 27, 2024 Replies 5 Views 2K How do I make Browserify work with Puppeteer?",
    "source_url": "https://www.physicsforums.com/forums/programming-and-computer-science.165/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:25:42.347921",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:25:42.347921",
        "weights": {
          "static": 0.896,
          "dynamic": 0.104
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:25:42.347921",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748287542387_6518",
    "text": "Mar 27, 2024 Replies 5 Views 2K How do I make Browserify work with Puppeteer? Mar 25, 2024 Replies 1 Views 2K Python Query runs fine in MySQL, but returns empty list in Python Mar 12, 2024 Replies 7 Views 3K Python Python scipy.optimize.minimize: ‘trust-constr’ and Hessian output Mar 12, 2024 Replies 5 Views 2K How to install Cheerio in Visual Studio Code v 1.87.1 Mar 9, 2024 Replies 2 Views 2K C/C++ Cpp in visual studio: cmake and being able to compile Mar 9, 2024 Replies 0 Views 2K F(x) row isn't shown in origin software Mar 3, 2024 Replies 3 Views 2K Iterators and generators and the data they generate Mar 1, 2024 Replies 1 Views 2K JavaScript How do I run an exe file on an Apple iPad? Feb 27, 2024 Replies 6 Views 4K Python Best way to fix \"externally managed environment\" error? Feb 26, 2024 Replies 1 Views 6K My app has a generic Android icon when I download it from Google Play Feb 25, 2024 Replies 10 Views 5K [Godot] Can I directly access files saved on Android to user:// ?",
    "source_url": "https://www.physicsforums.com/forums/programming-and-computer-science.165/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:25:42.387932",
    "symbols_found_in_chunk": 2,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:25:42.388925",
        "weights": {
          "static": 0.896,
          "dynamic": 0.104
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:25:42.388925",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748287542413_9501",
    "text": "Feb 21, 2024 Replies 3 Views 2K Python Docker containers in Windows \"look\" like VMs... Feb 15, 2024 Replies 4 Views 2K Python Stop current Python REPL command, but keep REPL session open? Feb 12, 2024 Replies 1 Views 2K Why do many applications come with their own terminal instead of using the native shell? Feb 11, 2024 Replies 3 Views 2K Docker and Containers:",
    "source_url": "https://www.physicsforums.com/forums/programming-and-computer-science.165/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T19:25:42.413241",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T19:25:42.413241",
        "weights": {
          "static": 0.896,
          "dynamic": 0.104
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T19:25:42.413241",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748289664533_3583",
    "text": "Good point. Baluncore said: But this thread is about the proof of the number of \"multiplies\" required for an FFT. Good point again: I should have read from the top! Albert01 14 0 I initially determined the number of Butterflies constructively, using the number of levels and the knowledge that ##N/2## butterflies are required in each level. .Scott said: The proof is fairly simple. Multiplications occur in the butterfly modules and in the preparation of the qk factors - but those qk factors can be prepared at \"compile time\". Only the butterfly multiplies are executed at run time. When N=1, the number of multiplies is zero. Each time you double N=2∗(N−1), you perform two \"N/2\" FFTs and then N/2 butterflies. This is the inductive proof? Not more? Last edited: Apr 19, 2024 Albert01 14 0 A suggestion for proof via induction from me. Please correct me if you find any mistakes! A confirmation would be nice!",
    "source_url": "https://www.physicsforums.com/threads/number-of-multiplications-in-the-fft-algorithm.1060665/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-05-26T20:01:04.533096",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-05-26T20:01:04.533096",
        "weights": {
          "static": 0.896,
          "dynamic": 0.104
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-05-26T20:01:04.533096",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748826118074_8078",
    "text": "May 16, 2024 Replies 7 Views 2K Python Most efficient way to randomly choose a word from a file with a list of words May 10, 2024 2 Replies 35 Views 5K C/C++ Parallel processing for loops and pointer defined outside the loop May 9, 2024 Replies 14 Views 2K JavaScript Links from navbar made with React don't work May 6, 2024 Replies 2 Views 2K Fortran Passing variables in FORTRAN May 2, 2024 Replies 25 Views 3K Classifiers, threshold, and ROC curve Apr 30, 2024 Replies 5 Views 2K My Website For Creating Interactive Visuals Linked To Equations Apr 19, 2024 Replies 4 Views 2K JavaScript Error logging in: onLoginSuccess is not a function Apr 18, 2024 Replies 8 Views 2K Python Building a homemade Long Short Term Memory with FSMs Apr 7, 2024 Replies 2 Views 2K Git, staging and committing files Mar 31, 2024 Replies 20 Views 3K HTML/CSS Is it possible to use js variables in html while using Puppeteer? Mar 27, 2024 Replies 5 Views 2K How do I make Browserify work with Puppeteer?",
    "source_url": "https://www.physicsforums.com/forums/programming-and-computer-science.165/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-02T01:01:58.074722",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-02T01:01:58.074722",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-02T01:01:58.074722",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748826118106_3570",
    "text": "Mar 27, 2024 Replies 5 Views 2K How do I make Browserify work with Puppeteer? Mar 25, 2024 Replies 1 Views 2K Python Query runs fine in MySQL, but returns empty list in Python Mar 12, 2024 Replies 7 Views 3K Python Python scipy.optimize.minimize: ‘trust-constr’ and Hessian output Mar 12, 2024 Replies 5 Views 2K How to install Cheerio in Visual Studio Code v 1.87.1 Mar 9, 2024 Replies 2 Views 2K C/C++ Cpp in visual studio: cmake and being able to compile Mar 9, 2024 Replies 0 Views 2K F(x) row isn't shown in origin software Mar 3, 2024 Replies 3 Views 2K Iterators and generators and the data they generate Mar 1, 2024 Replies 1 Views 2K JavaScript How do I run an exe file on an Apple iPad? Feb 27, 2024 Replies 6 Views 4K Python Best way to fix \"externally managed environment\" error? Feb 26, 2024 Replies 1 Views 6K My app has a generic Android icon when I download it from Google Play Feb 25, 2024 Replies 10 Views 5K [Godot] Can I directly access files saved on Android to user:// ?",
    "source_url": "https://www.physicsforums.com/forums/programming-and-computer-science.165/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-02T01:01:58.106141",
    "symbols_found_in_chunk": 2,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-02T01:01:58.106141",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-02T01:01:58.106141",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748826118121_7821",
    "text": "Feb 21, 2024 Replies 3 Views 2K Python Docker containers in Windows \"look\" like VMs... Feb 15, 2024 Replies 4 Views 2K Python Stop current Python REPL command, but keep REPL session open? Feb 12, 2024 Replies 1 Views 2K Why do many applications come with their own terminal instead of using the native shell? Feb 11, 2024 Replies 3 Views 2K Docker and Containers:",
    "source_url": "https://www.physicsforums.com/forums/programming-and-computer-science.165/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-02T01:01:58.121141",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-02T01:01:58.121141",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-02T01:01:58.121141",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748826118150_9159",
    "text": "Feb 11, 2024 Replies 3 Views 2K Docker and Containers: Understanding the Basics and Common Doubts Explained Feb 11, 2024 Replies 6 Views 2K Bash shell via Git Bash or WSL in Windows Feb 8, 2024 Replies 1 Views 3K Python How to store a large data-set in a \"grid\" in Python/NumPy Feb 6, 2024 Replies 14 Views 3K Java When an Athlete Throws His Javalin A Meter Too Far Feb 5, 2024 Replies 2 Views 2K C/C++ Interpolation of a rapidly oscillating function Feb 5, 2024 Replies 3 Views 2K Windows OS: Administrator status vs regular user Feb 4, 2024 Replies 5 Views 2K Confusion On Frontend vs. Backend for Web Developement Feb 3, 2024 Replies 13 Views 3K Can globals in Godot randomly fail to update? Feb 1, 2024 Replies 4 Views 2K Problems installing the TMDlib package Jan 31, 2024 Replies 1 Views 2K DeepMind AlphaGeometry: Is AGI just around the corner? Jan 31, 2024 Replies 9 Views 2K C/C++",
    "source_url": "https://www.physicsforums.com/forums/programming-and-computer-science.165/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-02T01:01:58.150801",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-02T01:01:58.150801",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-02T01:01:58.150801",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748826144986_4130",
    "text": "FallArk 127 0 Update: I figured out how to make the output an integer. By doing this: Code: def eval_infix_sum(expr,pos):\n    if expr[pos+1] == '+' :\n        ans = int(expr[pos]) + int(expr[pos+2])\n    elif expr[pos+1] == '-' :\n        ans = int(expr[pos]) - int(expr[pos+2])\n    pos = pos + 1\n    return ans,pos But I am still confused about how the \"pos\" will correspond with the other functions. I know after finishing the code, the function \"eval_infix\" should be able to call the related functions and get the output, but I don't really understand it clearly I like Serena Homework Helper MHB 16,335 258 Hey FallArk! ;) Suppose we want to evalute [1,\"+\",2,\"+\",3]. Then after calling eval_sum_infix, we will have evaluated \"1+2\", leaving \"+3\". We can call eval_sum_infix again, but then we should continue at pos=3... FallArk 127 0 I like Serena said: Hey FallArk! ;) Suppose we want to evalute [1,\"+\",2,\"+\",3]. Then after calling eval_sum_infix, we will have evaluated \"1+2\", leaving \"+3\".",
    "source_url": "https://www.physicsforums.com/threads/help-with-python-implementing-algorithm.1035553/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-02T01:02:24.986890",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-02T01:02:24.986890",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-02T01:02:24.986890",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748826145080_8989",
    "text": "FallArk 127 0 My code so far: Code: def eval_infix_sum(expr,pos):\n    while expr[pos] ! = ';':\n        if expr[pos+1] == '+' :\n            ans = int(expr[pos]) + int(expr[pos+2])\n        elif expr[pos+1] == '-' :\n            ans = int(expr[pos]) - int(expr[pos+2])\n        pos = pos + 1\n    return ans,pos\ndef eval_infix_product(expr,pos): while expr[pos] != ';':\n        if expr[pos+1] == '*' :\n            ans = int(expr[pos]) * int(expr[pos+2])\n        elif expr[pos+1] == '/' :\n            ans = int(expr[pos]) / int(expr[pos+2])\n        pos = pos + 1\n    return ans,pos Inputs like : Code: [\"1\",\"+\",\"2\",\"-3\",\";\"],0 works out just fine. Thanks for the comments, so inside the \"eval_infix_factor\" function, I should do something so that the \"(\" token can be dealt with then? I like Serena Homework Helper MHB 16,335 258 FallArk said: My code so far: Code: def eval_infix_sum(expr,pos):\n    while expr[pos] !",
    "source_url": "https://www.physicsforums.com/threads/help-with-python-implementing-algorithm.1035553/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-02T01:02:25.080306",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-02T01:02:25.080306",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-02T01:02:25.080306",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748826145113_1191",
    "text": "FallArk said: My code so far: Code: def eval_infix_sum(expr,pos):\n    while expr[pos] ! = ';':\n        if expr[pos+1] == '+' :\n            ans = int(expr[pos]) + int(expr[pos+2])\n        elif expr[pos+1] == '-' :\n            ans = int(expr[pos]) - int(expr[pos+2])\n        pos = pos + 1\n    return ans,pos\ndef eval_infix_product(expr,pos): while expr[pos] != ';':\n        if expr[pos+1] == '*' :\n            ans = int(expr[pos]) * int(expr[pos+2])\n        elif expr[pos+1] == '/' :\n            ans = int(expr[pos]) / int(expr[pos+2])\n        pos = pos + 1\n    return ans,pos Inputs like : Code: [\"1\",\"+\",\"2\",\"-3\",\";\"],0 works out just fine. Thanks for the comments, so inside the \"eval_infix_factor\" function, I should do something so that the \"(\" token can be dealt with then? What we have is sum-expressions that consist of multiplicative-expressions that consist of either constants or parenthesized expressions. In pseudo code it's something like this. (\"rhs\" is short for right hand side .)",
    "source_url": "https://www.physicsforums.com/threads/help-with-python-implementing-algorithm.1035553/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-02T01:02:25.113836",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-02T01:02:25.113836",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-02T01:02:25.113836",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748826145142_9311",
    "text": "In pseudo code it's something like this. (\"rhs\" is short for right hand side .) Code: def sum_expr\n    result = mul_expr\n    while next token == \"+\"\n        rhs = mul_expr\n        result += rhs\n    return result\n\ndef mul_expr\n    result = factor_expr\n    while next token == \"*\"\n        rhs =factor_expr\n        result *= rhs\n    return result\n\ndef factor_expr\n    if next token == \"(\"\n        result = sum_expr\n        skip following \")\"\n    else\n        result = constant\n    return result All the parameters, and tracking of the position still have to be added. FallArk 127 0 duh, I just realized that if input like \" '2 + 3' \" is entered, the function \"eval_infix\" will split it up into a list with semicolon and then call function \"eval_infix_list\" which will call \"eval_infix_sum\". :D I will talk to my instructor today and also ask him about it again. Thank you!",
    "source_url": "https://www.physicsforums.com/threads/help-with-python-implementing-algorithm.1035553/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-02T01:02:25.142052",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-02T01:02:25.142052",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-02T01:02:25.142052",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748826147893_9960",
    "text": "do you have a link to Marletto's proof HrvojeDjurdjevic 23 4 Here you are https://royalsocietypublishing.org/doi/10.1098/rsif.2014.1226#d3e2524 tade 720 26 HrvojeDjurdjevic said: Here you are https://royalsocietypublishing.org/doi/10.1098/rsif.2014.1226#d3e2524 thanks, and which part of it describes her proof that the second model is the only possible accurate way pbuk Science Advisor Homework Helper Gold Member 4,947 3,191 HrvojeDjurdjevic said: How sound and rigorous is her proof? It seems tautological to me: \"we define a replicator as something that replicates, therefore in order for something to replicate itself it must contain a replicator\". HrvojeDjurdjevic said: Would you be able to prove the same without looking at her proof? Yes, unless I am wrong in believing it to be vacuously true. HrvojeDjurdjevic said: Can you point to the relevant source that contains already performed and published proofreading of that text?",
    "source_url": "https://www.physicsforums.com/threads/von-neumann-replicator-vehicle-model.1056248/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-02T01:02:27.893860",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-02T01:02:27.893860",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-02T01:02:27.893860",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748826153330_1254",
    "text": "Each node keeps track of how many higher children it has. You start with a root node containing 5. Then you add 2 as the \"lower child\" of 5, then 3 as the \"higher child\" of 2 (because it's lower than 5, but 5 already has a lower child but 2 doesn't have a higher child), then 1 as the \"lower child\" of 2 (5 already has a lower child but 2 doesn't), then 4 as the \"higher child\" of 3 (5 has a lower child, 2 has a higher child, but 3 doesn't). If you keep track of how many child nodes have been added on the higher subtree of each one, I think you can work out how many higher numbers you've already seen without having to check every one, which ought to be better than ##O(n^2)##. Last edited: Oct 12, 2019 Ibix Science Advisor Insights Author 13,111 15,409 Python: class TreeNode:\n    def __init__(self,v):\n        self.v=v # A number from the original list\n        self.nGreater=0 # The number of higher numbers we've seen.",
    "source_url": "https://www.physicsforums.com/threads/permutation-counting-algorithm-for-large-integers.978830/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-02T01:02:33.330246",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-02T01:02:33.331246",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-02T01:02:33.331246",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748826153348_4067",
    "text": "The number of higher numbers we've seen. self.lowerChild=None\n        self.greaterChild=None\n    def addNode(self,newV):\n        if newV<self.v:\n            if self.lowerChild is None:\n                # New number is lower than this node and we have not seen any such numbers before. Return 1 (this node) plus how many greater-than-this-node children\n                self.lowerChild=TreeNode(newV)\n                return 1+self.nGreater\n            else:\n                # New number is lower than this node.",
    "source_url": "https://www.physicsforums.com/threads/permutation-counting-algorithm-for-large-integers.978830/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-02T01:02:33.348133",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-02T01:02:33.348133",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-02T01:02:33.348133",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748826153368_8636",
    "text": "New number is lower than this node. Return 1 (this node) plus how many greater-than-this-node children plus anything between the new node and this node\n                return 1+self.nGreater+self.lowerChild.addNode(newV)\n        else:\n            self.nGreater+=1\n            if self.greaterChild is None:\n                # Greater than this node and we haven't seen such a number before - return that there are no larger numbers below this node\n                self.greaterChild=TreeNode(newV)\n                return 0\n            else:\n                # Greater than this node - return how many greater-than-the-new-node values are found in the subtree\n                return self.greaterChild.addNode(newV)",
    "source_url": "https://www.physicsforums.com/threads/permutation-counting-algorithm-for-large-integers.978830/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-02T01:02:33.368133",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-02T01:02:33.368133",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-02T01:02:33.368133",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1748826153396_3470",
    "text": "def printTree(self):\n        chstr=\"\"\n        if self.lowerChild is None:\n            chstr+=\"-\"\n        else:\n            chstr+=str(self.lowerChild.v)\n        if self.greaterChild is None:\n            chstr+=\" -\"\n        else:\n            chstr+=\" \"+str(self.greaterChild.v)\n        print \"Node:\",self.v,\" Children:\",chstr\n        if self.lowerChild is not None:\n            self.lowerChild.printTree()\n        if self.greaterChild is not None:\n            self.greaterChild.printTree()\n\na=[5,2,3,1,4]\nrootNode=TreeNode(a[0])\nb=[0]\nfor a_i in a[1:]:\n    b.append(rootNode.addNode(a_i))\nprint b\nrootNode.printTree() This has not been extensively tested, and was put together in half an hour on a tiny phone. No guarantees it's right! Last edited: Oct 13, 2019 DrDu Science Advisor 6,404 1,002 Thank you Ibix! In the meanwhile, I figured out how to do this using mergesort: 1. Initialize the vector b to n times 0.",
    "source_url": "https://www.physicsforums.com/threads/permutation-counting-algorithm-for-large-integers.978830/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-02T01:02:33.396133",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-02T01:02:33.396133",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-02T01:02:33.396133",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mathematics_1_1749012125359_1584",
    "text": "Number theory This is the Ulam spiral , which illustrates the distribution of prime numbers . The dark diagonal lines in the spiral hint at the hypothesized approximate independence between being prime and being a value of a quadratic polynomial, a conjecture now known as Hardy and Littlewood's Conjecture F . Number theory began with the manipulation of numbers , that is, natural numbers ( N ) , {\\displaystyle (\\mathbb {N} ),} and later expanded to integers ( Z ) {\\displaystyle (\\mathbb {Z} )} and rational numbers ( Q ) . {\\displaystyle (\\mathbb {Q} ).} Number theory was once called arithmetic, but nowadays this term is mostly used for numerical calculations . [ 15 ] Number theory dates back to ancient Babylon and probably China . Two prominent early number theorists were Euclid of ancient Greece and Diophantus of Alexandria. [ 16 ] The modern study of number theory in its abstract form is largely attributed to Pierre de Fermat and Leonhard Euler .",
    "source_url": "https://en.wikipedia.org/wiki/Mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:05.359818",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:05.359818",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:05.359818",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mathematics_1_1749012125387_3061",
    "text": "[ 14 ] Geometry Main article: Geometry On the surface of a sphere, Euclidean geometry only applies as a local approximation. For larger scales the sum of the angles of a triangle is not equal to 180°. Geometry is one of the oldest branches of mathematics. It started with empirical recipes concerning shapes, such as lines , angles and circles , which were developed mainly for the needs of surveying and architecture , but has since blossomed out into many other subfields. [ 20 ] A fundamental innovation was the ancient Greeks' introduction of the concept of proofs , which require that every assertion must be proved . For example, it is not sufficient to verify by measurement that, say, two lengths are equal; their equality must be proven via reasoning from previously accepted results ( theorems ) and a few basic statements. The basic statements are not subject to proof because they are self-evident ( postulates ), or are part of the definition of the subject of study ( axioms ).",
    "source_url": "https://en.wikipedia.org/wiki/Mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:05.387514",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:05.387514",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:05.387514",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mathematics_1_1749012125438_4104",
    "text": "Manifold theory , the study of shapes that are not necessarily embedded in a larger space. Riemannian geometry , the study of distance properties in curved spaces. Algebraic geometry , the study of curves, surfaces, and their generalizations, which are defined using polynomials . Topology , the study of properties that are kept under continuous deformations . Algebraic topology , the use in topology of algebraic methods, mainly homological algebra . Discrete geometry , the study of finite configurations in geometry. Convex geometry , the study of convex sets , which takes its importance from its applications in optimization . Complex geometry , the geometry obtained by replacing real numbers with complex numbers . Algebra Main article: Algebra The quadratic formula , which concisely expresses the solutions of all quadratic equations The Rubik's Cube group is a concrete application of group theory . [ 26 ] Algebra is the art of manipulating equations and formulas.",
    "source_url": "https://en.wikipedia.org/wiki/Mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:05.438590",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:05.438590",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:05.438590",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mathematics_1_1749012125465_8167",
    "text": "[ 34 ] Until the 19th century, algebra consisted mainly of the study of linear equations (presently linear algebra ), and polynomial equations in a single unknown , which were called algebraic equations (a term still in use, although it may be ambiguous). During the 19th century, mathematicians began to use variables to represent things other than numbers (such as matrices , modular integers , and geometric transformations ), on which generalizations of arithmetic operations are often valid. [ 35 ] The concept of algebraic structure addresses this, consisting of a set whose elements are unspecified, of operations acting on the elements of the set, and rules that these operations must follow. The scope of algebra thus grew to include the study of algebraic structures. This object of algebra was called modern algebra or abstract algebra , as established by the influence and works of Emmy Noether , [ 36 ] and popularized by Van der Waerden 's book Moderne Algebra .",
    "source_url": "https://en.wikipedia.org/wiki/Mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:05.465791",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:05.465791",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:05.465791",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mathematics_1_1749012125490_2637",
    "text": "[ 37 ] The latter applies to every mathematical structure (not only algebraic ones). At its origin, it was introduced, together with homological algebra for allowing the algebraic study of non-algebraic objects such as topological spaces ; this particular area of application is called algebraic topology . [ 38 ] Calculus and analysis Main articles: Calculus and Mathematical analysis A Cauchy sequence consists of elements such that all subsequent terms of a term become arbitrarily close to each other as the sequence progresses (from left to right). Calculus, formerly called infinitesimal calculus, was introduced independently and simultaneously by 17th-century mathematicians Newton and Leibniz . [ 39 ] It is fundamentally the study of the relationship of variables that depend on each other. Calculus was expanded in the 18th century by Euler with the introduction of the concept of a function and many other results.",
    "source_url": "https://en.wikipedia.org/wiki/Mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:05.490817",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:05.490817",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:05.490817",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mathematics_1_1749012125555_7010",
    "text": "[ 46 ] [ 47 ] Before this period, sets were not considered to be mathematical objects, and logic , although used for mathematical proofs, belonged to philosophy and was not specifically studied by mathematicians. [ 48 ] Before Cantor 's study of infinite sets , mathematicians were reluctant to consider actually infinite collections, and considered infinity to be the result of endless enumeration . Cantor's work offended many mathematicians not only by considering actually infinite sets [ 49 ] but by showing that this implies different sizes of infinity, per Cantor's diagonal argument . This led to the controversy over Cantor's set theory . [ 50 ] In the same period, various areas of mathematics concluded the former intuitive definitions of the basic mathematical objects were insufficient for ensuring mathematical rigour . [ 51 ] This became the foundational crisis of mathematics.",
    "source_url": "https://en.wikipedia.org/wiki/Mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:05.555598",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:05.555598",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:05.555598",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Number_theory_1_1749012130017_3512",
    "text": "Number theorists study prime numbers as well as the properties of mathematical objects constructed from integers (for example, rational numbers ), or defined as generalizations of the integers (for example, algebraic integers ). [ 3 ] [ 4 ] Number theory is closely related to arithmetic and some authors use the terms as synonyms. [ 5 ] However, the word \"arithmetic\" is used today to mean the study of numerical operations and extends to the real numbers . [ 6 ] In a more specific sense, number theory is restricted to the study of integers and focuses on their properties and relationships. [ 7 ] Traditionally, it is known as higher arithmetic. [ 8 ] By the early twentieth century, the term number theory had been widely adopted. [ note 1 ] The term number means whole numbers, which refers to either the natural numbers or the integers. [ 9 ] [ 10 ] [ 11 ] Elementary number theory studies aspects of integers that can be investigated using elementary methods such as elementary proofs .",
    "source_url": "https://en.wikipedia.org/wiki/Number_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:10.018501",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:10.018501",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:10.018501",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Number_theory_1_1749012130077_6225",
    "text": "The triples are too numerous and too large to have been obtained by brute force . The heading over the first column reads: \"The takiltum of the diagonal which has been subtracted such that the width...\" [ 19 ] The table's layout suggests that it was constructed by means of what amounts, in modern language, to the identity [ 20 ] ( 1 2 ( x − 1 x ) ) 2 + 1 = ( 1 2 ( x + 1 x ) ) 2 , {\\displaystyle \\left({\\frac {1}{2}}\\left(x-{\\frac {1}{x}}\\right)\\right)^{2}+1=\\left({\\frac {1}{2}}\\left(x+{\\frac {1}{x}}\\right)\\right)^{2},} which is implicit in routine Old Babylonian exercises. If some other method was used, the triples were first constructed and then reordered by c / a {\\displaystyle c/a} , presumably for actual use as a \"table\", for example, with a view to applications. [ 21 ] It is not known what these applications may have been, or whether there could have been any; Babylonian astronomy , for example, truly came into its own many centuries later.",
    "source_url": "https://en.wikipedia.org/wiki/Number_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:10.077591",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:10.077591",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:10.077591",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Number_theory_1_1749012130103_9287",
    "text": "It has been suggested instead that the table was a source of numerical examples for school problems. [ 22 ] [ note 2 ] Plimpton 322 tablet is the only surviving evidence of what today would be called number theory within Babylonian mathematics, though a kind of Babylonian algebra was much more developed. [ 23 ] Ancient Greece [ edit ] Further information: Ancient Greek mathematics Although other civilizations probably influenced Greek mathematics at the beginning, [ 24 ] all evidence of such borrowings appear relatively late, [ 25 ] [ 26 ] and it is likely that Greek arithmētikḗ (the theoretical or philosophical study of numbers) is an indigenous tradition. Aside from a few fragments, most of what is known about Greek mathematics in the 6th to 4th centuries BC (the Archaic and Classical periods) comes through either the reports of contemporary non-mathematicians or references from mathematical works in the early Hellenistic period .",
    "source_url": "https://en.wikipedia.org/wiki/Number_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:10.103953",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:10.103953",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:10.103953",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Number_theory_1_1749012130196_1654",
    "text": "[ 34 ] [ 35 ] This forced a distinction between numbers (integers and the rationals—the subjects of arithmetic) and lengths and proportions (which may be identified with real numbers, whether rational or not). The Pythagorean tradition also spoke of so-called polygonal or figurate numbers . [ 36 ] While square numbers , cubic numbers , etc., are seen now as more natural than triangular numbers , pentagonal numbers , etc., the study of the sums of triangular and pentagonal numbers would prove fruitful in the early modern period (17th to early 19th centuries). An epigram published by Lessing in 1773 appears to be a letter sent by Archimedes to Eratosthenes . [ 37 ] [ 38 ] The epigram proposed what has become known as Archimedes's cattle problem ; its solution (absent from the manuscript) requires solving an indeterminate quadratic equation (which reduces to what would later be misnamed Pell's equation ).",
    "source_url": "https://en.wikipedia.org/wiki/Number_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:10.196794",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:10.197794",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:10.197794",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Number_theory_1_1749012130225_8407",
    "text": "As far as it is known, such equations were first successfully treated by Indian mathematicians. It is not known whether Archimedes himself had a method of solution. Late Antiquity [ edit ] Title page of Diophantus's Arithmetica , translated into Latin by Bachet (1621) Aside from the elementary work of Neopythagoreans such as Nicomachus and Theon of Smyrna , the foremost authority in arithmētikḗ in Late Antiquity was Diophantus of Alexandria , who probably lived in the 3rd century AD, approximately five hundred years after Euclid. Little is known about his life, but he wrote two works that are extant: On Polygonal Numbers , a short treatise written in the Euclidean manner on the subject, and the Arithmetica , a work on pre-modern algebra (namely, the use of algebra to solve numerical problems). Six out of the thirteen books of Diophantus's Arithmetica survive in the original Greek and four more survive in an Arabic translation.",
    "source_url": "https://en.wikipedia.org/wiki/Number_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:10.225365",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:10.225365",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:10.225365",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Geometry_1_1749012135929_5933",
    "text": "Parallelogram Square Rectangle Rhombus Rhomboid Quadrilateral Trapezoid Kite Circle Diameter Circumference Area Three-dimensional Volume Cube cuboid Cylinder Dodecahedron Icosahedron Octahedron Pyramid Platonic Solid Sphere Tetrahedron Four -/other-dimensional Tesseract Hypersphere Geometers by name Aida Aryabhata Ahmes Alhazen Apollonius Archimedes Atiyah Baudhayana Bolyai Brahmagupta Cartan Chern Coxeter Descartes Euclid Euler Gauss Gromov Hilbert Huygens Jyeṣṭhadeva Kātyāyana Khayyám Klein Lobachevsky Manava Minkowski Minggatu Pascal Pythagoras Parameshvara Poincaré Riemann Sakabe Sijzi al-Tusi Veblen Virasena Yang Hui al-Yasamin Zhang List of geometers by period BCE Ahmes Baudhayana Manava Pythagoras Euclid Archimedes Apollonius 1–1400s Zhang Kātyāyana Aryabhata Brahmagupta Virasena Alhazen Sijzi Khayyám al-Yasamin al-Tusi Yang Hui Parameshvara 1400s–1700s Jyeṣṭhadeva Descartes Pascal Huygens Minggatu Euler",
    "source_url": "https://en.wikipedia.org/wiki/Geometry",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:15.929929",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:15.929929",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:15.929929",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Geometry_1_1749012136082_7080",
    "text": "A mathematician who works in the field of geometry is called a geometer . Until the 19th century, geometry was almost exclusively devoted to Euclidean geometry , [ a ] which includes the notions of point , line , plane , distance , angle , surface , and curve , as fundamental concepts. [ 3 ] Originally developed to model the physical world, geometry has applications in almost all sciences, and also in art, architecture , and other activities that are related to graphics. [ 4 ] Geometry also has applications in areas of mathematics that are apparently unrelated. For example, methods of algebraic geometry are fundamental in Wiles's proof of Fermat's Last Theorem , a problem that was stated in terms of elementary arithmetic , and remained unsolved for several centuries. During the 19th century several discoveries enlarged dramatically the scope of geometry.",
    "source_url": "https://en.wikipedia.org/wiki/Geometry",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:16.082140",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:16.082140",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:16.082140",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Geometry_1_1749012136102_7728",
    "text": "During the 19th century several discoveries enlarged dramatically the scope of geometry. One of the oldest such discoveries is Carl Friedrich Gauss 's Theorema Egregium (\"remarkable theorem\") that asserts roughly that the Gaussian curvature of a surface is independent from any specific embedding in a Euclidean space . This implies that surfaces can be studied intrinsically , that is, as stand-alone spaces, and has been expanded into the theory of manifolds and Riemannian geometry . Later in the 19th century, it appeared that geometries without the parallel postulate ( non-Euclidean geometries ) can be developed without introducing any contradiction. The geometry that underlies general relativity is a famous application of non-Euclidean geometry.",
    "source_url": "https://en.wikipedia.org/wiki/Geometry",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:16.102833",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:16.103826",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:16.103826",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Geometry_1_1749012136220_8631",
    "text": "[ 17 ] The Elements was known to all educated people in the West until the middle of the 20th century and its contents are still taught in geometry classes today. [ 18 ] Archimedes ( c. 287–212 BC ) of Syracuse, Italy used the method of exhaustion to calculate the area under the arc of a parabola with the summation of an infinite series , and gave remarkably accurate approximations of pi . [ 19 ] He also studied the spiral bearing his name and obtained formulas for the volumes of surfaces of revolution . Woman teaching geometry . Illustration at the beginning of a medieval translation of Euclid's Elements , ( c. 1310 ). Indian mathematicians also made many important contributions in geometry. The Shatapatha Brahmana (3rd century BC) contains rules for ritual geometric constructions that are similar to the Sulba Sutras . [ 20 ]",
    "source_url": "https://en.wikipedia.org/wiki/Geometry",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:16.220587",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:16.220587",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:16.220587",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algebra_1_1749012139692_4357",
    "text": "By replacing the numbers with variables, it is possible to express a general law that applies to any possible combination of numbers, like the commutative property of multiplication , which is expressed in the equation a × b = b × a {\\displaystyle a\\times b=b\\times a} . [ 23 ] Algebraic expressions are formed by using arithmetic operations to combine variables and numbers. By convention, the lowercase letters ⁠ x {\\displaystyle x} ⁠ , ⁠ y {\\displaystyle y} ⁠ , and z {\\displaystyle z} represent variables. In some cases, subscripts are added to distinguish variables, as in ⁠ x 1 {\\displaystyle x_{1}} ⁠ , ⁠ x 2 {\\displaystyle x_{2}} ⁠ , and ⁠ x 3 {\\displaystyle x_{3}} ⁠ . The lowercase letters ⁠ a {\\displaystyle a} ⁠ , ⁠ b {\\displaystyle b} ⁠ , and c {\\displaystyle c} are usually used for constants and coefficients .",
    "source_url": "https://en.wikipedia.org/wiki/Algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:19.692779",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:19.692779",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:19.692779",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algebra_1_1749012139720_7665",
    "text": "Unlike other expressions, statements can be true or false, and their truth value usually depends on the values of the variables. For example, the statement x 2 = 4 {\\displaystyle x^{2}=4} is true if x {\\displaystyle x} is either 2 or −2 and false otherwise. [ 26 ] Equations with variables can be divided into identity equations and conditional equations. Identity equations are true for all values that can be assigned to the variables, such as the equation ⁠ 2 x + 5 x = 7 x {\\displaystyle 2x+5x=7x} ⁠ . Conditional equations are only true for some values. For example, the equation x + 4 = 9 {\\displaystyle x+4=9} is only true if x {\\displaystyle x} is 5. [ 27 ] The main goal of elementary algebra is to determine the values for which a statement is true. This can be achieved by transforming and manipulating statements according to certain rules. A key principle guiding this process is that whatever operation is applied to one side of an equation also needs to be done to the other side.",
    "source_url": "https://en.wikipedia.org/wiki/Algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:19.720530",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:19.720530",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:19.720530",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algebra_1_1749012139747_7162",
    "text": "= 4 x {\\displaystyle 7x-3x=(7-3)x=4x} by the distributive property. [ 29 ] For statements with several variables, substitution is a common technique to replace one variable with an equivalent expression that does not use this variable. For example, if one knows that y = 3 x {\\displaystyle y=3x} then one can simplify the expression 7 x y {\\displaystyle 7xy} to arrive at ⁠ 21 x 2 {\\displaystyle 21x^{2}} ⁠ . In a similar way, if one knows the value of one variable one may be able to use it to determine the value of other variables. [ 30 ] Algebraic equations can be used to describe geometric figures. All values for x {\\displaystyle x} and y {\\displaystyle y} that solve the equation are interpreted as points. They are drawn as a red, upward-sloping line in the graph above. Algebraic equations can be interpreted geometrically to describe spatial figures in the form of a graph .",
    "source_url": "https://en.wikipedia.org/wiki/Algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:19.747129",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:19.747129",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:19.747129",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Calculus_1_1749012143498_1937",
    "text": "Jump to content From Wikipedia, the free encyclopedia Branch of mathematics This article is about the branch of mathematics. For other uses, see Calculus (disambiguation) . Part of a series of articles about Calculus ∫ a b f ′ ( t )",
    "source_url": "https://en.wikipedia.org/wiki/Calculus",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:23.498891",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:23.498891",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:23.498891",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Calculus_1_1749012143521_7693",
    "text": "Part of a series of articles about Calculus ∫ a b f ′ ( t ) d t = f ( b ) − f ( a ) {\\displaystyle \\int _{a}^{b}f'(t)\\,dt=f(b)-f(a)} Fundamental theorem Limits Continuity Rolle's theorem Mean value theorem Inverse function theorem Differential Definitions Derivative ( generalizations ) Differential infinitesimal of a function total Concepts Differentiation notation Second derivative Implicit differentiation Logarithmic differentiation Related rates Taylor's theorem Rules and identities Sum Product Chain Power Quotient L'Hôpital's rule Inverse General Leibniz Faà di Bruno's formula Reynolds Integral Lists of integrals Integral transform Leibniz integral rule Definitions Antiderivative Integral ( improper ) Riemann integral Lebesgue integration Contour integration Integral of inverse functions Integration by Parts Discs Cylindrical shells Substitution ( trigonometric , tangent half-angle , Euler ) Euler's formula Partial fractions ( Heaviside's method )",
    "source_url": "https://en.wikipedia.org/wiki/Calculus",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:23.521381",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:23.521381",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:23.521381",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Calculus_1_1749012143579_8359",
    "text": "Calculus is the mathematical study of continuous change, in the same way that geometry is the study of shape, and algebra is the study of generalizations of arithmetic operations . Originally called infinitesimal calculus or \"the calculus of infinitesimals \", it has two major branches, differential calculus and integral calculus . The former concerns instantaneous rates of change , and the slopes of curves , while the latter concerns accumulation of quantities, and areas under or between curves. These two branches are related to each other by the fundamental theorem of calculus . They make use of the fundamental notions of convergence of infinite sequences and infinite series to a well-defined limit . [ 1 ] It is the \"mathematical backbone\" for dealing with problems where variables change with time or another reference variable. [ 2 ] Infinitesimal calculus was formulated separately in the late 17th century by Isaac Newton and Gottfried Wilhelm Leibniz .",
    "source_url": "https://en.wikipedia.org/wiki/Calculus",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:23.579654",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:23.579654",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:23.579654",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Calculus_1_1749012143656_8640",
    "text": "Ancient precursors Egypt Calculations of volume and area , one goal of integral calculus, can be found in the Egyptian Moscow papyrus ( c. 1820 BC ), but the formulae are simple instructions, with no indication as to how they were obtained. [ 9 ] [ 10 ] Greece See also: Greek mathematics Archimedes used the method of exhaustion to calculate the area under a parabola in his work Quadrature of the Parabola . Laying the foundations for integral calculus and foreshadowing the concept of the limit, ancient Greek mathematician Eudoxus of Cnidus ( c. 390–337 BC ) developed  the method of exhaustion to prove the formulas for cone and pyramid volumes. During the Hellenistic period , this method was further developed by Archimedes ( c. 287 – c. 212 BC), who combined it with a concept of the indivisibles —a precursor to infinitesimals —allowing him to solve several problems now treated by integral calculus.",
    "source_url": "https://en.wikipedia.org/wiki/Calculus",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:23.656070",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:23.656070",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:23.656070",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Calculus_1_1749012143682_8377",
    "text": "In The Method of Mechanical Theorems he describes, for example, calculating the center of gravity of a solid hemisphere , the center of gravity of a frustum of a circular paraboloid , and the area of a region bounded by a parabola and one of its secant lines . [ 11 ] China The method of exhaustion was later discovered independently in China by Liu Hui in the 3rd century AD to find the area of a circle. [ 12 ] [ 13 ] In the 5th century AD, Zu Gengzhi , son of Zu Chongzhi , established a method [ 14 ] [ 15 ] that would later be called Cavalieri's principle to find the volume of a sphere . Medieval Ibn al-Haytham , 11th-century Arab mathematician and physicist Indian mathematician and astronomer Bhāskara II Middle East In the Middle East, Hasan Ibn al-Haytham , Latinized as Alhazen ( c. 965 – c. 1040 AD) derived a formula for the sum of fourth powers .",
    "source_url": "https://en.wikipedia.org/wiki/Calculus",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:23.682602",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:23.682602",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:23.682602",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Risch_algorithm_1_1749012144342_7646",
    "text": "Jump to content From Wikipedia, the free encyclopedia Method for evaluating indefinite integrals Part of a series of articles about Calculus ∫ a b f ′ ( t ) d t = f ( b ) − f ( a ) {\\displaystyle \\int _{a}^{b}f'(t)\\,dt=f(b)-f(a)} Fundamental theorem Limits Continuity Rolle's theorem Mean value theorem Inverse function theorem Differential Definitions Derivative ( generalizations ) Differential infinitesimal of a function total Concepts Differentiation notation Second derivative Implicit differen",
    "source_url": "https://en.wikipedia.org/wiki/Risch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:24.342404",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:24.342404",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:24.342404",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mathematical_logic_1_1749012148522_7936",
    "text": "The modern (ε, δ)-definition of limit and continuous functions was already developed by Bolzano in 1817, [ 16 ] but remained relatively unknown. Cauchy in 1821 defined continuity in terms of infinitesimals (see Cours d'Analyse, page 34). In 1858, Dedekind proposed a definition of the real numbers in terms of Dedekind cuts of rational numbers, a definition still employed in contemporary texts. [ 17 ] Georg Cantor developed the fundamental concepts of infinite set theory. His early results developed the theory of cardinality and proved that the reals and the natural numbers have different cardinalities. [ 18 ] Over the next twenty years, Cantor developed a theory of transfinite numbers in a series of publications. In 1891, he published a new proof of the uncountability of the real numbers that introduced the diagonal argument , and used this method to prove Cantor's theorem that no set can have the same cardinality as its powerset .",
    "source_url": "https://en.wikipedia.org/wiki/Mathematical_logic",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:28.522445",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:28.522445",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:28.522445",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Applied_mathematics_1_1749012153740_4721",
    "text": "There is no consensus as to what the various branches of applied mathematics are. Such categorizations are made difficult by the way mathematics and science change over time, and also by the way universities organize departments, courses, and degrees. Many mathematicians distinguish between \"applied mathematics\", which is concerned with mathematical methods, and the \"applications of mathematics\" within science and engineering. A biologist using a population model and applying known mathematics would not be doing applied mathematics, but rather using it; however, mathematical biologists have posed problems that have stimulated the growth of pure mathematics. Mathematicians such as Poincaré and Arnold deny the existence of \"applied mathematics\" and claim that there are only \"applications of mathematics.\" Similarly, non-mathematicians blend applied mathematics and applications of mathematics.",
    "source_url": "https://en.wikipedia.org/wiki/Applied_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:33.740644",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:33.740644",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:33.740644",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Applied_mathematics_1_1749012153785_4546",
    "text": "[ 3 ] Mathematicians often distinguish between \"applied mathematics\" on the one hand, and the \"applications of mathematics\" or \"applicable mathematics\" both within and outside of science and engineering, on the other. [ 3 ] Some mathematicians emphasize the term applicable mathematics to separate or delineate the traditional applied areas from new applications arising from fields that were previously seen as pure mathematics. [ 4 ] For example, from this viewpoint, an ecologist or geographer using population models and applying known mathematics would not be doing applied, but rather applicable, mathematics. Even fields such as number theory that are part of pure mathematics are now important in applications (such as cryptography ), though they are not generally considered to be part of the field of applied mathematics per se .",
    "source_url": "https://en.wikipedia.org/wiki/Applied_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:33.785376",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:33.785376",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:33.785376",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Applied_mathematics_1_1749012153808_9028",
    "text": "Such descriptions can lead to applicable mathematics being seen as a collection of mathematical methods such as real analysis , linear algebra , mathematical modelling , optimisation , combinatorics , probability and statistics , which are useful in areas outside traditional mathematics and not specific to mathematical physics . Other authors prefer describing applicable mathematics as a union of \"new\" mathematical applications with the traditional fields of applied mathematics. [ 4 ] [ 5 ] [ 6 ] With this outlook, the terms applied mathematics and applicable mathematics are thus interchangeable. Utility [ edit ] Mathematical finance is concerned with the modelling of financial markets. Historically, mathematics was most important in the natural sciences and engineering . However, since World War II , fields outside the physical sciences have spawned the creation of new areas of mathematics, such as game theory and social choice theory , which grew out of economic considerations.",
    "source_url": "https://en.wikipedia.org/wiki/Applied_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:33.808392",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:33.808392",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:33.808392",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Applied_mathematics_1_1749012153855_4438",
    "text": "It is very common for Statistics departments to be separated at schools with graduate programs, but many undergraduate-only institutions include statistics under the mathematics department. Many applied mathematics programs (as opposed to departments) consist primarily of cross-listed courses and jointly appointed faculty in departments representing applications. Some Ph.D. programs in applied mathematics require little or no coursework outside mathematics, while others require substantial coursework in a specific area of application. In some respects this difference reflects the distinction between \"application of mathematics\" and \"applied mathematics\". Some universities in the U.K . host departments of Applied Mathematics and Theoretical Physics , [ 15 ] [ 16 ] [ 17 ] but it is now much less common to have separate departments of pure and applied mathematics.",
    "source_url": "https://en.wikipedia.org/wiki/Applied_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:33.855915",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:33.855915",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:33.855915",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pure_mathematics_1_1749012156353_1005",
    "text": "This may be done without focusing on concrete applications of concepts in the physical world. Pure mathematics is the study of mathematical concepts independently of any application outside mathematics . These concepts may originate in real-world concerns, and the results obtained may later turn out to be useful for practical applications, but pure mathematicians are not primarily motivated by such applications. Instead, the appeal is attributed to the intellectual challenge and aesthetic beauty of working out the logical consequences of basic principles. While pure mathematics has existed as an activity since at least ancient Greece , the concept was elaborated upon around the year 1900, [ 2 ] after the introduction of theories with counter-intuitive properties (such as non-Euclidean geometries and Cantor's theory of infinite sets), and the discovery of apparent paradoxes (such as continuous functions that are nowhere differentiable , and Russell's paradox ).",
    "source_url": "https://en.wikipedia.org/wiki/Pure_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:36.353106",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:36.353106",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:36.353106",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pure_mathematics_1_1749012156427_6078",
    "text": "[ 5 ] In this wise Euclid of Alexandria , when asked by one of his students of what use was the study of geometry, asked his slave to give the student threepence, \"since he must make gain of what he learns.\" [ 6 ] The Greek mathematician Apollonius of Perga , asked about the usefulness of some of his theorems in Book IV of Conics ,   asserted that [ 7 ] They are worthy of acceptance for the sake of the demonstrations themselves, in the same way as we accept many other things in mathematics for this and for no other reason. And since many of his results were not applicable to the science or engineering of his day, Apollonius further argued in the preface of the fifth book of Conics that the subject is one of those that \"...seem worthy of study for their own sake.\" [ 7 ] 19th century [ edit ] The term itself is enshrined in the full title of the Sadleirian Chair , \"Sadleirian Professor of Pure Mathematics\", founded (as a professorship) in the mid-nineteenth century.",
    "source_url": "https://en.wikipedia.org/wiki/Pure_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:36.427646",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:36.427646",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:36.427646",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pure_mathematics_1_1749012156452_3958",
    "text": "The idea of a separate discipline of pure mathematics may have emerged at that time. The generation of Gauss made no sweeping distinction of the kind between pure and applied . In the following years, specialisation and professionalisation (particularly in the Weierstrass approach to mathematical analysis ) started to make a rift more apparent. 20th century [ edit ] At the start of the twentieth century mathematicians took up the axiomatic method , strongly influenced by David Hilbert 's example. The logical formulation of pure mathematics suggested by Bertrand Russell in terms of a quantifier structure of propositions seemed more and more plausible, as large parts of mathematics became axiomatised and thus subject to the simple criteria of rigorous proof . Pure mathematics, according to a view that can be ascribed to the Bourbaki group , is what is proved. \"Pure mathematician\" became a recognized vocation, achievable through training.",
    "source_url": "https://en.wikipedia.org/wiki/Pure_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:36.452162",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:36.452162",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:36.452162",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pure_mathematics_1_1749012156473_2200",
    "text": "\"Pure mathematician\" became a recognized vocation, achievable through training. That said, the case has been made pure mathematics is useful in engineering education : [ 8 ] There is a training in habits of thought, points of view, and intellectual comprehension of ordinary engineering problems, which only the study of higher mathematics can give. Generality and abstraction [ edit ] An illustration of the Banach–Tarski paradox , a famous result in pure mathematics. Although it is proven that it is possible to convert one sphere into two using nothing but cuts and rotations, the transformation involves objects that cannot exist in the physical world. One central concept in pure mathematics is the idea of generality; pure mathematics often exhibits a trend towards increased generality.",
    "source_url": "https://en.wikipedia.org/wiki/Pure_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:36.473539",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:36.473539",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:36.473539",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pure_mathematics_1_1749012156494_5367",
    "text": "Uses and advantages of generality include the following: Generalizing theorems or mathematical structures can lead to deeper understanding of the original theorems or structures Generality can simplify the presentation of material, resulting in shorter proofs or arguments that are easier to follow. One can use generality to avoid duplication of effort, proving a general result instead of having to prove separate cases independently, or using results from other areas of mathematics. Generality can facilitate connections between different branches of mathematics. Category theory is one area of mathematics dedicated to exploring this commonality of structure as it plays out in some areas of math. Generality's impact on intuition is both dependent on the subject and a matter of personal preference or learning style.",
    "source_url": "https://en.wikipedia.org/wiki/Pure_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:36.494548",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:36.495552",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:36.495552",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pure_mathematics_1_1749012156520_8518",
    "text": "Often generality is seen as a hindrance to intuition, although it can certainly function as an aid to it, especially when it provides analogies to material for which one already has good intuition. As a prime example of generality, the Erlangen program involved an expansion of geometry to accommodate non-Euclidean geometries as well as the field of topology , and other forms of geometry, by viewing geometry as the study of a space together with a group of transformations. The study of numbers , called algebra at the beginning undergraduate level, extends to abstract algebra at a more advanced level; and the study of functions , called calculus at the college freshman level becomes mathematical analysis and functional analysis at a more advanced level. Each of these branches of more abstract mathematics have many sub-specialties, and there are in fact many connections between pure mathematics and applied mathematics disciplines. A steep rise in abstraction was seen mid 20th century.",
    "source_url": "https://en.wikipedia.org/wiki/Pure_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:36.520151",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:36.520151",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:36.520151",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pure_mathematics_1_1749012156542_5667",
    "text": "A steep rise in abstraction was seen mid 20th century. In practice, however, these developments led to a sharp divergence from physics , particularly from 1950 to 1983. Later this was criticised, for example by Vladimir Arnold , as too much Hilbert , not enough Poincaré . The point does not yet seem to be settled: string theory pulls one way towards abstraction, while discrete mathematics pulls back towards proof as central. Pure vis- applied mathematics [ edit ] Mathematicians have always had differing opinions regarding the distinction between pure and applied mathematics. One of the most famous (but perhaps misunderstood) modern examples of this debate can be found in G.H. Hardy 's 1940 essay A Mathematician's Apology . It is widely believed that Hardy considered applied mathematics to be ugly and dull.",
    "source_url": "https://en.wikipedia.org/wiki/Pure_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:36.542702",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:36.542702",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:36.542702",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pure_mathematics_1_1749012156567_1661",
    "text": "It is widely believed that Hardy considered applied mathematics to be ugly and dull. Although it is true that Hardy preferred pure mathematics, which he often compared to painting and poetry , Hardy saw the distinction between pure and applied mathematics to be simply that applied mathematics sought to express physical truth in a mathematical framework, whereas pure mathematics expressed truths that were independent of the physical world. Hardy made a separate distinction in mathematics between what he called \"real\" mathematics, \"which has permanent aesthetic value\", and \"the dull and elementary parts of mathematics\" that have practical use. [ 9 ] Hardy considered some physicists, such as Einstein and Dirac , to be among the \"real\" mathematicians, but at the time that he was writing his Apology , he considered general relativity and quantum mechanics to be \"useless\", which allowed him to hold the opinion that only \"dull\" mathematics was useful.",
    "source_url": "https://en.wikipedia.org/wiki/Pure_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:36.567734",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:36.567734",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:36.567734",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012161140_8403",
    "text": "First, consider ## 19^{53}\\pmod {503} ##. Then ## 53=(110101)_{2}=2^{5}+2^{4}+2^{2}+1=32+16+4+1 ##. Note that \\begin{align*} 19^{2}\\equiv 361\\pmod {503}\\\\ 19^{4}\\equiv 44\\pmod {503}\\\\ 19^{8}\\equiv 427\\pmod {503}\\\\ 19^{16}\\equiv 243\\pmod {503}\\\\ 19^{32}\\equiv 198\\pmod {503}.\\\\ \\end{align*} Thus ## 19^{53}\\equiv (19^{32}\\cdot 19^{16}\\cdot 19^{4}\\cdot 19)\\pmod {503}\\equiv (198\\cdot 243\\cdot 44\\cdot 19)\\pmod {503} ##. Therefore, ## 19^{53}\\equiv 406\\pmod {503} ##. Next, consider ## 141^{47}\\pmod {1537} ##. Then ## 47=(101111)_{2}=2^{5}+2^{3}+2^{2}+2+1=32+8+4+2+1 ##. Note that \\begin{align*} 141^{2}\\equiv 1437\\pmod {1537}\\\\ 141^{4}\\equiv 778\\pmod {1537}\\\\ 141^{8}\\equiv 1243\\pmod {1537}\\\\ 141^{16}\\equiv 364\\pmod {1537}\\\\ 141^{32}\\equiv 314\\pmod {1537}\\\\ \\end{align*} Thus ## 141^{47}\\equiv (141^{32}\\cdot 141^{8}\\cdot 141^{4}\\cdot 141^{2}\\cdot 141)\\pmod {1537}\\equiv (314\\cdot 1243\\cdot 778\\cdot 1437\\cdot 141)\\pmod {1537} ##. Therefore, ## 141^{47}\\equiv 658\\pmod {1537} ##.",
    "source_url": "https://www.physicsforums.com/threads/use-the-binary-exponentiation-algorithm-to-compute.1015967/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:41.140837",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:41.141834",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:41.141834",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012161233_8552",
    "text": "Bluesky LinkedIn Share Forums Homework Help Precalculus Mathematics Homework Help Hot Threads N Came across this puzzle for an 8 year old Started by Natasha1 Jan 4, 2025 Replies: 32 Precalculus Mathematics Homework Help L Equality of sums of powers Started by littlemathquark Jan 31, 2025 Replies: 47 Precalculus Mathematics Homework Help L ##f(x+y) =f(x) f(y)## and ##f(1)+f(2)=5## then find ##f(-1)=?## Started by littlemathquark Feb 4, 2025 Replies: 49 Precalculus Mathematics Homework Help L Regions with polygons Started by littlemathquark Feb 6, 2025 Replies: 12 Precalculus Mathematics Homework Help A Understanding the graphical effect of f(x+a) Started by Aion96 Feb 22, 2025 Replies: 19 Precalculus Mathematics Homework Help Recent Insights F Insights Fermat's Last Theorem Started by fresh_42 May 21, 2025 Replies: 31 General Math F Insights Why Vector Spaces Explain The World: A Historical Perspective Started by fresh_42 Mar 13, 2025 Replies: 0",
    "source_url": "https://www.physicsforums.com/threads/use-the-binary-exponentiation-algorithm-to-compute.1015967/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:41.233428",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:41.233428",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:41.233428",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012163020_4238",
    "text": "Can you illuminate the detector with a small spot of light that you can move around? This is a good way to quantify crosstalk btb4198 570 10 phyzguy said: It could be crosstalk and it could be scattered light. What type of detector is it, and what is the detector architecture? Is it read out in a single array, or in multiple segments? Can you illuminate the detector with a small spot of light that you can move around? This is a good way to quantify  crosstalk Please see attachment. I am  using  a  camera  that has a CMOS image sensor. What do you mean by \" illuminate the detector with a small spot of light\"  that can move around ? how small of a light ? btb4198 570 10 When I put my cell phone in front   of the camera everything turns white phyzguy Science Advisor 5,258 2,322 I don't think you are dealing with crosstalk. Try pointing the camera at a dark screen and point a laser pointer at the screen. You should see a spot of light in the camera.",
    "source_url": "https://www.physicsforums.com/threads/crosstalk-algorithm-optical-system.1002907/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:43.020112",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:43.020112",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:43.020112",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012163182_5018",
    "text": "Replies 4 Views 2K Share: Bluesky LinkedIn Share Forums Physics Classical Physics Optics Hot Threads U I Explain Bernoulli at the molecular level? Started by user079622 May 5, 2025 Replies: 251 Classical Physics Effects of coherence length on optical interference filter Started by shiweiliu Jan 5, 2025 Replies: 66 Optics B Is all EM radiation light? Started by paulb203 Dec 16, 2024 Replies: 35 Classical Physics I Is Mechanical Energy Conservation Free of Ambiguity - follow up Started by cianfa72 Mar 3, 2025 Replies: 76 Classical Physics Z B Can we measure absolute motion of Earth and Sun? Started by zasvitim Jan 14, 2025 Replies: 57 Classical Physics Recent Insights F Insights Fermat's Last Theorem Started by fresh_42 May 21, 2025 Replies: 31 General Math F Insights Why Vector Spaces Explain The World: A Historical Perspective Started by fresh_42 Mar 13, 2025 Replies: 0",
    "source_url": "https://www.physicsforums.com/threads/crosstalk-algorithm-optical-system.1002907/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:43.182027",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:43.182027",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:43.182027",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012170153_1103",
    "text": "Good point. Baluncore said: But this thread is about the proof of the number of \"multiplies\" required for an FFT. Good point again: I should have read from the top! Albert01 14 0 I initially determined the number of Butterflies constructively, using the number of levels and the knowledge that ##N/2## butterflies are required in each level. .Scott said: The proof is fairly simple. Multiplications occur in the butterfly modules and in the preparation of the qk factors - but those qk factors can be prepared at \"compile time\". Only the butterfly multiplies are executed at run time. When N=1, the number of multiplies is zero. Each time you double N=2∗(N−1), you perform two \"N/2\" FFTs and then N/2 butterflies. This is the inductive proof? Not more? Last edited: Apr 19, 2024 Albert01 14 0 A suggestion for proof via induction from me. Please correct me if you find any mistakes! A confirmation would be nice!",
    "source_url": "https://www.physicsforums.com/threads/number-of-multiplications-in-the-fft-algorithm.1060665/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:50.153687",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:50.153687",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:50.153687",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012173564_8253",
    "text": "Given an integer variable timer , write a statement that uses the auto-decrement operator to decrease the value of that variable by 1. 3) Given an int variable k that has already been declared, use a while loop to print a single line consisting of 97 asterisks. Use no variables other than k . 4) Given an int variable n that has already been declared and initialized to a positive value, and another int variable j that has already been declared, use a while loop to print a single line consisting of n asterisks. Thus if n contains 5, five asterisks will be printed. Use no variables other than n and j . 5) Given int variables k and total that have already been declared, use a while loop to compute the sum of the squares of the first 50 counting numbers, and store this value in total . Thus your code should put 1*1 + 2*2 + 3*3 +... + 49*49 + 50*50 into total . Use no variables other than k and total .",
    "source_url": "https://www.physicsforums.com/threads/codelab-excercise-2-computer-programming.378743/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:53.564164",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:53.564164",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:53.564164",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012173596_7835",
    "text": "Use no variables other than k and total . Instructor's notes: You must initialize the value of the variables total and k prior to your loop. 6) Given an int variable n that has been initialized to a positive value and, in addition, int variables k and total that have already been declared, use a while loop to compute the sum of the cubes of the first n counting numbers, and store this value in total . Thus if n equals 4, your code should put 1*1*1 + 2*2*2 + 3*3*3 + 4*4*4 into total . Use no variables other than n , k , and total . Do NOT modify n . 7) Given an int variable k that has already been declared, use a do...while loop to print a single line consisting of 97 asterisks. Use no variables other than k . 8) Given an int variable n that has already been declared and initialized to a positive value, and another int variable j that has already been declared, use a do...while loop to print a single line consisting of n asterisks. Thus if n contains 5, five asterisks will be printed.",
    "source_url": "https://www.physicsforums.com/threads/codelab-excercise-2-computer-programming.378743/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:53.596222",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:53.597223",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:53.597223",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012173624_1495",
    "text": "Thus if n contains 5, five asterisks will be printed. Use no variables other than n and j . 9) Given int variables k and total that have already been declared, use a do...while loop to compute the sum of the squares of the first 50 counting numbers, and store this value in total . Thus your code should put 1*1 + 2*2 + 3*3 +... + 49*49 + 50*50 into total . Use no variables other than k and total . 10)Given an int variable k that has already been declared, use a for loop to print a single line consisting of 97 asterisks. Use no variables other than k . 11)Given an int variable n that has already been declared and initialized to a positive value, and another int variable j that has already been declared, use a for loop to print a single line consisting of n asterisks. Thus if n contains 5, five asterisks will be printed. Use no variables other than n and j . 12)",
    "source_url": "https://www.physicsforums.com/threads/codelab-excercise-2-computer-programming.378743/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:53.624099",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:53.624099",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:53.624099",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012173657_2398",
    "text": "Thus if n contains 5, five asterisks will be printed. Use no variables other than n and j . 12) Given int variables k and total that have already been declared, use a for loop to compute the sum of the squares of the first 50 counting numbers, and store this value in total . Thus your code should put 1*1 + 2*2 + 3*3 +... + 49*49 + 50*50 into total . Use no variables other than k and total . Given that two int variables, total and amount, have been declared, write a loop that reads integers into amount and adds all the non-negative values into total. The loop terminates when a value less than 0 is read into amount. Don't forget to initialize total to 0. 14)Assume that the int variables i , j and n have been declared, and n has been initialized. Write code that causes a \"triangle\" of asterisks to be output to the screen, i.e., n lines should be printed out, the first consisting of a single asterisk, the second consisting of two asterisks, the third consisting of three, etc.",
    "source_url": "https://www.physicsforums.com/threads/codelab-excercise-2-computer-programming.378743/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:53.657021",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:53.657021",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:53.657021",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012173763_2205",
    "text": "22 Engineering and Comp Sci Homework Help Projected Cash Flows: Present and Future Worth Calculations Started by LittleJonJon Jan 16, 2025 Replies: 12 Engineering and Comp Sci Homework Help Engineering Measuring Artificial Intelligence Started by hasilm Jan 18, 2025 Replies: 26 Engineering and Comp Sci Homework Help A Engineering Loads on a shaft with V-Belts Started by arokisbobcat Jan 9, 2025 Replies: 2 Engineering and Comp Sci Homework Help Recent Insights F Insights Fermat's Last Theorem Started by fresh_42 May 21, 2025 Replies: 31 General Math F Insights Why Vector Spaces Explain The World: A Historical Perspective Started by fresh_42 Mar 13, 2025 Replies: 0",
    "source_url": "https://www.physicsforums.com/threads/codelab-excercise-2-computer-programming.378743/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:42:53.763020",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:42:53.763020",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:42:53.763020",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012196525_1793",
    "text": "FallArk 127 0 Update: I figured out how to make the output an integer. By doing this: Code: def eval_infix_sum(expr,pos):\n    if expr[pos+1] == '+' :\n        ans = int(expr[pos]) + int(expr[pos+2])\n    elif expr[pos+1] == '-' :\n        ans = int(expr[pos]) - int(expr[pos+2])\n    pos = pos + 1\n    return ans,pos But I am still confused about how the \"pos\" will correspond with the other functions. I know after finishing the code, the function \"eval_infix\" should be able to call the related functions and get the output, but I don't really understand it clearly I like Serena Homework Helper MHB 16,335 258 Hey FallArk! ;) Suppose we want to evalute [1,\"+\",2,\"+\",3]. Then after calling eval_sum_infix, we will have evaluated \"1+2\", leaving \"+3\". We can call eval_sum_infix again, but then we should continue at pos=3... FallArk 127 0 I like Serena said: Hey FallArk! ;) Suppose we want to evalute [1,\"+\",2,\"+\",3]. Then after calling eval_sum_infix, we will have evaluated \"1+2\", leaving \"+3\".",
    "source_url": "https://www.physicsforums.com/threads/help-with-python-implementing-algorithm.1035553/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:43:16.525806",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:43:16.525806",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:43:16.525806",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012196616_1393",
    "text": "FallArk 127 0 My code so far: Code: def eval_infix_sum(expr,pos):\n    while expr[pos] ! = ';':\n        if expr[pos+1] == '+' :\n            ans = int(expr[pos]) + int(expr[pos+2])\n        elif expr[pos+1] == '-' :\n            ans = int(expr[pos]) - int(expr[pos+2])\n        pos = pos + 1\n    return ans,pos\ndef eval_infix_product(expr,pos): while expr[pos] != ';':\n        if expr[pos+1] == '*' :\n            ans = int(expr[pos]) * int(expr[pos+2])\n        elif expr[pos+1] == '/' :\n            ans = int(expr[pos]) / int(expr[pos+2])\n        pos = pos + 1\n    return ans,pos Inputs like : Code: [\"1\",\"+\",\"2\",\"-3\",\";\"],0 works out just fine. Thanks for the comments, so inside the \"eval_infix_factor\" function, I should do something so that the \"(\" token can be dealt with then? I like Serena Homework Helper MHB 16,335 258 FallArk said: My code so far: Code: def eval_infix_sum(expr,pos):\n    while expr[pos] !",
    "source_url": "https://www.physicsforums.com/threads/help-with-python-implementing-algorithm.1035553/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:43:16.616398",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:43:16.617038",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:43:16.617038",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012196648_3434",
    "text": "FallArk said: My code so far: Code: def eval_infix_sum(expr,pos):\n    while expr[pos] ! = ';':\n        if expr[pos+1] == '+' :\n            ans = int(expr[pos]) + int(expr[pos+2])\n        elif expr[pos+1] == '-' :\n            ans = int(expr[pos]) - int(expr[pos+2])\n        pos = pos + 1\n    return ans,pos\ndef eval_infix_product(expr,pos): while expr[pos] != ';':\n        if expr[pos+1] == '*' :\n            ans = int(expr[pos]) * int(expr[pos+2])\n        elif expr[pos+1] == '/' :\n            ans = int(expr[pos]) / int(expr[pos+2])\n        pos = pos + 1\n    return ans,pos Inputs like : Code: [\"1\",\"+\",\"2\",\"-3\",\";\"],0 works out just fine. Thanks for the comments, so inside the \"eval_infix_factor\" function, I should do something so that the \"(\" token can be dealt with then? What we have is sum-expressions that consist of multiplicative-expressions that consist of either constants or parenthesized expressions. In pseudo code it's something like this. (\"rhs\" is short for right hand side .)",
    "source_url": "https://www.physicsforums.com/threads/help-with-python-implementing-algorithm.1035553/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:43:16.648548",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:43:16.648548",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:43:16.648548",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012196678_5375",
    "text": "In pseudo code it's something like this. (\"rhs\" is short for right hand side .) Code: def sum_expr\n    result = mul_expr\n    while next token == \"+\"\n        rhs = mul_expr\n        result += rhs\n    return result\n\ndef mul_expr\n    result = factor_expr\n    while next token == \"*\"\n        rhs =factor_expr\n        result *= rhs\n    return result\n\ndef factor_expr\n    if next token == \"(\"\n        result = sum_expr\n        skip following \")\"\n    else\n        result = constant\n    return result All the parameters, and tracking of the position still have to be added. FallArk 127 0 duh, I just realized that if input like \" '2 + 3' \" is entered, the function \"eval_infix\" will split it up into a list with semicolon and then call function \"eval_infix_list\" which will call \"eval_infix_sum\". :D I will talk to my instructor today and also ask him about it again. Thank you!",
    "source_url": "https://www.physicsforums.com/threads/help-with-python-implementing-algorithm.1035553/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:43:16.678588",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:43:16.678588",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:43:16.678588",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID__1_1749012199287_1249",
    "text": "do you have a link to Marletto's proof HrvojeDjurdjevic 23 4 Here you are https://royalsocietypublishing.org/doi/10.1098/rsif.2014.1226#d3e2524 tade 720 26 HrvojeDjurdjevic said: Here you are https://royalsocietypublishing.org/doi/10.1098/rsif.2014.1226#d3e2524 thanks, and which part of it describes her proof that the second model is the only possible accurate way pbuk Science Advisor Homework Helper Gold Member 4,947 3,191 HrvojeDjurdjevic said: How sound and rigorous is her proof? It seems tautological to me: \"we define a replicator as something that replicates, therefore in order for something to replicate itself it must contain a replicator\". HrvojeDjurdjevic said: Would you be able to prove the same without looking at her proof? Yes, unless I am wrong in believing it to be vacuously true. HrvojeDjurdjevic said: Can you point to the relevant source that contains already performed and published proofreading of that text?",
    "source_url": "https://www.physicsforums.com/threads/von-neumann-replicator-vehicle-model.1056248/",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:43:19.287165",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:43:19.287165",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:43:19.287165",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_mathematical_theories_1_1749012604697_3215",
    "text": "Jump to content From Wikipedia, the free encyclopedia See also: Theory § Mathematical , Theory (mathematical logic) , and Glossary of areas of mathematics This is a list of mathematical theories .",
    "source_url": "https://en.wikipedia.org/wiki/List_of_mathematical_theories",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:04.697164",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:04.697164",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:04.697164",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_mathematical_theories_1_1749012604738_7586",
    "text": "Proof theory Queue theory Ramsey theory Random matrix theory Representation theory Ring theory Scheme theory Semigroup theory Set theory Shape theory Sheaf theory Sieve theory Singularity theory Soliton theory Spectral theory String theory Sturm-Liouville theory Surgery theory Teichmüller theory Theory of equations Theory of statistics Topos theory Transcendental number theory Twistor theory Type theory Wheel theory Retrieved from \" https://en.wikipedia.org/w/index.php?title=List_of_mathematical_theories&oldid=1264822108 \" Categories : Fields of mathematics Mathematics-related lists Hidden categories: Articles with short description Short description is different from Wikidata List of mathematical theories Add",
    "source_url": "https://en.wikipedia.org/wiki/List_of_mathematical_theories",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:04.738378",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:04.739378",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:04.739378",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_unsolved_problems_in_mathematics_1_1749012609302_6674",
    "text": "Over six decades of Erdős' career, from the 1930s to 1990s The Riemann zeta function , subject of the Riemann hypothesis [ 13 ] Millennium Prize Problems Of the original seven Millennium Prize Problems listed by the Clay Mathematics Institute in 2000, six remain unsolved to date: [ 6 ] Birch and Swinnerton-Dyer conjecture Hodge conjecture Navier–Stokes existence and smoothness P versus NP Riemann hypothesis Yang–Mills existence and mass gap The seventh problem, the Poincaré conjecture , was solved by Grigori Perelman in 2003. [ 14 ] However, a generalization called the smooth four-dimensional Poincaré conjecture —that is, whether a four -dimensional topological sphere can have two or more inequivalent smooth structures —is unsolved. [ 15 ] Notebooks The Kourovka Notebook ( Russian : Коуровская тетрадь ) is a collection of unsolved problems in group theory , first published in 1965 and updated many times since.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:09.302994",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:09.302994",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:09.302994",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_unsolved_problems_in_mathematics_1_1749012609328_8110",
    "text": "[ 23 ] Goncharov conjecture on the cohomology of certain motivic complexes . Green's conjecture : the Clifford index of a non- hyperelliptic curve is determined by the extent to which it, as a canonical curve , has linear syzygies . Grothendieck–Katz p-curvature conjecture : a conjectured local–global principle for linear ordinary differential equations . Hadamard conjecture : for every positive integer k {\\displaystyle k} , a Hadamard matrix of order 4 k {\\displaystyle 4k} exists. Williamson conjecture : the problem of finding Williamson matrices, which can be used to construct Hadamard matrices. Hadamard's maximal determinant problem : what is the largest determinant of a matrix with entries all equal to 1 or −1? Hilbert's fifteenth problem : put Schubert calculus on a rigorous foundation. Hilbert's sixteenth problem : what are the possible configurations of the connected components of M-curves ?",
    "source_url": "https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:09.328211",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:09.328211",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:09.328211",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_unsolved_problems_in_mathematics_1_1749012609357_6295",
    "text": "\\displaystyle N(K,g)} of K {\\displaystyle K} - rational points ? Wild problems : problems involving classification of pairs of n × n {\\displaystyle n\\times n} matrices under simultaneous conjugation. Zariski–Lipman conjecture : for a complex algebraic variety V {\\displaystyle V} with coordinate ring R {\\displaystyle R} , if the derivations of R {\\displaystyle R} are a free module over R {\\displaystyle R} , then V {\\displaystyle V} is smooth . Zauner's conjecture: do SIC-POVMs exist in all dimensions? Zilber–Pink conjecture that if X {\\displaystyle X} is a mixed Shimura variety or semiabelian variety defined over C {\\displaystyle \\mathbb {C} } , and V ⊆ X {\\displaystyle V\\subseteq X} is a subvariety, then V {\\displaystyle V} contains only finitely many atypical subvarieties. Group theory Main article: Group theory The free Burnside group B ( 2 , 3 ) {\\displaystyle B(2,3)} is finite; in its Cayley graph , shown here, each of its 27 elements is represented by a vertex.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:09.357742",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:09.357742",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:09.357742",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_unsolved_problems_in_mathematics_1_1749012609380_7588",
    "text": "Analysis Main article: Mathematical analysis The Brennan conjecture : estimating the integral of powers of the moduli of the derivative of conformal maps into the open unit disk, on certain subsets of C {\\displaystyle \\mathbb {C} } Fuglede's conjecture on whether nonconvex sets in R {\\displaystyle \\mathbb {R} } and R 2 {\\displaystyle \\mathbb {R} ^{2}} are spectral if and only if they tile by translation . Goodman's conjecture on the coefficients of multivalued functions Invariant subspace problem – does every bounded operator on a complex Banach space send some non-trivial closed subspace to itself? Kung–Traub conjecture on the optimal order of a multipoint iteration without memory [ 25 ] Lehmer's conjecture on the Mahler measure of non-cyclotomic polynomials [ 26 ]",
    "source_url": "https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:09.380760",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:09.381753",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:09.381753",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_unsolved_problems_in_mathematics_1_1749012609536_8347",
    "text": "[ 71 ] Dissection into orthoschemes – is it possible for simplices of every dimension? [ 72 ] Ehrhart's volume conjecture : a convex body K {\\displaystyle K} in n {\\displaystyle n} dimensions containing a single lattice point in its interior as its center of mass cannot have volume greater than ( n + 1 ) n / n ! {\\displaystyle (n+1)^{n}/n!} Falconer's conjecture : sets of Hausdorff dimension greater than d / 2 {\\displaystyle d/2} in R d {\\displaystyle \\mathbb {R} ^{d}} must have a distance set of nonzero Lebesgue measure [ 73 ] The values of the Hermite constants for dimensions other than 1–8 and 24 What is the lowest number of faces possible for a holyhedron ? Inscribed square problem , also known as Toeplitz' conjecture and the square peg problem – does every Jordan curve have an inscribed square?",
    "source_url": "https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:09.536071",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:09.536071",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:09.536071",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Glossary_of_areas_of_mathematics_1_1749012612615_7718",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article includes a list of general references , but it lacks sufficient corresponding inline citations . Please help to improve this article by introducing more precise citations. ( August 2024 ) ( Learn how and when to remove this message ) This list has no precise inclusion criteria as described in the Manual of Style for standalone lists . Please improve this article by adding inclusion criteria, or discuss this issue on the talk page . ( July 2022 ) Mathematics is a broad subject that is commonly divided in many areas or branches that may be defined by their objects of study , by the used methods, or by both. For example, analytic number theory is a subarea of number theory devoted to the use of methods of analysis for the study of natural numbers . This glossary is alphabetically sorted. This hides a large part of the relationships between areas.",
    "source_url": "https://en.wikipedia.org/wiki/Glossary_of_areas_of_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:12.615954",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:12.616957",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:12.616957",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Glossary_of_areas_of_mathematics_1_1749012612643_6112",
    "text": "This glossary is alphabetically sorted. This hides a large part of the relationships between areas. For the broadest areas of mathematics, see Mathematics § Areas of mathematics . The Mathematics Subject Classification is a hierarchical list of areas and subjects of study that has been elaborated by the community of mathematicians. It is used by most publishers for classifying mathematical articles and books. Contents: Top A B C D E F G H I J K L M N O P Q R S T U V W X Y Z See also References A [ edit ] Absolute differential calculus An older name of Ricci calculus Absolute geometry Also called neutral geometry , [ 1 ] a synthetic geometry similar to Euclidean geometry but without the parallel postulate . [ 2 ] Abstract algebra The part of algebra devoted to the study of algebraic structures in themselves. [ 3 ] Occasionally named modern algebra in course titles.",
    "source_url": "https://en.wikipedia.org/wiki/Glossary_of_areas_of_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:12.643004",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:12.643004",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:12.643004",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Glossary_of_areas_of_mathematics_1_1749012612667_7447",
    "text": "[ 3 ] Occasionally named modern algebra in course titles. Abstract analytic number theory The study of arithmetic semigroups as a means to extend notions from classical analytic number theory . [ 4 ] Abstract differential geometry A form of differential geometry without the notion of smoothness from calculus . Instead it is built using sheaf theory and sheaf cohomology . Abstract harmonic analysis A modern branch of harmonic analysis that extends upon the generalized Fourier transforms that can be defined on locally compact groups . Abstract homotopy theory A part of topology that deals with homotopic functions, i.e. functions from one topological space to another which are homotopic (the functions can be deformed into one another). Actuarial science The discipline that applies mathematical and statistical methods to assess risk in insurance , finance and other industries and professions. More generally, actuaries apply rigorous mathematics to model matters of uncertainty.",
    "source_url": "https://en.wikipedia.org/wiki/Glossary_of_areas_of_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:12.667762",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:12.667762",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:12.667762",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Glossary_of_areas_of_mathematics_1_1749012612690_7653",
    "text": "More generally, actuaries apply rigorous mathematics to model matters of uncertainty. Additive combinatorics The part of arithmetic combinatorics devoted to the operations of addition and subtraction . Additive number theory A part of number theory that studies subsets of integers and their behaviour under addition. Affine geometry A branch of geometry that deals with properties that are independent from distances and angles, such as alignment and parallelism . Affine geometry of curves The study of curve properties that are invariant under affine transformations . Affine differential geometry A type of differential geometry dedicated to differential invariants under volume -preserving affine transformations . Ahlfors theory A part of complex analysis being the geometric counterpart of Nevanlinna theory . It was invented by Lars Ahlfors . Algebra One of the major areas of mathematics .",
    "source_url": "https://en.wikipedia.org/wiki/Glossary_of_areas_of_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:12.690651",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:12.690651",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:12.690651",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Glossary_of_areas_of_mathematics_1_1749012612738_2989",
    "text": "Fundamentally, it studies algebraic varieties . Algebraic graph theory a branch of graph theory in which methods are taken from algebra and employed to problems about graphs . The methods are commonly taken from group theory and linear algebra. Algebraic K-theory an important part of homological algebra concerned with defining and applying a certain sequence of functors from rings to abelian groups . Algebraic number theory The part of number theory devoted to the use of algebraic methods, mainly those of commutative algebra , for the study of number fields and their rings of integers . Algebraic statistics the use of algebra to advance statistics , although the term is sometimes restricted to label the use of algebraic geometry and commutative algebra in statistics . Algebraic topology a branch that uses tools from abstract algebra for topology to study topological spaces .",
    "source_url": "https://en.wikipedia.org/wiki/Glossary_of_areas_of_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:12.738296",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:12.738296",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:12.738296",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Glossary_of_areas_of_mathematics_1_1749012612796_4311",
    "text": "It is a subarea of both complex analysis and algebraic geometry . Analytic number theory An area of number theory that applies methods from mathematical analysis to solve problems about integers . [ 6 ] Analytic theory of L-functions Applied mathematics a combination of various parts of mathematics that concern a variety of mathematical methods that can be applied to practical and theoretical problems. Typically the methods used are for science , engineering , finance , economics and logistics . Approximation theory part of analysis that studies how well functions can be approximated by simpler ones (such as polynomials or trigonometric polynomials ) Arakelov geometry also known as Arakelov theory Arakelov theory an approach to Diophantine geometry used to study Diophantine equations in higher dimensions (using techniques from algebraic geometry). It is named after Suren Arakelov .",
    "source_url": "https://en.wikipedia.org/wiki/Glossary_of_areas_of_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:12.796891",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:12.796891",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:12.796891",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Glossary_of_areas_of_mathematics_1_1749012612819_3994",
    "text": "It is named after Suren Arakelov . Arithmetic 1.   Also known as elementary arithmetic , the methods and rules for computing with addition , subtraction , multiplication and division of numbers. 2.   Also known as higher arithmetic , another name for number theory . Arithmetic algebraic geometry See arithmetic geometry . Arithmetic combinatorics the study of the estimates from combinatorics that are associated with arithmetic operations such as addition, subtraction , multiplication and division . Arithmetic dynamics Arithmetic dynamics is the study of the number-theoretic properties of integer , rational , p -adic, and/or algebraic points under repeated application of a polynomial or rational function . A fundamental goal is to describe arithmetic properties in terms of underlying geometric structures. Arithmetic geometry The use of algebraic geometry and more specially scheme theory for solving problems of number theory.",
    "source_url": "https://en.wikipedia.org/wiki/Glossary_of_areas_of_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:12.819888",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:12.819888",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:12.819888",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_mathematical_topics_in_quantum_theory_1_1749012615534_4938",
    "text": "supermultiplet supergravity Quantum gravity [ edit ] theory of everything loop quantum gravity spin network black hole thermodynamics Non-commutative geometry [ edit ] Quantum group Hopf algebra Noncommutative quantum field theory String theory [ edit ] See list of string theory topics Matrix model Retrieved from \" https://en.wikipedia.org/w/index.php?title=List_of_mathematical_topics_in_quantum_theory&oldid=1285934627 \" Categories : Mathematics-related lists Quantum mechanics Hidden categories: Articles with short description Short description is different from Wikidata List of mathematical topics in quantum theory Add",
    "source_url": "https://en.wikipedia.org/wiki/List_of_mathematical_topics_in_quantum_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:15.534921",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:15.534921",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:15.534921",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_abstract_algebra_topics_1_1749012617195_2217",
    "text": "Jump to content From Wikipedia, the free encyclopedia Look up Appendix:Glossary of abstract algebra in Wiktionary, the free dictionary. Abstract algebra is the subject area of mathematics that studies algebraic structures , such as groups , rings , fields , modules , vector spaces , and algebras . The phrase abstract algebra was coined at the turn of the 20th century to distinguish this area from what was normally referred to as algebra, the study of the rules for manipulating formulae and algebraic expressions involving unknowns and real or complex numbers , often now called elementary algebra . The distinction is rarely made in more recent writings. Basic language [ edit ] Algebraic structures are defined primarily as sets with operations . Algebraic structure Subobjects : subgroup , subring , subalgebra , submodule etc.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_abstract_algebra_topics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:17.195648",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:17.195648",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:17.195648",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_abstract_algebra_topics_1_1749012617234_5313",
    "text": "Morita equivalence , Morita duality Category of vector spaces Homological algebra Filtration (algebra) Exact sequence Functor Zorn's lemma Semigroups and monoids [ edit ] Semigroup Subsemigroup Free semigroup Green's relations Inverse semigroup (or inversion semigroup, cf. [1] ) Krohn–Rhodes theory Semigroup algebra Transformation semigroup Monoid Aperiodic monoid Free monoid Monoid (category theory) Monoid factorisation Syntactic monoid Group theory [ edit ] Main article: List of group theory topics Structure Group (mathematics) Lagrange's theorem (group theory)",
    "source_url": "https://en.wikipedia.org/wiki/List_of_abstract_algebra_topics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:17.234632",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:17.234632",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:17.234632",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_abstract_algebra_topics_1_1749012617291_2350",
    "text": "Ring homomorphism , Algebra homomorphism Ring epimorphism Ring monomorphism Ring isomorphism Skolem–Noether theorem Graded algebra Morita equivalence Brauer group Constructions Direct sum of rings , Product of rings Quotient ring Matrix ring Endomorphism ring Polynomial ring Formal power series Monoid ring , Group ring Localization of a ring Tensor algebra Symmetric algebra , Exterior algebra , Clifford algebra Free algebra Completion (ring theory)",
    "source_url": "https://en.wikipedia.org/wiki/List_of_abstract_algebra_topics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:17.291549",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:17.291549",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:17.291549",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_abstract_algebra_topics_1_1749012617343_9606",
    "text": "Jordan algebra Differential algebra Banach algebra Examples Rational number , Real number , Complex number , Quaternions , Octonions Hurwitz quaternion Gaussian integer Theorems and applications Algebraic geometry Hilbert's Nullstellensatz Hilbert's basis theorem Hopkins–Levitzki theorem Krull's principal ideal theorem Levitzky's theorem Galois theory Abel–Ruffini theorem Artin-Wedderburn theorem Jacobson density theorem Wedderburn's little theorem Lasker–Noether theorem Field theory [ edit ] Main article: Field theory (mathematics) Basic concepts Field (mathematics) Subfield (mathematics) Multiplicative group Primitive element (field theory) Field extension Algebraic extension Splitting field Algebraically closed field Algebraic element Algebraic closure Separable extension Separable polynomial Normal extension Galois extension Abelian extension Transcendence degree Field norm Field trace Conjugate element (field theory)",
    "source_url": "https://en.wikipedia.org/wiki/List_of_abstract_algebra_topics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:17.343464",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:17.343464",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:17.343464",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_abstract_algebra_topics_1_1749012617361_8421",
    "text": "Tensor product of fields Types Algebraic number field Global field Local field Finite field Symmetric function Formally real field Real closed field Applications Galois theory Galois group Inverse Galois problem Kummer theory Module theory [ edit ] Main article: Module (mathematics) General Module (mathematics) Bimodule Annihilator (ring theory) Structure Submodule Pure submodule Module homomorphism Essential submodule Superfluous submodule Singular submodule Socle of a module Radical of a module Constructions Free module Quotient module Direct sum , Direct product of modules Direct limit , Inverse limit Localization of a module Completion (ring theory)",
    "source_url": "https://en.wikipedia.org/wiki/List_of_abstract_algebra_topics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:17.361487",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:17.361487",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:17.361487",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Boolean_algebra_1_1749012636259_8255",
    "text": "They are used to store either true or false values. [ 21 ] The basic operations on Boolean variables x and y are defined as follows: Logical operation Operator Notation Alternative notations Definition Conjunction AND x ∧ y x AND y , K xy x ∧ y = 1 if x = y = 1, x ∧ y = 0 otherwise Disjunction OR x ∨ y x OR y , A xy x ∨ y = 0 if x = y = 0, x ∨ y = 1 otherwise Negation NOT ¬ x NOT x , N x , x̅ , x' , ! x ¬ x = 0 if x = 1, ¬ x = 1 if x = 0 Alternatively, the values of x ∧ y , x ∨ y , and ¬ x can be expressed by tabulating their values with truth tables as follows: [ 22 ] x {\\displaystyle x} y {\\displaystyle y} x ∧ y {\\displaystyle x\\wedge y} x ∨ y {\\displaystyle x\\vee y} 0 0 0 0 1 0 0 1 0 1 0 1 1 1 1 1 x {\\displaystyle x} ¬ x {\\displaystyle \\neg x} 0 1 1 0 When used in expressions, the operators are applied according to the precedence rules. As with elementary algebra, expressions in parentheses are evaluated first, following the precedence rules. [ 23 ]",
    "source_url": "https://en.wikipedia.org/wiki/Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:36.259509",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:36.259509",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:36.259509",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Boolean_algebra_1_1749012636286_4159",
    "text": "[ 23 ] If the truth values 0 and 1 are interpreted as integers, these operations may be expressed with the ordinary operations of arithmetic (where x + y uses addition and xy uses multiplication), or by the minimum/maximum functions: x ∧ y = x y = min ( x , y ) x ∨ y = x + y − x y = x + y ( 1 − x ) = max ( x , y ) ¬ x = 1 − x {\\displaystyle {\\begin{aligned}x\\wedge y&=xy=\\min(x,y)\\\\x\\vee y&=x+y-xy=x+y(1-x)=\\max(x,y)\\\\\\neg x&=1-x\\end{aligned}}} One might consider that only negation and one of the two other operations are basic because of the following identities that allow one to define conjunction in terms of negation and the disjunction, and vice versa ( De Morgan's laws ): [ 24 ] x ∧ y = ¬ ( ¬ x ∨ ¬ y ) x",
    "source_url": "https://en.wikipedia.org/wiki/Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:36.286997",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:36.286997",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:36.286997",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Boolean_algebra_1_1749012636442_9947",
    "text": "x ∨ y = ¬ ( ¬ x ∧ ¬ y ) {\\displaystyle {\\begin{aligned}x\\wedge y&=\\neg (\\neg x\\vee \\neg y)\\\\x\\vee y&=\\neg (\\neg x\\wedge \\neg y)\\end{aligned}}} Secondary operations [ edit ] Operations composed from the basic operations include, among others, the following: Material conditional : x → y = ¬ x ∨ y {\\textstyle x\\rightarrow y=\\neg {x}\\vee y} Material biconditional : x ↔ y = ( x ∧ y ) ∨ ( ¬ x ∧ ¬ y ) = ( x ∨ ¬ y ) ∧ ( ¬ x ∨ y ) {\\textstyle x\\leftrightarrow y=(x\\land y)\\lor (\\neg x\\land \\neg y)=(x\\lor \\neg y)\\land (\\neg x\\lor y)} Exclusive OR ( XOR ): x ⊕ y = ¬ ( x ↔ y ) = ( x ∨ y ) ∧ ¬ ( x ∧ y ) = ( x ∨ y ) ∧ ( ¬ x ∨ ¬ y ) = ( x ∧ ¬ y ) ∨ ( ¬ x ∧ y ) {\\textstyle x\\oplus y=\\neg (x\\leftrightarrow y)=(x\\vee y)\\wedge \\neg (x\\wedge y)=(x\\vee y)\\wedge (\\neg x\\vee \\neg y)=(x\\wedge \\neg y)\\vee (\\neg x\\wedge y)} These definitions give rise to the following truth tables giving the values of these operations for all four possible inputs. Secondary operations. Table 1",
    "source_url": "https://en.wikipedia.org/wiki/Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:36.442572",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:36.443215",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:36.443215",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Euclidean_algorithm_1_1749012658149_9949",
    "text": "A 24×60 rectangle is covered with ten 12×12 square tiles, where 12 is the GCD of 24 and 60. More generally, an a × b rectangle can be covered with square tiles of side-length c only if c is a common divisor of a and b . Let g = gcd( a , b ) . Since a and b are both multiples of g , they can be written a = mg and b = ng , and there is no larger number G > g for which this is true. The natural numbers m and n must be coprime, since any common factor could be factored out of m and n to make g greater. Thus, any other number c that divides both a and b must also divide g . The greatest common divisor g of a and b is the unique (positive) common divisor of a and b that is divisible by any other common divisor c . [ 6 ] The greatest common divisor can be visualized as follows. [ 7 ] Consider a rectangular area a by b , and any common divisor c that divides both a and b exactly.",
    "source_url": "https://en.wikipedia.org/wiki/Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:58.149236",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:58.149236",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:58.149236",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Euclidean_algorithm_1_1749012658323_9012",
    "text": "This determines r 0 = 147 {\\displaystyle r_{0}=147} and so the sequence is now { 1071 , 462 , r 0 = 147 } {\\displaystyle \\{1071,\\ 462,\\ r_{0}=147\\}} . The next step is to continue the sequence to find r 1 {\\displaystyle r_{1}} by finding integers q 1 {\\displaystyle q_{1}} and r 1 < r 0 {\\displaystyle r_{1}<r_{0}} such that: 462 = q 1 ⋅ 147 + r 1 {\\displaystyle 462=q_{1}\\cdot 147+r_{1}} . This is the quotient q 1 = 3 {\\displaystyle q_{1}=3} since 462 = 3 ⋅ 147 + 21 {\\displaystyle 462=3\\cdot 147+21} . This determines r 1 = 21 {\\displaystyle r_{1}=21} and so the sequence is now { 1071 , 462 , 147 , r 1 = 21 } {\\displaystyle \\{1071,\\ 462,\\ 147,\\ r_{1}=21\\}} . The next step is to continue the sequence to find r 2 {\\displaystyle r_{2}} by finding integers q 2 {\\displaystyle q_{2}} and r 2 < r 1 {\\displaystyle r_{2}<r_{1}} such that: 147 = q 2 ⋅ 21 + r 2 {\\displaystyle 147=q_{2}\\cdot 21+r_{2}} .",
    "source_url": "https://en.wikipedia.org/wiki/Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:58.323333",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:58.323333",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:58.323333",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Euclidean_algorithm_1_1749012658395_9362",
    "text": "r N −2 = q N r N −1 since the final remainder r N is zero. r N −1 also divides its next predecessor r N −3 r N −3 = q N −1 r N −2 + r N −1 because it divides both terms on the right-hand side of the equation. Iterating the same argument, r N −1 divides all the preceding remainders, including a and b . None of the preceding remainders r N −2 , r N −3 , etc. divide a and b , since they leave a remainder. Since r N −1 is a common divisor of a and b , r N −1 ≤ g . In the second step, any natural number c that divides both a and b (in other words, any common divisor of a and b ) divides the remainders r k . By definition, a and b can be written as multiples of c : a = mc and b = nc , where m and n are natural numbers. Therefore, c divides the initial remainder r 0 , since r 0 = a − q 0 b = mc − q 0 nc = ( m − q 0 n ) c . An analogous argument shows that c also divides the subsequent remainders r 1 , r 2 , etc.",
    "source_url": "https://en.wikipedia.org/wiki/Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:50:58.395130",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:50:58.395130",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:50:58.395130",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Euclidean_algorithm&oldid=1288126959_1_1749012664026_6180",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Citation bot ( talk | contribs ) at 16:35, 30 April 2025 (Add: location, issue. | Use this bot . Report bugs . | Suggested by Dominic3203 | Linked from User:Mathbot/Most_linked_math_articles | #UCB_webform_linked 659/1913) . The present address (URL) is a permanent link to this version. Revision as of 16:35, 30 April 2025 by Citation bot ( talk | contribs ) (Add: location, issue. | Use t",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Euclidean_algorithm&oldid=1288126959",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:51:04.026430",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:51:04.026430",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:51:04.026430",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Needleman%E2%80%93Wunsch_algorithm_1_1749012675804_6945",
    "text": "Jump to content From Wikipedia, the free encyclopedia Method for aligning biological sequences This article may be too technical for most readers to understand . Please help improve it to make it understandable to non-experts , without removing the technical details. ( September 2013 ) ( Learn how and when to remove this message ) Figure 1: Needleman-Wunsch pairwise sequence alignment Class Sequence alignment Worst-case performance O ( m n ) {\\displaystyle O(mn)} Worst-case space complexity O ( ",
    "source_url": "https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:51:15.804858",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:51:15.804858",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:51:15.804858",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Risch_algorithm_1_1749012680195_9622",
    "text": "Jump to content From Wikipedia, the free encyclopedia Method for evaluating indefinite integrals Part of a series of articles about Calculus ∫ a b f ′ ( t ) d t = f ( b ) − f ( a ) {\\displaystyle \\int _{a}^{b}f'(t)\\,dt=f(b)-f(a)} Fundamental theorem Limits Continuity Rolle's theorem Mean value theorem Inverse function theorem Differential Definitions Derivative ( generalizations ) Differential infinitesimal of a function total Concepts Differentiation notation Second derivative Implicit differen",
    "source_url": "https://en.wikipedia.org/wiki/Risch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:51:20.195876",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:51:20.195876",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:51:20.195876",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Nested_sampling_algorithm_1_1749012701978_7990",
    "text": "Jump to content From Wikipedia, the free encyclopedia Part of a series on Bayesian statistics Posterior = Likelihood × Prior ÷ Evidence Background Bayesian inference Bayesian probability Bayes' theorem Bernstein–von Mises theorem Coherence Cox's theorem Cromwell's rule Likelihood principle Principle of indifference Principle of maximum entropy Model building Conjugate prior Linear regression Empirical Bayes Hierarchical model Posterior approximation Markov chain Monte Carlo Laplace's approximati",
    "source_url": "https://en.wikipedia.org/wiki/Nested_sampling_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:51:41.978030",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:51:41.978030",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:51:41.978030",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Linde%E2%80%93Buzo%E2%80%93Gray_algorithm_1_1749012703342_5290",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article is missing information about general information, usage in the field (mention cinepak?), optimality conditions, choice of 𝜖s, model instead of training data, ELBG. Please expand the article to include this information. Further details may exist on the talk page . ( December 2023 ) This article relies largely or entirely on a single source . Relevant discussion may be found on the talk page . Please help improve this article by in",
    "source_url": "https://en.wikipedia.org/wiki/Linde%E2%80%93Buzo%E2%80%93Gray_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:51:43.342669",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:51:43.342669",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:51:43.342669",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Fast_Cosine_Transform_1_1749012717401_3851",
    "text": "Jump to content From Wikipedia, the free encyclopedia (Redirected from Fast Cosine Transform ) Technique used in signal processing and data compression A discrete cosine transform ( DCT ) expresses a finite sequence of data points in terms of a sum of cosine functions oscillating at different frequencies . The DCT, first proposed by Nasir Ahmed in 1972, is a widely used transformation technique in signal processing and data compression . It is used in most digital media , including digital image",
    "source_url": "https://en.wikipedia.org/wiki/Fast_Cosine_Transform",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:51:57.401415",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:51:57.401415",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:51:57.401415",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Join_(SQL)_1_1749012721021_4539",
    "text": "Jump to content From Wikipedia, the free encyclopedia SQL clause A Venn diagram representing the full join SQL statement between tables A and B. A join clause in the Structured Query Language ( SQL ) combines columns from one or more tables into a new table. The operation corresponds to a join operation in relational algebra . Informally, a join stitches two tables and puts on the same row records with matching fields : INNER , LEFT OUTER , RIGHT OUTER , FULL OUTER and CROSS . Example tables [ e",
    "source_url": "https://en.wikipedia.org/wiki/Join_(SQL)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:52:01.021808",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:52:01.021808",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:52:01.021808",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Snapshot_algorithm_1_1749012723985_8283",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article's tone or style may not reflect the encyclopedic tone used on Wikipedia . See Wikipedia's guide to writing better articles for suggestions. ( November 2016 ) ( Learn how and when to remove this message ) This article needs additional citations for verification . Please help improve th",
    "source_url": "https://en.wikipedia.org/wiki/Snapshot_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:52:03.985205",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:52:03.985205",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:52:03.985205",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Analysis_of_algorithms&oldid=1286246799_1_1749012745219_6772",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Widefox ( talk | contribs ) at 17:34, 18 April 2025 ( → See also : already in body per WP:SEEALSO / WP:OVERLINK ) . The present address (URL) is a permanent link to this version. Revision as of 17:34, 18 April 2025 by Widefox ( talk | contribs ) ( → See also : already in body per WP:SEEALSO / WP:OVERLINK ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) St",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Analysis_of_algorithms&oldid=1286246799",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:52:25.219700",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:52:25.219700",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:52:25.219700",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithmic_efficiency&oldid=1286247421_1_1749012748550_5558",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Widefox ( talk | contribs ) at 17:38, 18 April 2025 ( → top : fix sect WP:ORDER , fix hatnote) . The present address (URL) is a permanent link to this version. Revision as of 17:38, 18 April 2025 by Widefox ( talk | contribs ) ( → top : fix sect WP:ORDER , fix hatnote) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Not to be confused with program optimiza",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithmic_efficiency&oldid=1286247421",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:52:28.550734",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:52:28.551726",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:52:28.551726",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Atlantic_City_algorithm_1_1749012752999_3714",
    "text": "Jump to content From Wikipedia, the free encyclopedia You can help expand this article with text translated from the corresponding article in French . (June 2022) Click [show] for important translation instructions. View a machine-translated version of the French article. Machine translation, like DeepL or Google Translate , is a useful starting point for translations, but translators must revise errors as necessary and confirm that the translation is accurate, rather than simply copy-pasting ma",
    "source_url": "https://en.wikipedia.org/wiki/Atlantic_City_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:52:32.999701",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:52:32.999701",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:52:32.999701",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Randomized_algorithm&oldid=1276591468_1_1749012754421_3673",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by WikiCleanerBot ( talk | contribs ) at 18:46, 19 February 2025 (v2.05b - Bot T20 CW#61 - Fix errors for CW project (Reference before punctuation)) . The present address (URL) is a permanent link to this version. Revision as of 18:46, 19 February 2025 by WikiCleanerBot ( talk | contribs ) (v2.05b - Bot T20 CW#61 - Fix errors for CW project (Reference before punctuation)) ( diff ) ← Previou",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Randomized_algorithm&oldid=1276591468",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:52:34.421496",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:52:34.421496",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:52:34.421496",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Horner%27s_method_1_1749012761438_4094",
    "text": "To see why this works, the polynomial can be written in the form p ( x ) = a 0 + x ( a 1 + x ( a 2 + x ( a 3 + ⋯ + x ( a n − 1 + x a n ) ⋯ ) ) ) . {\\displaystyle p(x)=a_{0}+x{\\bigg (}a_{1}+x{\\Big (}a_{2}+x{\\big (}a_{3}+\\cdots +x(a_{n-1}+x\\,a_{n})\\cdots {\\big )}{\\Big )}{\\bigg )}\\ .} Thus, by iteratively substituting the b i {\\displaystyle b_{i}} into the expression, p ( x 0 ) = a 0 + x 0 ( a 1 + x 0 ( a 2 + ⋯ + x 0 ( a n − 1 + b n x 0 ) ⋯ ) ) = a 0 + x 0 ( a 1 + x 0 ( a 2 + ⋯ + x 0 b n − 1 ) ) ⋮ = a 0 + x 0 b 1 = b 0 . {\\displaystyle {\\begin{aligned}p(x_{0})&=a_{0}+x_{0}{\\Big (}a_{1}+x_{0}{\\big (}a_{2}+\\cdots +x_{0}(a_{n-1}+b_{n}x_{0})\\cdots {\\big )}{\\Big )}\\\\&=a_{0}+x_{0}{\\Big (}a_{1}+x_{0}{\\big (}a_{2}+\\cdots +x_{0}b_{n-1}{\\big )}{\\Big )}\\\\&~~\\vdots \\\\&=a_{0}+x_{0}b_{1}\\\\&=b_{0}.\\end{aligned}}} Now, it can be proven that; p ( x ) = ( b 1 + b 2 x + b 3 x 2 + b 4 x 3 + ⋯ + b n − 1 x n − 2 + b n x n − 1 )",
    "source_url": "https://en.wikipedia.org/wiki/Horner%27s_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:52:41.438000",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:52:41.438000",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:52:41.438000",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Horner%27s_method_1_1749012761508_9373",
    "text": "Then you then work recursively using the formula: b n − 1 = a n − 1 + b n x 0 {\\displaystyle b_{n-1}=a_{n-1}+b_{n}x_{0}} till you arrive at b 0 {\\displaystyle b_{0}} . Examples [ edit ] Evaluate f ( x ) = 2 x 3 − 6 x 2 + 2 x − 1 {\\displaystyle f(x)=2x^{3}-6x^{2}+2x-1} for x = 3 {\\displaystyle x=3} . We use synthetic division as follows: x 0 │ x 3 x 2 x 1 x 0 3 │   2    −6     2    −1\n   │         6     0     6\n   └────────────────────────\n       2     0     2     5 The entries in the third row are the sum of those in the first two. Each entry in the second row is the product of the x -value ( 3 in this example) with the third-row entry immediately to the left. The entries in the first row are the coefficients of the polynomial to be evaluated. Then the remainder of f ( x ) {\\displaystyle f(x)} on division by x − 3 {\\displaystyle x-3} is 5 . But by the polynomial remainder theorem , we know that the remainder is f ( 3 ) {\\displaystyle f(3)} . Thus, f ( 3 ) = 5 {\\displaystyle f(3)=5} .",
    "source_url": "https://en.wikipedia.org/wiki/Horner%27s_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:52:41.508884",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:52:41.509888",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:52:41.509888",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Horner%27s_method_1_1749012761545_5521",
    "text": "Thus, f ( 3 ) = 5 {\\displaystyle f(3)=5} . In this example, if a 3 = 2 , a 2 = − 6 , a 1 = 2 , a 0 = − 1 {\\displaystyle a_{3}=2,a_{2}=-6,a_{1}=2,a_{0}=-1} we can see that b 3 = 2 , b 2 = 0 , b 1 = 2 , b 0 = 5 {\\displaystyle b_{3}=2,b_{2}=0,b_{1}=2,b_{0}=5} , the entries in the third row. So, synthetic division (which was actually invented and published by Ruffini 10 years before Horner's publication) is easier to use;  it can be shown to be equivalent to Horner's method. As a consequence of the polynomial remainder theorem, the entries in the third row are the coefficients of the second-degree polynomial, the quotient of f ( x ) {\\displaystyle f(x)} on division by x − 3 {\\displaystyle x-3} . The remainder is 5 . This makes Horner's method useful for polynomial long division . Divide x 3 − 6 x 2 + 11 x − 6 {\\displaystyle x^{3}-6x^{2}+11x-6} by x − 2 {\\displaystyle x-2} : 2 │   1    −6    11    −6\n   │         2    −8     6\n   └────────────────────────\n       1    −4     3     0",
    "source_url": "https://en.wikipedia.org/wiki/Horner%27s_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:52:41.545022",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:52:41.545022",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:52:41.545022",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Horner%27s_method_1_1749012761577_7450",
    "text": "The quotient is x 2 − 4 x + 3 {\\displaystyle x^{2}-4x+3} . Let f 1 ( x ) = 4 x 4 − 6 x 3 + 3 x − 5 {\\displaystyle f_{1}(x)=4x^{4}-6x^{3}+3x-5} and f 2 ( x ) = 2 x − 1 {\\displaystyle f_{2}(x)=2x-1} . Divide f 1 ( x ) {\\displaystyle f_{1}(x)} by f 2 ( x ) {\\displaystyle f_{2}\\,(x)} using Horner's method. 0.5 │ 4  −6   0   3  −5\n      │     2  −2  −1   1\n      └───────────────────────\n        2  −2  −1   1  −4 The third row is the sum of the first two rows, divided by 2 . Each entry in the second row is the product of 1 with the third-row entry to the left. The answer is f 1 ( x ) f 2 ( x ) = 2 x 3 − 2 x 2 − x + 1 − 4 2 x − 1 . {\\displaystyle {\\frac {f_{1}(x)}{f_{2}(x)}}=2x^{3}-2x^{2}-x+1-{\\frac {4}{2x-1}}.}",
    "source_url": "https://en.wikipedia.org/wiki/Horner%27s_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:52:41.577580",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:52:41.578573",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:52:41.578573",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Risch_algorithm_1_1749012765067_6586",
    "text": "Jump to content From Wikipedia, the free encyclopedia Method for evaluating indefinite integrals Part of a series of articles about Calculus ∫ a b f ′ ( t )",
    "source_url": "https://en.wikipedia.org/wiki/Risch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:52:45.067844",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:52:45.067844",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:52:45.067844",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Risch_algorithm_1_1749012765087_4407",
    "text": "d t = f ( b ) − f ( a ) {\\displaystyle \\int _{a}^{b}f'(t)\\,dt=f(b)-f(a)} Fundamental theorem Limits Continuity Rolle's theorem Mean value theorem Inverse function theorem Differential Definitions Derivative ( generalizations ) Differential infinitesimal of a function total Concepts Differentiation notation Second derivative Implicit differentiation Logarithmic differentiation Related rates Taylor's theorem Rules and identities Sum Product Chain Power Quotient L'Hôpital's rule Inverse General Leibniz Faà di Bruno's formula Reynolds Integral Lists of integrals Integral transform Leibniz integral rule Definitions Antiderivative Integral ( improper ) Riemann integral Lebesgue integration Contour integration Integral of inverse functions Integration by Parts Discs Cylindrical shells Substitution ( trigonometric , tangent half-angle , Euler ) Euler's formula Partial fractions ( Heaviside's method )",
    "source_url": "https://en.wikipedia.org/wiki/Risch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:52:45.087854",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:52:45.087854",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:52:45.087854",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Risch_algorithm&oldid=1292293391_1_1749012766820_6337",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 06:22, 26 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 06:22, 26 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Meth",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Risch_algorithm&oldid=1292293391",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:52:46.820577",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:52:46.821577",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:52:46.821577",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_mathematical_theories_1_1749013111353_5102",
    "text": "Jump to content From Wikipedia, the free encyclopedia See also: Theory § Mathematical , Theory (mathematical logic) , and Glossary of areas of mathematics This is a list of mathematical theories .",
    "source_url": "https://en.wikipedia.org/wiki/List_of_mathematical_theories",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:31.353027",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:31.353027",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:31.353027",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_mathematical_theories_1_1749013111394_1363",
    "text": "Proof theory Queue theory Ramsey theory Random matrix theory Representation theory Ring theory Scheme theory Semigroup theory Set theory Shape theory Sheaf theory Sieve theory Singularity theory Soliton theory Spectral theory String theory Sturm-Liouville theory Surgery theory Teichmüller theory Theory of equations Theory of statistics Topos theory Transcendental number theory Twistor theory Type theory Wheel theory Retrieved from \" https://en.wikipedia.org/w/index.php?title=List_of_mathematical_theories&oldid=1264822108 \" Categories : Fields of mathematics Mathematics-related lists Hidden categories: Articles with short description Short description is different from Wikidata List of mathematical theories Add",
    "source_url": "https://en.wikipedia.org/wiki/List_of_mathematical_theories",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:31.394803",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:31.394803",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:31.394803",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_unsolved_problems_in_mathematics_1_1749013116027_7003",
    "text": "Over six decades of Erdős' career, from the 1930s to 1990s The Riemann zeta function , subject of the Riemann hypothesis [ 13 ] Millennium Prize Problems Of the original seven Millennium Prize Problems listed by the Clay Mathematics Institute in 2000, six remain unsolved to date: [ 6 ] Birch and Swinnerton-Dyer conjecture Hodge conjecture Navier–Stokes existence and smoothness P versus NP Riemann hypothesis Yang–Mills existence and mass gap The seventh problem, the Poincaré conjecture , was solved by Grigori Perelman in 2003. [ 14 ] However, a generalization called the smooth four-dimensional Poincaré conjecture —that is, whether a four -dimensional topological sphere can have two or more inequivalent smooth structures —is unsolved. [ 15 ] Notebooks The Kourovka Notebook ( Russian : Коуровская тетрадь ) is a collection of unsolved problems in group theory , first published in 1965 and updated many times since.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:36.027000",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:36.027000",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:36.027000",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_unsolved_problems_in_mathematics_1_1749013116053_1816",
    "text": "[ 23 ] Goncharov conjecture on the cohomology of certain motivic complexes . Green's conjecture : the Clifford index of a non- hyperelliptic curve is determined by the extent to which it, as a canonical curve , has linear syzygies . Grothendieck–Katz p-curvature conjecture : a conjectured local–global principle for linear ordinary differential equations . Hadamard conjecture : for every positive integer k {\\displaystyle k} , a Hadamard matrix of order 4 k {\\displaystyle 4k} exists. Williamson conjecture : the problem of finding Williamson matrices, which can be used to construct Hadamard matrices. Hadamard's maximal determinant problem : what is the largest determinant of a matrix with entries all equal to 1 or −1? Hilbert's fifteenth problem : put Schubert calculus on a rigorous foundation. Hilbert's sixteenth problem : what are the possible configurations of the connected components of M-curves ?",
    "source_url": "https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:36.053088",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:36.053088",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:36.053088",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_unsolved_problems_in_mathematics_1_1749013116082_3659",
    "text": "\\displaystyle N(K,g)} of K {\\displaystyle K} - rational points ? Wild problems : problems involving classification of pairs of n × n {\\displaystyle n\\times n} matrices under simultaneous conjugation. Zariski–Lipman conjecture : for a complex algebraic variety V {\\displaystyle V} with coordinate ring R {\\displaystyle R} , if the derivations of R {\\displaystyle R} are a free module over R {\\displaystyle R} , then V {\\displaystyle V} is smooth . Zauner's conjecture: do SIC-POVMs exist in all dimensions? Zilber–Pink conjecture that if X {\\displaystyle X} is a mixed Shimura variety or semiabelian variety defined over C {\\displaystyle \\mathbb {C} } , and V ⊆ X {\\displaystyle V\\subseteq X} is a subvariety, then V {\\displaystyle V} contains only finitely many atypical subvarieties. Group theory Main article: Group theory The free Burnside group B ( 2 , 3 ) {\\displaystyle B(2,3)} is finite; in its Cayley graph , shown here, each of its 27 elements is represented by a vertex.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:36.082160",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:36.082160",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:36.082160",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_unsolved_problems_in_mathematics_1_1749013116103_5282",
    "text": "Analysis Main article: Mathematical analysis The Brennan conjecture : estimating the integral of powers of the moduli of the derivative of conformal maps into the open unit disk, on certain subsets of C {\\displaystyle \\mathbb {C} } Fuglede's conjecture on whether nonconvex sets in R {\\displaystyle \\mathbb {R} } and R 2 {\\displaystyle \\mathbb {R} ^{2}} are spectral if and only if they tile by translation . Goodman's conjecture on the coefficients of multivalued functions Invariant subspace problem – does every bounded operator on a complex Banach space send some non-trivial closed subspace to itself? Kung–Traub conjecture on the optimal order of a multipoint iteration without memory [ 25 ] Lehmer's conjecture on the Mahler measure of non-cyclotomic polynomials [ 26 ]",
    "source_url": "https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:36.103889",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:36.103889",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:36.103889",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_unsolved_problems_in_mathematics_1_1749013116256_2649",
    "text": "[ 71 ] Dissection into orthoschemes – is it possible for simplices of every dimension? [ 72 ] Ehrhart's volume conjecture : a convex body K {\\displaystyle K} in n {\\displaystyle n} dimensions containing a single lattice point in its interior as its center of mass cannot have volume greater than ( n + 1 ) n / n ! {\\displaystyle (n+1)^{n}/n!} Falconer's conjecture : sets of Hausdorff dimension greater than d / 2 {\\displaystyle d/2} in R d {\\displaystyle \\mathbb {R} ^{d}} must have a distance set of nonzero Lebesgue measure [ 73 ] The values of the Hermite constants for dimensions other than 1–8 and 24 What is the lowest number of faces possible for a holyhedron ? Inscribed square problem , also known as Toeplitz' conjecture and the square peg problem – does every Jordan curve have an inscribed square?",
    "source_url": "https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:36.256152",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:36.257369",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:36.257369",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Category:Mathematical_theorems_1_1749013118997_1776",
    "text": "U Uniqueness theorems (12 P) Pages in category \"Mathematical theorems\" The following 44 pages are in this category, out of  44 total. This list may not reflect recent changes . A Additive combinatorics Alexander–Hirschowitz theorem Approximate max-flow min-cut theorem B Bauer maximum principle Blackwell's informativeness theorem Buchdahl's theorem Budan's theorem C Chasles' theorem (kinematics) Classification theorem Comparison theorem E Existence theorem F Fueter–Pólya theorem Full-employment theorem Fundamental theorem of topos theory G Gauss congruence Girsanov theorem Greibach's theorem Grey box model Gurzadyan theorem H Herglotz's variational principle J Jouanolou's trick K Kawasaki's theorem Kostant's convexity theorem L Lawvere's fixed-point theorem M Mathematics of apportionment Maximum theorem Minimax theorem Motzkin–Taussky theorem Multiplication theorem N",
    "source_url": "https://en.wikipedia.org/wiki/Category:Mathematical_theorems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:38.997554",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:38.997554",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:38.997554",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Category:Mathematical_theorems_1_1749013119013_7803",
    "text": "Namioka's theorem No free lunch theorem O Omega-categorical theory P Petersen–Morley theorem R Rank-index method Representation theorem S Shell theorem Solovay–Kitaev theorem Stochastic portfolio theory T Toy theorem Transport theorem Trombi–Varadarajan theorem Tutte homotopy theorem V Vincent's theorem Z Zermelo's theorem (game theory) Retrieved from \" https://en.wikipedia.org/w/index.php?title=Category:Mathematical_theorems&oldid=931520308 \" Categories : Mathematics Theorems Mathematical problems Hidden category: Commons category link is on Wikidata Category : Mathematical theorems Add topic",
    "source_url": "https://en.wikipedia.org/wiki/Category:Mathematical_theorems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:39.013571",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:39.013571",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:39.013571",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_theorems_called_fundamental_1_1749013120302_4405",
    "text": "Jump to content From Wikipedia, the free encyclopedia In mathematics , a fundamental theorem is a theorem which is considered to be central and conceptually important for some topic. For example, the fundamental theorem of calculus gives the relationship between differential calculus and integral calculus . [ 1 ] The names are mostly traditional, so that for example the fundamental theorem of arithmetic is basic to what would now be called number theory . [ 2 ] Some of these are classification theorems of objects which are mainly dealt with in the field. For instance, the fundamental theorem of curves describes classification of regular curves in space up to translation and rotation . Likewise, the mathematical literature sometimes refers to the fundamental lemma of a field. The term lemma is conventionally used to denote a proven proposition which is used as a stepping stone to a larger result, rather than as a useful statement in-and-of itself.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_theorems_called_fundamental",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:40.302915",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:40.302915",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:40.302915",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_theorems_called_fundamental_1_1749013120342_5531",
    "text": "noncommutative algebra Fundamental theorem of projective geometry Fundamental theorem of random fields Fundamental theorem of Riemannian geometry Fundamental theorem of tessarine algebra Fundamental theorem of symmetric polynomials Fundamental theorem of topos theory Fundamental theorem of ultraproducts Fundamental theorem of vector analysis Carl Friedrich Gauss referred to the law of quadratic reciprocity as the \"fundamental theorem\" of quadratic residues",
    "source_url": "https://en.wikipedia.org/wiki/List_of_theorems_called_fundamental",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:40.342170",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:40.342170",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:40.342170",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_theorems_called_fundamental_1_1749013120413_4313",
    "text": "Retrieved from \" https://en.wikipedia.org/w/index.php?title=List_of_theorems_called_fundamental&oldid=1245682194 \" Categories : Mathematics-related lists Theorems Hidden categories: Articles with short description Short description is different from Wikidata Commons category link is on Wikidata List of theorems called fundamental Add topic",
    "source_url": "https://en.wikipedia.org/wiki/List_of_theorems_called_fundamental",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:40.413554",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:40.413554",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:40.413554",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_1_1749013122480_9216",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is a list of notable mathematical conjectures . Open problems [ edit ] The following conjectures remain open. The (incomplete) column \"cites\" lists the number of results for a Google Scholar search for the term, in double quotes as of September 2022 [update] . Conjecture Field Comments Eponym(s) Cites 1/3–2/3 conjecture order theory n/a 70 abc conjecture number theory ⇔Granville–Langevin conjecture, Vojta's conjecture in dimension 1 ⇒ Erdős–Woods conjecture , Fermat–Catalan conjecture Formulated by David Masser and Joseph Oesterlé . [ 1 ] Proof claimed in 2012 by Shinichi Mochizuki n/a 2440 Agoh–Giuga conjecture number theory Takashi Agoh and Giuseppe Giuga 8",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:42.480477",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:42.480477",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:42.480477",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_1_1749013122503_5180",
    "text": "Agrawal's conjecture number theory Manindra Agrawal 10 Andrews–Curtis conjecture combinatorial group theory James J. Andrews and Morton L. Curtis 358 Andrica's conjecture number theory Dorin Andrica 45 Artin conjecture (L-functions) number theory Emil Artin 650 Artin's conjecture on primitive roots number theory ⇐ generalized Riemann hypothesis [ 2 ] ⇐ Selberg conjecture B [ 3 ] Emil Artin 325 Bateman–Horn conjecture number theory Paul T. Bateman and Roger Horn 245 Baum–Connes conjecture operator K-theory ⇒ Gromov-Lawson-Rosenberg conjecture [ 4 ] ⇒ Kaplansky-Kadison conjecture [ 4 ] ⇒ Novikov conjecture [ 4 ] Paul Baum and Alain Connes 2670 Beal's conjecture number theory Andrew Beal 142 Beilinson conjecture number theory Alexander Beilinson 461 Berry–Tabor conjecture geodesic flow Michael Berry and Michael Tabor 239",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:42.503659",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:42.503659",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:42.503659",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_1_1749013122542_1363",
    "text": "208 Bunyakovsky conjecture number theory Viktor Bunyakovsky 43 Carathéodory conjecture differential geometry Constantin Carathéodory 173 Carmichael totient conjecture number theory Robert Daniel Carmichael Casas-Alvero conjecture polynomials Eduardo Casas-Alvero 56 Catalan–Dickson conjecture on aliquot sequences number theory Eugène Charles Catalan and Leonard Eugene Dickson 46 Catalan's Mersenne conjecture number theory Eugène Charles Catalan Cherlin–Zilber conjecture group theory Gregory Cherlin and Boris Zilber 86 Chowla conjecture Möbius function ⇒ Sarnak conjecture [ 6 ] [ 7 ] Sarvadaman Chowla Collatz conjecture number theory",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:42.542714",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:42.542714",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:42.543707",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_1_1749013122558_8251",
    "text": "Lothar Collatz 1440 Cramér's conjecture number theory Harald Cramér 32 Conway's thrackle conjecture graph theory John Horton Conway 150 Deligne conjecture monodromy Pierre Deligne 788 Dittert conjecture combinatorics Eric Dittert 11 Eilenberg−Ganea conjecture algebraic topology Samuel Eilenberg and Tudor Ganea 96 Elliott–Halberstam conjecture number theory Peter D. T. A. Elliott and Heini Halberstam 300 Erdős–Faber–Lovász conjecture graph theory Paul Erdős , Vance Faber , and László Lovász 172 Erdős–Gyárfás conjecture graph theory Paul Erdős and András Gyárfás 37",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:42.558974",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:42.558974",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:42.558974",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_1_1749013122578_9790",
    "text": "Erdős–Straus conjecture number theory Paul Erdős and Ernst G. Straus 103 Farrell–Jones conjecture geometric topology F. Thomas Farrell and Lowell E. Jones 545 Filling area conjecture differential geometry n/a 60 Firoozbakht's conjecture number theory Farideh Firoozbakht 33 Fortune's conjecture number theory Reo Fortune 16 Four exponentials conjecture number theory n/a 110 Frankl conjecture combinatorics Péter Frankl 83 Gauss circle problem number theory Carl Friedrich Gauss 553 Gilbert–Pollack conjecture on the Steiner ratio of the Euclidean plane metric geometry Edgar Gilbert and Henry O. Pollak Gilbreath conjecture number theory Norman Laurence Gilbreath 34 Goldbach's conjecture number theory ⇒The ternary Goldbach conjecture , which was the original formulation.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:42.578051",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:42.578051",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:42.578051",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_1_1749013122601_5022",
    "text": "[ 8 ] Christian Goldbach 5880 Gold partition conjecture [ 9 ] order theory n/a 25 Goldberg–Seymour conjecture graph theory Mark K. Goldberg and Paul Seymour 57 Goormaghtigh conjecture number theory René Goormaghtigh 14 Green's conjecture algebraic curves Mark Lee Green 150 Grimm's conjecture number theory Carl Albert Grimm 46 Grothendieck–Katz p-curvature conjecture differential equations Alexander Grothendieck and Nick Katz 98 Hadamard conjecture combinatorics Jacques Hadamard 858 Herzog–Schönheim conjecture group theory Marcel Herzog and Jochanan Schönheim 44 Hilbert–Smith conjecture geometric topology David Hilbert and Paul Althaus Smith 219 Hodge conjecture algebraic geometry W. V. D. Hodge 2490 Homological conjectures in commutative algebra commutative algebra n/a Hopf conjectures geometry Heinz Hopf 476 Ibragimov–Iosifescu conjecture for φ-mixing sequences probability theory Ildar Ibragimov , ro:Marius Iosifescu Invariant subspace problem functional analysis n/a 2120 Jacobian",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:42.601948",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:42.601948",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:42.601948",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_1_1749013122635_9315",
    "text": "John Edensor Littlewood 1230 Lovász conjecture graph theory László Lovász 560 MNOP conjecture algebraic geometry n/a 63 Manin conjecture diophantine geometry Yuri Manin 338 Marshall Hall's conjecture number theory Marshall Hall, Jr. 44 Mazur's conjectures diophantine geometry Barry Mazur 97 Montgomery's pair correlation conjecture number theory Hugh Lowell Montgomery 77 n conjecture number theory n/a 126 New Mersenne conjecture number theory Marin Mersenne 47",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:42.635400",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:42.635400",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:42.635400",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Unifying_theories_in_mathematics_1_1749013125303_2568",
    "text": "In particular, this perspective placed little value on fields of mathematics (such as combinatorics ) whose objects of study are very often special, or found in situations which can only superficially be related to more axiomatic branches of the subject. Category theory as a rival [ edit ] Category theory is a unifying theory of mathematics that was initially developed in the second half of the 20th century. [ 4 ] In this respect, it is an alternative and complement to set theory. A key theme from the \"categorical\" point of view is that mathematics requires not only certain kinds of objects ( Lie groups , Banach spaces , etc.) but also mappings between them that preserve their structure. In particular, this clarifies exactly what it means for mathematical objects to be considered to be the same . (For example, are all equilateral triangles the same , or does size matter?)",
    "source_url": "https://en.wikipedia.org/wiki/Unifying_theories_in_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:45.303853",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:45.304852",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:45.304852",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Unifying_theories_in_mathematics_1_1749013125354_4196",
    "text": "We have already noted the example of analytic geometry, and more generally the field of algebraic geometry thoroughly develops the connections between geometric objects ( algebraic varieties , or more generally schemes ) and algebraic ones ( ideals ); the touchstone result here is Hilbert's Nullstellensatz , which roughly speaking shows that there is a natural one-to-one correspondence between the two types of objects. One may view other theorems in the same light. For example, the fundamental theorem of Galois theory asserts that there is a one-to-one correspondence between extensions of a field and subgroups of the field's Galois group . The Taniyama–Shimura conjecture for elliptic curves (now proven) establishes a one-to-one correspondence between curves defined as modular forms and elliptic curves defined over the rational numbers .",
    "source_url": "https://en.wikipedia.org/wiki/Unifying_theories_in_mathematics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:58:45.354565",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:58:45.354565",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:58:45.354565",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Post%E2%80%93Turing_machine_1_1749013145347_5712",
    "text": "Jump to content From Wikipedia, the free encyclopedia Abstract calculator This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article contains instructions, advice, or how-to content . Please help rewrite the content so that it is more encyclopedic or move it to Wikiversity , Wikibooks , or Wikivoyage . ( August 2020 ) This article is written like a research paper or a scientific journal . Please",
    "source_url": "https://en.wikipedia.org/wiki/Post%E2%80%93Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:59:05.347490",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:59:05.347490",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:59:05.347490",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Raita_algorithm_1_1749013146139_8291",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) The topic of this article may not meet Wikipedia's general notability guideline . Please help to demonstrate the notability of the topic by citing reliable secondary sources that are independent of the topic and provide significant coverage of it beyond a mere trivial mention. If notability cannot",
    "source_url": "https://en.wikipedia.org/wiki/Raita_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:59:06.139193",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:59:06.139193",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:59:06.139193",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=List_of_terms_relating_to_algorithms_and_data_structures&oldid=1289141319_1_1749013151473_4373",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by YiFeiBot ( talk | contribs ) at 18:46, 6 May 2025 (Bot: Migrating 1 langlinks, now provided by Wikidata on d:q16002499 ) . The present address (URL) is a permanent link to this version. Revision as of 18:46, 6 May 2025 by YiFeiBot ( talk | contribs ) (Bot: Migrating 1 langlinks, now provided by Wikidata on d:q16002499 ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revisi",
    "source_url": "https://en.wikipedia.org/w/index.php?title=List_of_terms_relating_to_algorithms_and_data_structures&oldid=1289141319",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:59:11.473703",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:59:11.473703",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:59:11.473703",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Computational_complexity_of_mathematical_operations_1_1749013163215_3542",
    "text": "\\displaystyle O(n\\log n)} Division Two n {\\displaystyle n} -digit numbers One n {\\displaystyle n} -digit number Schoolbook long division O ( n 2 ) {\\displaystyle O{\\mathord {\\left(n^{2}\\right)}}} Burnikel–Ziegler Divide-and-Conquer Division [ 5 ] O ( M ( n ) log ⁡ n ) {\\displaystyle O(M(n)\\log n)} Newton–Raphson division O ( M ( n ) ) {\\displaystyle O(M(n)) } Square root One n {\\displaystyle n} -digit number One n / 2 {\\displaystyle n/2} -digit number Newton's method O ( M ( n ) ) {\\displaystyle O(M(n))",
    "source_url": "https://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:59:23.215739",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:59:23.215739",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:59:23.215739",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Binary_search_algorithm_1_1749013174827_1214",
    "text": "If L > R {\\displaystyle L>R} , the search terminates as unsuccessful. Set m {\\displaystyle m} (the position of the middle element) to L {\\displaystyle L} plus the floor of R − L 2 {\\displaystyle {\\frac {R-L}{2}}} , which is the greatest integer less than or equal to R − L 2 {\\displaystyle {\\frac {R-L}{2}}} . If A m < T {\\displaystyle A_{m}<T} , set L {\\displaystyle L} to m + 1 {\\displaystyle m+1} and go to step 2. If A m > T {\\displaystyle A_{m}>T} , set R {\\displaystyle R} to m − 1 {\\displaystyle m-1} and go to step 2. Now A m = T {\\displaystyle A_{m}=T} , the search is done; return m {\\displaystyle m} . This iterative procedure keeps track of the search boundaries with the two variables L {\\displaystyle L} and R {\\displaystyle R} . The procedure may be expressed in pseudocode as follows, where the variable names and types remain the same as above, floor is the floor function , and unsuccessful refers to a specific value that conveys the failure of the search.",
    "source_url": "https://en.wikipedia.org/wiki/Binary_search_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:59:34.827375",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:59:34.827375",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:59:34.827375",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Binary_search_algorithm_1_1749013174994_8533",
    "text": "In the above example, the 4th element is the leftmost element of the value 4, while the 5th element is the rightmost element of the value 4. The alternative procedure above will always return the index of the rightmost element if such an element exists. [ 9 ] Procedure for finding the leftmost element [ edit ] To find the leftmost element, the following procedure can be used: [ 10 ] Set L {\\displaystyle L} to 0 {\\displaystyle 0} and R {\\displaystyle R} to n {\\displaystyle n} . While L < R {\\displaystyle L<R} , Set m {\\displaystyle m} (the position of the middle element) to L {\\displaystyle L} plus the floor of R − L 2 {\\displaystyle {\\frac {R-L}{2}}} , which is the greatest integer less than or equal to R − L 2 {\\displaystyle {\\frac {R-L}{2}}} . If A m < T {\\displaystyle A_{m}<T} , set L {\\displaystyle L} to m + 1 {\\displaystyle m+1} . Else, A m ≥ T {\\displaystyle A_{m}\\geq T} ; set R {\\displaystyle R} to m {\\displaystyle m} . Return L {\\displaystyle L} .",
    "source_url": "https://en.wikipedia.org/wiki/Binary_search_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:59:34.994600",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:59:34.994600",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:59:34.994600",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Binary_GCD_algorithm_1_1749013179316_6415",
    "text": "= v {\\displaystyle \\gcd(0,v)=v} , gcd ( 2 u , v ) = gcd ( u , v ) {\\displaystyle \\gcd(2u,v)=\\gcd(u,v)} if v {\\displaystyle v} is odd, etc.",
    "source_url": "https://en.wikipedia.org/wiki/Binary_GCD_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:59:39.316214",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:59:39.316214",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:59:39.316214",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Geometric_Folding_Algorithms_1_1749013194148_5501",
    "text": "[ 6 ] It is a monograph rather than a textbook, and in particular does not include sets of exercises. [ 4 ] The Basic Library List Committee of the Mathematical Association of America has recommended this book for inclusion in undergraduate mathematics libraries. [ 1 ] Topics and organization [ edit ] The book is organized into three sections, on linkages, origami, and polyhedra. [ 1 ] [ 2 ] Topics in the section on linkages include\nthe Peaucellier–Lipkin linkage for converting rotary motion into linear motion, [ 4 ] Kempe's universality theorem that any algebraic curve can be traced out by a linkage, [ 1 ] [ 4 ] the existence of linkages for angle trisection , [ 1 ] and the carpenter's rule problem on straightening two-dimensional polygonal chains . [ 4 ] This part of the book also includes applications to motion planning for robotic arms , and to protein folding . [ 1 ] [ 2 ] The second section of the book concerns the mathematics of paper folding , and mathematical origami .",
    "source_url": "https://en.wikipedia.org/wiki/Geometric_Folding_Algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:59:54.148072",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:59:54.148072",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:59:54.148072",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Geometric_Folding_Algorithms_1_1749013194169_1696",
    "text": "It includes the NP-completeness of testing flat foldability, [ 2 ] the problem of map folding (determining whether a pattern of mountain and valley folds forming a square grid can be folded flat), [ 2 ] [ 4 ] the work of Robert J. Lang using tree structures and circle packing to automate the design of origami folding patterns, [ 2 ] [ 4 ] the fold-and-cut theorem according to which any polygon can be constructed by folding a piece of paper and then making a single straight cut, [ 2 ] [ 4 ] origami-based angle trisection, [ 4 ] rigid origami , [ 2 ] and the work of David A. Huffman on curved folds.",
    "source_url": "https://en.wikipedia.org/wiki/Geometric_Folding_Algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:59:54.169091",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:59:54.169091",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:59:54.169091",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Geometric_Folding_Algorithms&oldid=1267520922_1_1749013194761_7061",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by MichaelMaggs ( talk | contribs ) at 13:48, 5 January 2025 (Adding short description : \"2007 mathematics book by Demaine and O'Rourke\") . The present address (URL) is a permanent link to this version. Revision as of 13:48, 5 January 2025 by MichaelMaggs ( talk | contribs ) (Adding short description : \"2007 mathematics book by Demaine and O'Rourke\") ( diff ) ← Previous revision | Latest re",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Geometric_Folding_Algorithms&oldid=1267520922",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:59:54.761182",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:59:54.761182",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:59:54.761182",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithmic_number_theory_1_1749013196159_4347",
    "text": "theorem Bring's curve Bolza surface Compact Riemann surface Dessin d'enfant Differential of the first",
    "source_url": "https://en.wikipedia.org/wiki/Algorithmic_number_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T04:59:56.159871",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T04:59:56.159871",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T04:59:56.159871",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Risch_algorithm_1_1749013214276_1551",
    "text": "Jump to content From Wikipedia, the free encyclopedia Method for evaluating indefinite integrals Part of a series of articles about Calculus ∫ a b f ′ ( t ) d t = f ( b ) − f ( a ) {\\displaystyle \\int _{a}^{b}f'(t)\\,dt=f(b)-f(a)} Fundamental theorem Limits Continuity Rolle's theorem Mean value theorem Inverse function theorem Differential Definitions Derivative ( generalizations ) Differential infinitesimal of a function total Concepts Differentiation notation Second derivative Implicit differen",
    "source_url": "https://en.wikipedia.org/wiki/Risch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:00:14.276539",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:00:14.278049",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:00:14.278049",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Analysis_of_algorithms&oldid=1286246799_1_1749013222308_8166",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Widefox ( talk | contribs ) at 17:34, 18 April 2025 ( → See also : already in body per WP:SEEALSO / WP:OVERLINK ) . The present address (URL) is a permanent link to this version. Revision as of 17:34, 18 April 2025 by Widefox ( talk | contribs ) ( → See also : already in body per WP:SEEALSO / WP:OVERLINK ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) St",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Analysis_of_algorithms&oldid=1286246799",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:00:22.308220",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:00:22.308220",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:00:22.308220",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Multitape_Turing_machine_1_1749013233742_3848",
    "text": "[ 2 ] Thus, multi-tape machines cannot calculate any more functions than single-tape machines, [ 3 ] and none of the robust complexity classes (such as polynomial time ) are affected by a change between single-tape and multi-tape machines.",
    "source_url": "https://en.wikipedia.org/wiki/Multitape_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:00:33.742628",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:00:33.742628",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:00:33.742628",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749013264936_3676",
    "text": "= a T ( n b ) + f ( n ) {\\displaystyle T(n)=a\\;T\\!\\left({\\frac {n}{b}}\\right)+f(n)} Here n {\\displaystyle n} is the size of an input problem, a {\\displaystyle a} is the number of subproblems in the recursion, and b {\\displaystyle b} is the factor by which the subproblem size is reduced in each recursive call ( b > 1 {\\displaystyle b>1} ). Crucially, a {\\displaystyle a} and b {\\displaystyle b} must not depend on n {\\displaystyle n} . The theorem below also assumes that, as a base case for the recurrence, T ( n ) = Θ ( 1 ) {\\displaystyle T(n)=\\Theta (1)} when n {\\displaystyle n} is less than some bound κ > 0 {\\displaystyle \\kappa >0} , the smallest input size that will lead to a recursive call. Recurrences of this form often satisfy one of the three following regimes, based on how the work to split/recombine the problem f ( n ) {\\displaystyle f(n)} relates to the critical exponent c crit = log b ⁡ a {\\displaystyle c_{\\operatorname {crit} }=\\log _{b}a} .",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:04.936165",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:04.936165",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:04.936165",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749013264965_6392",
    "text": "(The table below uses standard big O notation ). Throughout, ( log ⁡ n ) k {\\displaystyle (\\log n)^{k}} is used for clarity, though in textbooks this is usually rendered log k ⁡ n {\\displaystyle \\log ^{k}n} . c crit = log b ⁡ a = log ⁡ ( # subproblems ) / log ⁡ ( relative subproblem size ) {\\displaystyle c_{\\operatorname {crit} }=\\log _{b}a=\\log(\\#{\\text{subproblems}})/\\log({\\text{relative subproblem size}})} Case Description Condition on f ( n ) {\\displaystyle f(n)} in relation to c crit {\\displaystyle c_{\\operatorname {crit} }} , i.e. log b ⁡ a {\\displaystyle \\log _{b}a} Master Theorem bound Notational examples 1 Work to split/recombine a problem is dominated by subproblems. i.e. the recursion tree is leaf-heavy. When f ( n ) = O ( n c ) {\\displaystyle f(n)=O(n^{c})} where c < c crit {\\displaystyle c<c_{\\operatorname {crit} }} (upper-bounded by a lesser exponent polynomial) ...",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:04.965123",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:04.966116",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:04.966116",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749013264997_3427",
    "text": "then T ( n ) = Θ ( n c crit ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}\\right)} (The splitting term does not appear; the recursive tree structure dominates.) If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = O ( n 1 / 2 − ϵ ) {\\displaystyle f(n)=O(n^{1/2-\\epsilon })} , then T ( n ) = Θ ( n 1 / 2 ) {\\displaystyle T(n)=\\Theta (n^{1/2})} . 2 Work to split/recombine a problem is comparable to subproblems. When f ( n ) = Θ ( n c crit ( log ⁡ n ) k ) {\\displaystyle f(n)=\\Theta (n^{c_{\\operatorname {crit} }}(\\log n)^{k})} for a k ≥ 0 {\\displaystyle k\\geq 0} (rangebound by the critical-exponent polynomial, times zero or more optional log {\\displaystyle \\log } s) ... then T ( n ) = Θ ( n c crit ( log ⁡ n ) k + 1 ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}(\\log n)^{k+1}\\right)} (The bound is the splitting term, where the log is augmented by a single power.)",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:04.997393",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:04.997393",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:04.997393",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749013265027_2700",
    "text": "If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 ) {\\displaystyle f(n)=\\Theta (n^{1/2})} , then T ( n ) = Θ ( n 1 / 2 log ⁡ n ) {\\displaystyle T(n)=\\Theta (n^{1/2}\\log n)} . If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 log ⁡ n ) {\\displaystyle f(n)=\\Theta (n^{1/2}\\log n)} , then T ( n ) = Θ ( n 1 / 2 ( log ⁡ n ) 2 ) {\\displaystyle T(n)=\\Theta (n^{1/2}(\\log n)^{2})} . 3 Work to split/recombine a problem dominates subproblems. i.e. the recursion tree is root-heavy. When f ( n ) = Ω ( n c ) {\\displaystyle f(n)=\\Omega (n^{c})} where c > c crit {\\displaystyle c>c_{\\operatorname {crit} }} (lower-bounded by a greater-exponent polynomial) ... this doesn't necessarily yield anything.",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:05.027315",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:05.027315",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:05.027315",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749013265059_3577",
    "text": "this doesn't necessarily yield anything. Furthermore, if a f ( n b ) ≤ k f ( n ) {\\displaystyle af\\left({\\frac {n}{b}}\\right)\\leq kf(n)} for some constant k < 1 {\\displaystyle k<1} and all sufficiently large n {\\displaystyle n} (often called the regularity condition ) then the total is dominated by the splitting term f ( n ) {\\displaystyle f(n)} : T ( n ) = Θ ( f ( n ) ) {\\displaystyle T\\left(n\\right)=\\Theta \\left(f(n)\\right)} If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Ω ( n 1 / 2 + ϵ ) {\\displaystyle f(n)=\\Omega (n^{1/2+\\epsilon })} and the regularity condition holds, then T ( n ) = Θ ( f ( n ) ) {\\displaystyle T(n)=\\Theta (f(n))} . A useful extension of Case 2 handles all values of k {\\displaystyle k} : [ 3 ] Case Condition on f ( n ) {\\displaystyle f(n)} in relation to c crit {\\displaystyle c_{\\operatorname {crit} }} , i.e. log b ⁡ a {\\displaystyle \\log _{b}a} Master Theorem bound Notational examples 2a",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:05.059260",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:05.060377",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:05.060377",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749013265097_2579",
    "text": "When f ( n ) = Θ ( n c crit ( log ⁡ n ) k ) {\\displaystyle f(n)=\\Theta (n^{c_{\\operatorname {crit} }}(\\log n)^{k})} for any k > − 1 {\\displaystyle k>-1} ... then T ( n ) = Θ ( n c crit ( log ⁡ n ) k + 1 ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}(\\log n)^{k+1}\\right)} (The bound is the splitting term, where the log is augmented by a single power.) If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 / ( log ⁡ n ) 1 / 2 ) {\\displaystyle f(n)=\\Theta (n^{1/2}/(\\log n)^{1/2})} , then T ( n ) = Θ ( n 1 / 2 ( log ⁡ n ) 1 / 2 ) {\\displaystyle T(n)=\\Theta (n^{1/2}(\\log n)^{1/2})} . 2b When f ( n ) = Θ ( n c crit ( log ⁡ n ) k ) {\\displaystyle f(n)=\\Theta (n^{c_{\\operatorname {crit} }}(\\log n)^{k})} for k = − 1 {\\displaystyle k=-1} ... then T ( n ) = Θ ( n c crit log ⁡ log ⁡ n ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}\\log \\log n\\right)} (The bound is the splitting term, where the log reciprocal is replaced by an iterated log.)",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:05.097632",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:05.097632",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:05.098635",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749013265133_3757",
    "text": "If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 / log ⁡ n ) {\\displaystyle f(n)=\\Theta (n^{1/2}/\\log n)} , then T ( n ) = Θ ( n 1 / 2 log ⁡ log ⁡ n ) {\\displaystyle T(n)=\\Theta (n^{1/2}\\log \\log n)} . 2c When f ( n ) = Θ ( n c crit ( log ⁡ n ) k ) {\\displaystyle f(n)=\\Theta (n^{c_{\\operatorname {crit} }}(\\log n)^{k})} for any k < − 1 {\\displaystyle k<-1} ... then T ( n ) = Θ ( n c crit ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}\\right)} (The bound is the splitting term, where the log disappears.) If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 / ( log ⁡ n ) 2 ) {\\displaystyle f(n)=\\Theta (n^{1/2}/(\\log n)^{2})} , then T ( n ) = Θ ( n 1 / 2 ) {\\displaystyle T(n)=\\Theta (n^{1/2})} . Examples [ edit ] Case 1 example [ edit ] T ( n ) = 8 T ( n 2 ) + 1000 n 2 {\\displaystyle T(n)=8T\\left({\\frac {n}{2}}\\right)+1000n^{2}} As one can see from the formula above:",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:05.133311",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:05.133311",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:05.133311",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662_1_1749013266097_7108",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Zhermes ( talk | contribs ) at 18:28, 27 February 2025 ( → Introduction : clarify what variable 'b' is) . The present address (URL) is a permanent link to this version. Revision as of 18:28, 27 February 2025 by Zhermes ( talk | contribs ) ( → Introduction : clarify what variable 'b' is) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Tool for analyzing div",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:06.097959",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:06.098959",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:06.098959",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithmic_efficiency&oldid=1286247421_1_1749013276198_5221",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Widefox ( talk | contribs ) at 17:38, 18 April 2025 ( → top : fix sect WP:ORDER , fix hatnote) . The present address (URL) is a permanent link to this version. Revision as of 17:38, 18 April 2025 by Widefox ( talk | contribs ) ( → top : fix sect WP:ORDER , fix hatnote) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Not to be confused with program optimiza",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithmic_efficiency&oldid=1286247421",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:16.198302",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:16.199305",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:16.199305",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Atlantic_City_algorithm_1_1749013280902_4816",
    "text": "Jump to content From Wikipedia, the free encyclopedia You can help expand this article with text translated from the corresponding article in French . (June 2022) Click [show] for important translation instructions. View a machine-translated version of the French article. Machine translation, like DeepL or Google Translate , is a useful starting point for translations, but translators must revise errors as necessary and confirm that the translation is accurate, rather than simply copy-pasting ma",
    "source_url": "https://en.wikipedia.org/wiki/Atlantic_City_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:20.902056",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:20.902056",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:20.902056",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Randomized_algorithm&oldid=1276591468_1_1749013281242_1311",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by WikiCleanerBot ( talk | contribs ) at 18:46, 19 February 2025 (v2.05b - Bot T20 CW#61 - Fix errors for CW project (Reference before punctuation)) . The present address (URL) is a permanent link to this version. Revision as of 18:46, 19 February 2025 by WikiCleanerBot ( talk | contribs ) (v2.05b - Bot T20 CW#61 - Fix errors for CW project (Reference before punctuation)) ( diff ) ← Previou",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Randomized_algorithm&oldid=1276591468",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:21.242811",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:21.242811",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:21.242811",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Analysis_of_algorithms&oldid=936082453_1_1749013283888_9331",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Allforrous ( talk | contribs ) at 16:16, 16 January 2020 (Commonscat and Cat main templates.) . The present address (URL) is a permanent link to this version. Revision as of 16:16, 16 January 2020 by Allforrous ( talk | contribs ) (Commonscat and Cat main templates.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Wikimedia Commons has media related t",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Analysis_of_algorithms&oldid=936082453",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:23.888589",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:23.888589",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:23.888589",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quantum_Turing_machine_1_1749013292145_4114",
    "text": "amplification Bernstein–Vazirani BHT Boson sampling Deutsch–Jozsa Grover's HHL Hidden subgroup Magic state distillation Quantum annealing Quantum counting Quantum Fourier transform Quantum optimization Quantum phase estimation Shor's Simon's VQE Quantum complexity theory BQP DQC1 EQP QIP QMA",
    "source_url": "https://en.wikipedia.org/wiki/Quantum_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:32.145699",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:32.145699",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:32.145699",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Symmetric_Turing_machine_1_1749013294218_9457",
    "text": "If D is left , then the head of a machine in state p above a tape symbol b preceded by a symbol a can be transitioned by moving the head left, changing the state to q and replacing the symbols a,b by c,d . The opposite transition ⁠ ( q , c d , − D , a b , p ) {\\displaystyle (q,cd,-D,ab,p)} ⁠ can always be applied. If D is right the transition is analogous. The ability to peek at two symbols and change both at a time is non-essential, but makes the definition easier. Such machines were first defined in 1982 by Harry R. Lewis and Christos Papadimitriou , [ 1 ] [ 2 ] who were looking for a class in which to place USTCON , the problem asking whether there is a path between two given vertices s,t in an undirected graph. Until this time, it could be placed only in NL , despite seeming not to require nondeterminism (the asymmetric variant STCON was known to be complete for NL).",
    "source_url": "https://en.wikipedia.org/wiki/Symmetric_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:34.218458",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:34.218458",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:34.218458",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Alternating_Turing_machine_1_1749013296357_4778",
    "text": "Q × Γ → P ( Q × Γ × { L , R } ) {\\displaystyle \\delta :Q\\times \\Gamma \\rightarrow {\\mathcal {P}}(Q\\times \\Gamma \\times \\{L,R\\})} is called the transition function ( L shifts the head left and R shifts the head right) q 0 ∈ Q {\\displaystyle q_{0}\\in Q} is the initial state g : Q → { ∧ , ∨ , a c c e p t , r e j e c t } {\\displaystyle g:Q\\rightarrow \\{\\wedge ,\\vee ,accept,reject\\}} specifies the type of each state If M is in a state q ∈ Q {\\displaystyle q\\in Q} with g ( q ) = a c c e p t {\\displaystyle g(q)=accept} then that configuration is said to be accepting , and if g ( q ) = r e j e c t {\\displaystyle g(q)=reject} the configuration is said to be rejecting . A configuration with g ( q ) = ∧ {\\displaystyle g(q)=\\wedge } is said to be accepting if all configurations reachable in one step are accepting, and rejecting if some configuration reachable in one step is rejecting.",
    "source_url": "https://en.wikipedia.org/wiki/Alternating_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:36.357401",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:36.358405",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:36.358405",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Alternating_Turing_machine_1_1749013296416_1158",
    "text": "In particular, an existential configuration can be labelled as accepting if any successor configuration is found to be accepting, and a universal configuration can be labelled as rejecting if any successor configuration is found to be rejecting. An ATM decides a formal language in time t ( n ) {\\displaystyle t(n)} if, on any input of length n , examining configurations only up to t ( n ) {\\displaystyle t(n)} steps is sufficient to label the initial configuration as accepting or rejecting. An ATM decides a language in space s ( n ) {\\displaystyle s(n)} if examining configurations that do not modify tape cells beyond the s ( n ) {\\displaystyle s(n)} cell from the left is sufficient. A language that is decided by some ATM in time c ⋅ t ( n ) {\\displaystyle c\\cdot t(n)} for some constant c > 0 {\\displaystyle c>0} is said to be in the class A T I M E ( t ( n ) )",
    "source_url": "https://en.wikipedia.org/wiki/Alternating_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:36.416731",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:36.417259",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:36.417259",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Alternating_Turing_machine_1_1749013296443_6562",
    "text": "( t ( n ) ) {\\displaystyle {\\mathsf {ATIME}}(t(n))} , and a language decided in space c ⋅ s ( n ) {\\displaystyle c\\cdot s(n)} is said to be in the class A S P A C E ( s ( n ) ) {\\displaystyle {\\mathsf {ASPACE}}(s(n))} . Example [ edit ] Perhaps the most natural problem for alternating machines to solve is the quantified Boolean formula problem , which is a generalization of the Boolean satisfiability problem in which each variable can be bound by either an existential or a universal quantifier. The alternating machine branches existentially to try all possible values of an existentially quantified variable and universally to try all possible values of a universally quantified variable, in the left-to-right order in which they are bound. After deciding a value for all quantified variables, the machine accepts if the resulting Boolean formula evaluates to true, and rejects if it evaluates to false.",
    "source_url": "https://en.wikipedia.org/wiki/Alternating_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:36.443936",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:36.443936",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:36.443936",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simple_continued_fraction_1_1749013309041_5905",
    "text": "Jump to content From Wikipedia, the free encyclopedia Number represented as a0+1/(a1+1/...) \"Recurring fraction\" redirects here and is not to be confused with Repeating decimal . A simple or regular continued fraction is a continued fraction with numerators all equal one, and denominators built from a sequence { a i } {\\displaystyle \\{a_{i}\\}} of integer numbers. The sequence can be finite or infinite, resulting in a finite (or terminated ) continued fraction like a 0 + 1 a 1 + 1 a 2 + 1 ⋱ + 1 a",
    "source_url": "https://en.wikipedia.org/wiki/Simple_continued_fraction",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:49.041046",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:49.041046",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:49.041046",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Shor%27s_algorithm&oldid=1289663168_1_1749013309560_5457",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by ClintonPortishead ( talk | contribs ) at 01:39, 10 May 2025 (Removed reference to Qiskit, which is a software product developed by one quantum computing vendor. Wikipedia should not be a place for product pitches or favoritism.) . The present address (URL) is a permanent link to this version. Revision as of 01:39, 10 May 2025 by ClintonPortishead ( talk | contribs ) (Removed reference to",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Shor%27s_algorithm&oldid=1289663168",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:49.560914",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:49.560914",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:49.560914",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Euclidean_algorithm_1_1749013313273_3783",
    "text": "A 24×60 rectangle is covered with ten 12×12 square tiles, where 12 is the GCD of 24 and 60. More generally, an a × b rectangle can be covered with square tiles of side-length c only if c is a common divisor of a and b . Let g = gcd( a , b ) . Since a and b are both multiples of g , they can be written a = mg and b = ng , and there is no larger number G > g for which this is true. The natural numbers m and n must be coprime, since any common factor could be factored out of m and n to make g greater. Thus, any other number c that divides both a and b must also divide g . The greatest common divisor g of a and b is the unique (positive) common divisor of a and b that is divisible by any other common divisor c . [ 6 ] The greatest common divisor can be visualized as follows. [ 7 ] Consider a rectangular area a by b , and any common divisor c that divides both a and b exactly.",
    "source_url": "https://en.wikipedia.org/wiki/Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:53.273244",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:53.274237",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:53.274237",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Euclidean_algorithm_1_1749013313448_9085",
    "text": "This determines r 0 = 147 {\\displaystyle r_{0}=147} and so the sequence is now { 1071 , 462 , r 0 = 147 } {\\displaystyle \\{1071,\\ 462,\\ r_{0}=147\\}} . The next step is to continue the sequence to find r 1 {\\displaystyle r_{1}} by finding integers q 1 {\\displaystyle q_{1}} and r 1 < r 0 {\\displaystyle r_{1}<r_{0}} such that: 462 = q 1 ⋅ 147 + r 1 {\\displaystyle 462=q_{1}\\cdot 147+r_{1}} . This is the quotient q 1 = 3 {\\displaystyle q_{1}=3} since 462 = 3 ⋅ 147 + 21 {\\displaystyle 462=3\\cdot 147+21} . This determines r 1 = 21 {\\displaystyle r_{1}=21} and so the sequence is now { 1071 , 462 , 147 , r 1 = 21 } {\\displaystyle \\{1071,\\ 462,\\ 147,\\ r_{1}=21\\}} . The next step is to continue the sequence to find r 2 {\\displaystyle r_{2}} by finding integers q 2 {\\displaystyle q_{2}} and r 2 < r 1 {\\displaystyle r_{2}<r_{1}} such that: 147 = q 2 ⋅ 21 + r 2 {\\displaystyle 147=q_{2}\\cdot 21+r_{2}} .",
    "source_url": "https://en.wikipedia.org/wiki/Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:53.448940",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:53.448940",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:53.448940",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Euclidean_algorithm_1_1749013313521_4829",
    "text": "r N −2 = q N r N −1 since the final remainder r N is zero. r N −1 also divides its next predecessor r N −3 r N −3 = q N −1 r N −2 + r N −1 because it divides both terms on the right-hand side of the equation. Iterating the same argument, r N −1 divides all the preceding remainders, including a and b . None of the preceding remainders r N −2 , r N −3 , etc. divide a and b , since they leave a remainder. Since r N −1 is a common divisor of a and b , r N −1 ≤ g . In the second step, any natural number c that divides both a and b (in other words, any common divisor of a and b ) divides the remainders r k . By definition, a and b can be written as multiples of c : a = mc and b = nc , where m and n are natural numbers. Therefore, c divides the initial remainder r 0 , since r 0 = a − q 0 b = mc − q 0 nc = ( m − q 0 n ) c . An analogous argument shows that c also divides the subsequent remainders r 1 , r 2 , etc.",
    "source_url": "https://en.wikipedia.org/wiki/Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:53.521516",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:53.521516",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:53.521516",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Euclidean_algorithm&oldid=1288126959_1_1749013317168_2924",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Citation bot ( talk | contribs ) at 16:35, 30 April 2025 (Add: location, issue. | Use this bot . Report bugs . | Suggested by Dominic3203 | Linked from User:Mathbot/Most_linked_math_articles | #UCB_webform_linked 659/1913) . The present address (URL) is a permanent link to this version. Revision as of 16:35, 30 April 2025 by Citation bot ( talk | contribs ) (Add: location, issue. | Use t",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Euclidean_algorithm&oldid=1288126959",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:01:57.168944",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:01:57.168944",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:01:57.168944",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Two-element_Boolean_algebra_1_1749013326296_8865",
    "text": "The following equations may now be verified: A + A = A A ⋅ A = A A + 0 = A A + 1 = 1 A ⋅ 0 = 0 A ¯ ¯ = A {\\displaystyle {\\begin{aligned}&A+A=A\\\\&A\\cdot A=A\\\\&A+0=A\\\\&A+1=1\\\\&A\\cdot 0=0\\\\&{\\overline {\\overline {A}}}=A\\end{aligned}}} Each of '+' and '∙' distributes over the other: A ⋅ ( B + C ) = A ⋅ B + A ⋅ C ; {\\displaystyle \\ A\\cdot (B+C)=A\\cdot B+A\\cdot C;} A + ( B ⋅ C ) = ( A + B ) ⋅ ( A + C ) . {\\displaystyle \\ A+(B\\cdot C)=(A+B)\\cdot (A+C).} That '∙' distributes over '+' agrees with elementary algebra , but not '+' over '∙'. For this and other reasons, a sum of products (leading to a NAND synthesis) is more commonly employed than a product of sums (leading to a NOR synthesis). Each of '+' and '∙' can be defined in terms of the other and complementation: A ⋅ B = A ¯ + B ¯ ¯ {\\displaystyle A\\cdot B={\\overline {{\\overline {A}}+{\\overline {B}}}}} A + B = A ¯ ⋅ B ¯ ¯ . {\\displaystyle A+B={\\overline {{\\overline {A}}\\cdot {\\overline {B}}}}.}",
    "source_url": "https://en.wikipedia.org/wiki/Two-element_Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:06.296505",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:06.297512",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:06.297512",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Two-element_Boolean_algebra_1_1749013326373_3014",
    "text": "A 0 = A {\\displaystyle \\ A0=A} (0 is the lower bound ). A A B ¯ = A B ¯ {\\displaystyle A{\\overline {AB}}=A{\\overline {B}}} ( 2 is a distributive lattice ) Where concatenation = OR, 1 = true, and 0 = false, or concatenation = AND, 1 = false, and 0 = true. (overbar is negation in both cases.) If 0=1, (1)–(3) are the axioms for an abelian group . (1) only serves to prove that concatenation commutes and associates. First assume that (1) associates from either the left or the right, then prove commutativity. Then prove association from the other direction. Associativity is simply association from the left and right combined. This basis makes for an easy approach to proof, called \"calculation\" in Laws of Form , that proceeds by simplifying expressions to 0 or 1, by invoking axioms (2)–(4), and the elementary identities A A = A , A ¯ ¯ = A , 1 + A = 1 {\\displaystyle AA=A,{\\overline {\\overline {A}}}=A,1+A=1} , and the distributive law.",
    "source_url": "https://en.wikipedia.org/wiki/Two-element_Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:06.373937",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:06.373937",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:06.373937",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Boolean_algebras_canonically_defined_1_1749013332694_5332",
    "text": "The maximal such algebra consists of all finitary operations on {0,1}. The number of arguments taken by each operation is called the arity of the operation. An operation on {0,1} of arity n , or n -ary operation, can be applied to any of 2 n possible values for its n arguments. For each choice of arguments, the operation may return 0 or 1 , whence there are 2 2 n n -ary operations. The prototype therefore has two operations taking no arguments, called zeroary or nullary operations, namely zero and one. It has four unary operations , two of which are constant operations, another is the identity, and the most commonly used one, called negation , returns the opposite of its argument: 1 if 0 , 0 if 1 .",
    "source_url": "https://en.wikipedia.org/wiki/Boolean_algebras_canonically_defined",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:12.694520",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:12.694520",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:12.694520",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimal_axioms_for_Boolean_algebra_1_1749013336402_8324",
    "text": "∧ ¯ {\\displaystyle {\\overline {\\wedge }}} Converse implication ⇐ {\\displaystyle \\Leftarrow } Implication ( IMPLY gate ) ⇒ {\\displaystyle \\Rightarrow } Disjunction ( OR gate ) ∨ {\\displaystyle \\lor } Negation ( NOT gate ) ¬ {\\displaystyle \\neg } Exclusive or ( XOR gate ) ⊕ {\\displaystyle \\oplus } Biconditional ( XNOR gate ) ⊙ {\\displaystyle \\odot } Statement ( Digital buffer ) Joint denial ( NOR gate )",
    "source_url": "https://en.wikipedia.org/wiki/Minimal_axioms_for_Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:16.402741",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:16.402741",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:16.402741",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_Boolean_algebra_topics_1_1749013337719_9603",
    "text": "theorem Hausdorff maximal principle Knaster–Tarski theorem Kruskal's tree theorem Laver's theorem Mirsky's theorem Szpilrajn extension theorem Zorn's lemma Properties & Types ( list",
    "source_url": "https://en.wikipedia.org/wiki/List_of_Boolean_algebra_topics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:17.719930",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:17.719930",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:17.719930",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann_universe_1_1749013339963_2759",
    "text": "Therefore, P ( x ) ⊆ V α + 1 {\\displaystyle {\\mathcal {P}}(x)\\subseteq V_{\\alpha +1}} and P ( x ) ∈ V α + 2 ⊆ V {\\displaystyle {\\mathcal {P}}(x)\\in V_{\\alpha +2}\\subseteq V} . For unions of subsets, if x ⊆ V {\\displaystyle x\\subseteq V} , then for every y ∈ x {\\displaystyle y\\in x} , let β y {\\displaystyle \\beta _{y}} be the smallest ordinal for which y ∈ V β y {\\displaystyle y\\in V_{\\beta _{y}}} . Because by assumption x {\\displaystyle x} is a set, we can form the limit α = sup { β y : y ∈ x } {\\displaystyle \\alpha =\\sup\\{\\beta _{y}:y\\in x\\}} . The stages are cumulative, and therefore again every y ∈ x {\\displaystyle y\\in x} is y ∈ V α {\\displaystyle y\\in V_{\\alpha }} . Then every z ∈ y {\\displaystyle z\\in y} is also z ∈ V α {\\displaystyle z\\in V_{\\alpha }} , and so ∪ x ⊆ V α {\\displaystyle \\cup x\\subseteq V_{\\alpha }} and ∪ x ∈ V α + 1 {\\displaystyle \\cup x\\in V_{\\alpha +1}} . Hilbert's paradox implies that no set with the above properties exists .",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann_universe",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:19.963568",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:19.964568",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:19.964568",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann_universe_1_1749013340182_3359",
    "text": "Hilbert's paradox implies that no set with the above properties exists . [ 9 ] For suppose V {\\displaystyle V} was a set. Then V {\\displaystyle V} would be a subset of itself, and U = ∪ V {\\displaystyle U=\\cup V} would belong to V {\\displaystyle V} , and so would P ( U ) {\\displaystyle {\\mathcal {P}}(U)} . But more generally, if A ∈ B {\\displaystyle A\\in B} , then A ⊆ ∪ B {\\displaystyle A\\subseteq \\cup B} . Hence, P ( U ) ⊆ ∪ V = U {\\displaystyle {\\mathcal {P}}(U)\\subseteq \\cup V=U} , which is impossible in models of ZFC such as V {\\displaystyle V} itself. Interestingly, x {\\displaystyle x} is a subset of V {\\displaystyle V} if, and only if, x {\\displaystyle x} is a member of V {\\displaystyle V} . Therefore, we can consider what happens if the union condition is replaced with x ∈ V ⟹ ∪ x ∈ V {\\displaystyle x\\in V\\implies \\cup x\\in V} . In this case, there are no known contradictions, and any Grothendieck universe satisfies the new pair of properties.",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann_universe",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:20.182003",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:20.182003",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:20.182003",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749013344363_7593",
    "text": "[ 3 ] Classes in set theory [ edit ] The uses of classes [ edit ] Classes have several uses in NBG: They produce a finite axiomatization of set theory. [ 4 ] They are used to state a \"very strong form of the axiom of choice \" [ 5 ] —namely, the axiom of global choice : There exists a global choice function G {\\displaystyle G} defined on the class of all nonempty sets such that G ( x ) ∈ x {\\displaystyle G(x)\\in x} for every nonempty set x . {\\displaystyle x.} This is stronger than ZFC's axiom of choice: For every set s {\\displaystyle s} of nonempty sets, there exists a choice function f {\\displaystyle f} defined on s {\\displaystyle s} such that f ( x ) ∈ x {\\displaystyle f(x)\\in x} for all x ∈ s . {\\displaystyle x\\in s.} [ a ] The set-theoretic paradoxes are handled by recognizing that some classes cannot be sets. For example, assume that the class O r d {\\displaystyle Ord} of all ordinals is a set.",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:24.363786",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:24.363786",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:24.363786",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749013344394_6519",
    "text": "The constructible universe is the image of this function. [ 7 ] Axiom schema versus class existence theorem [ edit ] Once classes are added to the language of ZFC, it is easy to transform ZFC into a set theory with classes. First, the axiom schema of class comprehension is added. This axiom schema states: For every formula ϕ ( x 1 , … , x n ) {\\displaystyle \\phi (x_{1},\\ldots ,x_{n})} that quantifies only over sets, there exists a class A {\\displaystyle A} consisting of the n {\\displaystyle n} - tuples satisfying the formula—that is, ∀ x 1 ⋯ ∀ x n [ ( x 1 , … , x n ) ∈ A ⟺ ϕ ( x 1 , … , x n ) ] . {\\displaystyle \\forall x_{1}\\cdots \\,\\forall x_{n}[(x_{1},\\ldots ,x_{n})\\in A\\iff \\phi (x_{1},\\ldots ,x_{n})].} Then the axiom schema of replacement is replaced by a single axiom that uses a class. Finally, ZFC's axiom of extensionality is modified to handle classes: If two classes have the same elements, then they are identical. The other axioms of ZFC are not modified. [ 8 ]",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:24.394651",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:24.394651",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:24.394651",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749013344426_7219",
    "text": "[ non-primary source needed ] Bernays used many-sorted logic with two sorts: classes and sets. [ 2 ] Gödel avoided sorts by introducing primitive predicates: C l s ( A ) {\\displaystyle {\\mathfrak {Cls}}(A)} for \" A {\\displaystyle A} is a class\" and M ( A ) {\\displaystyle {\\mathfrak {M}}(A)} for \" A {\\displaystyle A} is a set\" (in German, \"set\" is Menge ). He also introduced axioms stating that every set is a class and that if class A {\\displaystyle A} is a member of a class, then A {\\displaystyle A} is a set. [ 9 ] Using predicates is the standard way to eliminate sorts. Elliott Mendelson modified Gödel's approach by having everything be a class and defining the set predicate M ( A ) {\\displaystyle M(A)} as ∃ C ( A ∈ C ) . {\\displaystyle \\exists C(A\\in C).} [ 10 ] This modification eliminates Gödel's class predicate and his two axioms. Bernays' two-sorted approach may appear more natural at first, but it creates a more complex theory.",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:24.426157",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:24.426157",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:24.426157",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749013344488_8661",
    "text": "ϕ ( x ) ) {\\displaystyle \\forall x{\\bigl (}\\exists C(x\\in C)\\implies \\phi (x){\\bigr )}} The following axioms and definitions are needed for the proof of the class existence theorem. Axiom of extensionality. If two classes have the same elements, then they are identical. ∀ A ∀ B [ ∀ x ( x ∈ A ⟺ x ∈ B ) ⟹ A = B ] {\\displaystyle \\forall A\\,\\forall B\\,[\\forall x(x\\in A\\iff x\\in B)\\implies A=B]} [ 13 ] This axiom generalizes ZFC's axiom of extensionality to classes. Axiom of pairing . If x {\\displaystyle x} and y {\\displaystyle y} are sets, then there exists a set p {\\displaystyle p} whose only members are x {\\displaystyle x} and y {\\displaystyle y} . ∀ x ∀ y ∃ p ∀ z [ z ∈ p ⟺ ( z = x ∨ z = y ) ] {\\displaystyle \\forall x\\,\\forall y\\,\\exists p\\,\\forall z\\,[z\\in p\\iff (z=x\\,\\lor \\,z=y)]} [ 14 ] As in ZFC, the axiom of extensionality implies the uniqueness of the set p {\\displaystyle p} , which allows us to introduce the notation { x , y } . {\\displaystyle \\{x,y\\}.}",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:24.488670",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:24.488670",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:24.488670",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749013344518_8603",
    "text": "Example 1: If the classes F {\\displaystyle F} and G {\\displaystyle G} are functions, then the composite function G ∘ F {\\displaystyle G\\circ F} is defined by the formula: ∃ t [ ( x , t ) ∈ F ∧ ( t , y ) ∈ G ] . {\\displaystyle \\exists t[(x,t)\\in F\\,\\land \\,(t,y)\\in G].} Since this formula has two free set variables, x {\\displaystyle x} and y , {\\displaystyle y,} the class existence theorem constructs the class of ordered pairs: G ∘ F = { ( x , y ) : ∃ t [ ( x , t ) ∈ F ∧ ( t , y ) ∈ G ] } . {\\displaystyle G\\circ F\\,=\\,\\{(x,y):\\exists t[(x,t)\\in F\\,\\land \\,(t,y)\\in G]\\}.} Because this formula is built from simpler formulas using conjunction ∧ {\\displaystyle \\land } and existential quantification ∃ {\\displaystyle \\exists } , class operations are needed that take classes representing the simpler formulas and produce classes representing the formulas with ∧ {\\displaystyle \\land } and ∃ {\\displaystyle \\exists } .",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:24.518546",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:24.518546",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:24.518546",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749013344555_3786",
    "text": "F ′ = { ( x , t , y ) : ( x , t ) ∈ F } {\\displaystyle F'=\\{(x,t,y):(x,t)\\in F\\}\\,} and G ′ = { ( t , y , x ) : ( t , y ) ∈ G } {\\displaystyle \\,G'=\\{(t,y,x):(t,y)\\in G\\}} In the definition of F ′ , {\\displaystyle F',} the variable y {\\displaystyle y} is not restricted by the statement ( x , t ) ∈ F , {\\displaystyle (x,t)\\in F,} so y {\\displaystyle y} ranges over the class V {\\displaystyle V} of all sets. Similarly, in the definition of G ′ , {\\displaystyle G',} the variable x {\\displaystyle x} ranges over V . {\\displaystyle V.} So an axiom is needed that adds an extra component (whose values range over V {\\displaystyle V} ) to the tuples of a given class. Next, the variables are put in the same order to prepare for the intersection: F ″ = { ( x , y , t ) : ( x , t ) ∈ F } {\\displaystyle F''=\\{(x,y,t):(x,t)\\in F\\}\\,} and G ″ = { ( x , y , t ) : ( t , y ) ∈ G } {\\displaystyle \\,G''=\\{(x,y,t):(t,y)\\in G\\}}",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:24.555154",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:24.555154",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:24.555154",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749013344587_2025",
    "text": "So axioms of intersection and domain are needed. The class existence axioms are divided into two groups: axioms handling language primitives and axioms handling tuples. There are four axioms in the first group and three axioms in the second group. [ d ] Axioms for handling language primitives: Membership. There exists a class E {\\displaystyle E} containing all the ordered pairs whose first component is a member of the second component. ∃ E ∀ x ∀ y [ ( x , y ) ∈ E ⟺ x ∈ y ] {\\displaystyle \\exists E\\,\\forall x\\,\\forall y\\,[(x,y)\\in E\\iff x\\in y]\\!} [ 18 ] Intersection (conjunction). For any two classes A {\\displaystyle A} and B {\\displaystyle B} , there is a class C {\\displaystyle C} consisting precisely of the sets that belong to both A {\\displaystyle A} and B {\\displaystyle B} . ∀ A ∀ B ∃ C ∀ x [ x ∈ C ⟺ ( x ∈ A ∧ x ∈ B ) ] {\\displaystyle \\forall A\\,\\forall B\\,\\exists C\\,\\forall x\\,[x\\in C\\iff (x\\in A\\,\\land \\,x\\in B)]} [ 19 ] Complement (negation).",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:24.587461",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:24.587461",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:24.587461",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749013344616_4601",
    "text": "A , {\\displaystyle \\complement A,} and D o m ( A ) , {\\displaystyle Dom(A),} respectively. [ e ] The first three axioms imply the existence of the empty class and the class of all sets: The membership axiom implies the existence of a class E . {\\displaystyle E.} The intersection and complement axioms imply the existence of E ∩ ∁ E {\\displaystyle E\\cap \\complement E} , which is empty. By the axiom of extensionality, this class is unique; it is denoted by ∅ . { \\displaystyle \\emptyset .} The complement of ∅ {\\displaystyle \\emptyset } is the class V {\\displaystyle V} of all sets, which is also unique by extensionality. The set predicate M ( A ) {\\displaystyle M(A)} , which was defined as ∃ C ( A ∈ C ) { \\displaystyle \\exists C(A\\in C)} , is now redefined as A ∈ V {\\displaystyle A\\in V} to avoid quantifying over classes. Axioms for handling tuples: Product by V {\\displaystyle V} .",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:24.616559",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:24.616559",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:24.616559",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749013344647_3465",
    "text": "For any class A {\\displaystyle A} , there is a class B {\\displaystyle B} whose 3‑tuples are obtained by transposing the last two components of the 3‑tuples of A {\\displaystyle A} . ∀ A ∃ B ∀ x ∀ y ∀ z [ ( x , y , z ) ∈ B ⟺ ( x , z , y ) ∈ A ] {\\displaystyle \\forall A\\,\\exists B\\,\\forall x\\,\\forall y\\,\\forall z\\,[(x,y,z)\\in B\\iff (x,z,y)\\in A]} [ 25 ] By extensionality, the product by V {\\displaystyle V} axiom implies the existence of a unique class, which is denoted by A × V . {\\displaystyle A\\times V.} This axiom is used to define the class V n {\\displaystyle V^{n}} of all n {\\displaystyle n} -tuples : V 1 = V {\\displaystyle V^{1}=V} and V n + 1 = V n × V . {\\displaystyle V^{n+1}=V^{n}\\times V.\\,} If A {\\displaystyle A} is a class, extensionality implies that A ∩ V n {\\displaystyle A\\cap V^{n}} is the unique class consisting of the n {\\displaystyle n} -tuples of A .",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:24.647132",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:24.647132",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:24.647132",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithm_characterizations_1_1749013353730_9982",
    "text": "By means of what Couturat (1914) called a \"sort of logical piano [,] ... the equalities which represent the premises ... are \"played\" on a keyboard like that of a typewriter. ... When all the premises have been \"played\", the panel shows only those constituents whose sum is equal to 1, that is, ... its logical whole. This mechanical method has the advantage over VENN's geometrical method...\" (Couturat 1914:75). For his part John Venn , a logician contemporary to Jevons, was less than thrilled, opining that \"it does not seem to me that any contrivances at present known or likely to be discovered really deserve the name of logical machines\" (italics added, Venn 1881:120).",
    "source_url": "https://en.wikipedia.org/wiki/Algorithm_characterizations",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:33.730554",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:33.730554",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:33.730554",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Division_algorithm_1_1749013358020_9456",
    "text": "Step 2 :  Take i=3 (one less than the number of bits in N) Step 3 :  R=00 (left shifted by 1) Step 4 :  R=01 (setting R(0) to N(i)) Step 5 :  R < D, so skip statement Step 2 :  Set i=2 Step 3 :  R=010 Step 4 :  R=011 Step 5 :  R < D, statement skipped Step 2 : Set i=1 Step 3 :  R=0110 Step 4 : R=0110 Step 5 :  R>=D, statement entered Step 5b :  R=10 (R−D) Step 5c :  Q=10 (setting Q(i) to 1) Step 2 : Set i=0 Step 3 :  R=100 Step 4 :  R=100 Step 5 :  R>=D, statement entered Step 5b :  R=0 (R−D) Step 5c :  Q=11 (setting Q(i) to 1) end Q=11 2 (3 10 ) and R=0.",
    "source_url": "https://en.wikipedia.org/wiki/Division_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:38.020259",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:38.020259",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:38.020259",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Empirical_algorithmics&oldid=1194883679_1_1749013366793_4142",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Sir Ibee ( talk | contribs ) at 06:41, 11 January 2024 (Open access status updates in citations with OAbot #oabot) . The present address (URL) is a permanent link to this version. Revision as of 06:41, 11 January 2024 by Sir Ibee ( talk | contribs ) (Open access status updates in citations with OAbot #oabot) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Empirical_algorithmics&oldid=1194883679",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:46.793829",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:46.793829",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:46.793829",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Profiling_(computer_programming)_1_1749013368070_7626",
    "text": "/* ------------ source------------------------- count */             \n0001 IF X = \"A\"                      0055\n0002                THEN DO                       \n0003                    ADD 1 to XCOUNT         0032\n0004                ELSE\n0005 IF X = \"B\"                      0055 A stream of recorded events (a trace ) For sequential programs, a summary profile is usually sufficient, but performance problems in parallel programs (waiting for messages or synchronization issues) often depend on the time relationship of events, thus requiring a full trace to get an understanding of what is happening. The size of a (full) trace is linear to the program's instruction path length , making it somewhat impractical. A trace may therefore be initiated at one point in a program and terminated at another point to limit the output. An ongoing interaction with the hypervisor (continuous or periodic monitoring via on-screen display for instance)",
    "source_url": "https://en.wikipedia.org/wiki/Profiling_(computer_programming)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:48.070683",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:48.070683",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:48.070683",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Profiling_(computer_programming)_1_1749013368165_2464",
    "text": "In 1982 gprof extended the concept to a complete call graph analysis. [ 8 ] In 1994, Amitabh Srivastava and Alan Eustace of Digital Equipment Corporation published a paper describing ATOM [ 9 ] (Analysis Tools with OM). The ATOM platform converts a program into its own profiler: at compile time , it inserts code into the program to be analyzed. That inserted code outputs analysis data. This technique - modifying a program to analyze itself - is known as \" instrumentation \". In 2004 both the gprof and ATOM papers appeared on the list of the 50 most influential PLDI papers for the 20-year period ending in 1999. [ 10 ] Profiler types based on output [ edit ] Flat profiler [ edit ] Flat profilers compute the average call times, from the calls, and do not break down the call times based on the callee or the context. Call-graph profiler [ edit ] Call graph profilers [ 8 ] show the call times, and frequencies of the functions, and also the call-chains involved based on the callee.",
    "source_url": "https://en.wikipedia.org/wiki/Profiling_(computer_programming)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:48.165080",
    "symbols_found_in_chunk": 2,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:48.165080",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:48.165080",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Profiling_(computer_programming)&oldid=1286436094_1_1749013369028_5817",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Widefox ( talk | contribs ) at 22:10, 19 April 2025 ( → top : bold alt article name per MOS) . The present address (URL) is a permanent link to this version. Revision as of 22:10, 19 April 2025 by Widefox ( talk | contribs ) ( → top : bold alt article name per MOS) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Measuring the time or resources used by a se",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Profiling_(computer_programming)&oldid=1286436094",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:49.028348",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:49.028348",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:49.028348",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Recursive_algorithm_1_1749013371545_2484",
    "text": "Indirect recursion [ edit ] Main article: Mutual recursion Most basic examples of recursion, and most of the examples presented here, demonstrate direct recursion , in which a function calls itself. Indirect recursion occurs when a function is called not by itself but by another function that it called (either directly or indirectly). For example, if f calls f, that is direct recursion, but if f calls g which calls f, then that is indirect recursion of f. Chains of three or more functions are possible; for example, function 1 calls function 2, function 2 calls function 3, and function 3 calls function 1 again. Indirect recursion is also called mutual recursion , which is a more symmetric term, though this is simply a difference of emphasis, not a different notion.",
    "source_url": "https://en.wikipedia.org/wiki/Recursive_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:51.545747",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:51.545747",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:51.545747",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Deterministic_algorithm_1_1749013375057_2509",
    "text": "Disadvantages of determinism [ edit ] It is advantageous, in some cases, for a program to exhibit nondeterministic behavior. The behavior of a card shuffling program used in a game of blackjack , for example, should not be predictable by players — even if the source code of the program is visible. The use of a pseudorandom number generator is often not sufficient to ensure that players are unable to predict the outcome of a shuffle. A clever gambler might guess precisely the numbers the generator will choose and so determine the entire contents of the deck ahead of time, allowing him to cheat; for example, the Software Security Group at Reliable Software Technologies was able to do this for an implementation of Texas Hold 'em Poker that is distributed by ASF Software, Inc, allowing them to consistently predict the outcome of hands ahead of time.",
    "source_url": "https://en.wikipedia.org/wiki/Deterministic_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:55.057455",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:55.057455",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:55.057455",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoid_method_1_1749013379036_4265",
    "text": "Jump to content From Wikipedia, the free encyclopedia Iterative method for minimizing convex functions Example of graph. In mathematical optimization , the ellipsoid method is an iterative method for minimizing convex functions over convex sets . The ellipsoid method generates a sequence of ellipsoids whose volume uniformly decreases at every step, thus enclosing a minimizer of a convex function . When specialized to solving feasible linear optimization problems with rational data, the ellipsoid",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoid_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:02:59.036625",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:02:59.037814",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:02:59.037814",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Approximation_algorithm&oldid=1287316159_1_1749013381325_9883",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by 2001:638:708:306:290e:2b4c:e37e:90ea ( talk ) at 12:31, 25 April 2025 ( → Performance guarantees : fixed a typo) . The present address (URL) is a permanent link to this version. Revision as of 12:31, 25 April 2025 by 2001:638:708:306:290e:2b4c:e37e:90ea ( talk ) ( → Performance guarantees : fixed a typo) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Clas",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Approximation_algorithm&oldid=1287316159",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:01.325534",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:01.325534",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:01.325534",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Graph_exploration_algorithm_1_1749013388020_9027",
    "text": "This section needs expansion . You can help by adding to it . ( December 2016 ) A universal traversal sequence is a sequence of instructions comprising a graph traversal for any regular graph with a set number of vertices and for any starting vertex. A probabilistic proof was used by Aleliunas et al. to show that there exists a universal traversal sequence with number of instructions proportional to O ( n 5 ) for any regular graph with n vertices. [ 6 ] The steps specified in the sequence are relative to the current node, not absolute. For example, if the current node is v j , and v j has d neighbors, then the traversal sequence will specify the next node to visit, v j +1 , as the i th neighbor of v j , where 1 ≤ i ≤ d . See also [ edit ] External memory graph traversal References [ edit ] ^ Rosenkrantz, Daniel J.; Stearns, Richard E.; Lewis, II, Philip M. (1977). \"An Analysis of Several Heuristics for the Traveling Salesman Problem\". SIAM Journal on Computing . 6 (3): 563– 581.",
    "source_url": "https://en.wikipedia.org/wiki/Graph_exploration_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:08.020252",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:08.020252",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:08.020252",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimax_1_1749013391233_1598",
    "text": "Jump to content From Wikipedia, the free encyclopedia Decision rule used for minimizing the possible loss for a worst case scenario This article is about the decision theory concept. For other uses, see Minimax (disambiguation) . For company, see MiniMax (company) . Minimax (sometimes Minmax , MM [ 1 ] or saddle point [ 2 ] ) is a decision rule used in artificial intelligence , decision theory , combinatorial game theory , statistics , and philosophy for minimizing the possible loss for a worst ",
    "source_url": "https://en.wikipedia.org/wiki/Minimax",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:11.233042",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:11.233042",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:11.233042",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Las_Vegas_algorithm_1_1749013395898_3117",
    "text": "The time complexity thus ranges from getting \"lucky\" and finding the content immediately, to being \"unlucky\" and spending large amounts of time. Once the right website is found, then there is no possibility of error. [ 6 ] Randomized quicksort [ edit ] INPUT : # A is an array of n elements def randomized_quicksort ( A ): if n == 1 : return A # A is sorted. else : i = random . randrange ( 1 , n ) # Will take a random number in the range 1~n X = A [ i ] # The pivot element \"\"\"Partition A into elements < x, x, and >x  # as shown in the figure above. Execute Quicksort on A[1 to i-1] and A[i+1 to n]. Combine the responses in order to obtain a sorted array.\" \"\" A simple example is randomized quicksort , where the pivot is chosen randomly, and divides the elements into three partitions: elements less than pivot, elements equal to pivot, and elements greater than pivot. QuickSort always generates the solution, which in this case the sorted array.",
    "source_url": "https://en.wikipedia.org/wiki/Las_Vegas_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:15.898649",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:15.898649",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:15.898649",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Las_Vegas_algorithm_1_1749013395935_6470",
    "text": "QuickSort always generates the solution, which in this case the sorted array. Unfortunately, the time complexity is not that obvious. It turns out that the runtime depends on which element we pick as a pivot. The worst case Θ( n 2 ) when the pivot is the smallest or the largest element. T ( n ) = T ( 0 ) + T ( n − 1 ) + Θ ( n ) {\\displaystyle T(n)=T(0)+T(n-1)+\\Theta (n)} T ( n ) = Θ ( 1 ) + T ( n − 1 ) + Θ ( n ) {\\displaystyle T(n)=\\Theta (1)+T(n-1)+\\Theta (n)} T ( n ) = T ( n − 1 ) + Θ ( n ) {\\displaystyle T(n)=T(n-1)+\\Theta (n)} T ( n ) = Θ ( n 2 ) {\\displaystyle T(n)=\\Theta (n^{2})} However, through randomization, where the pivot is randomly picked and is exactly a middle value each time, the QuickSort can be done in Θ( n log n ). T ( n ) ≤ 2 ∗ T ( n / 2 ) + Θ ( n ) {\\displaystyle T(n)\\leq 2*T(n/2)+\\Theta (n)} T ( n ) = Θ ( n log ⁡ ( n ) ) {\\displaystyle T(n)=\\Theta (n\\log(n))} The runtime of quicksort depends heavily on how well the pivot is selected.",
    "source_url": "https://en.wikipedia.org/wiki/Las_Vegas_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:15.935383",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:15.935383",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:15.935383",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Selection_algorithm_1_1749013399655_6072",
    "text": "[ 1 ] To simplify the problem, some works on this problem assume that the values are all distinct from each other, [ 2 ] or that some consistent tie-breaking method has been used to assign an ordering to pairs of items with the same value as each other. Another variation in the problem definition concerns the numbering of the ordered values: is the smallest value obtained by setting k = 0 {\\displaystyle k=0} , as in zero-based numbering of arrays, or is it obtained by setting k = 1 {\\displaystyle k=1} , following the usual English-language conventions for the smallest, second-smallest, etc.? This article follows the conventions used by Cormen et al., according to which all values are distinct and the minimum value is obtained from k = 1 {\\displaystyle k=1} . [ 2 ] With these conventions, the maximum value, among a collection of n {\\displaystyle n} values, is obtained by setting k = n {\\displaystyle k=n} .",
    "source_url": "https://en.wikipedia.org/wiki/Selection_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:19.655713",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:19.655713",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:19.655713",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Selection_algorithm&oldid=1272480370_1_1749013403349_6916",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by David Eppstein ( talk | contribs ) at 20:59, 28 January 2025 (Undid revision 1272462687 by 49.207.232.175 ( talk ) the values must have an ordering. They may not be presented in that ordering.) . The present address (URL) is a permanent link to this version. Revision as of 20:59, 28 January 2025 by David Eppstein ( talk | contribs ) (Undid revision 1272462687 by 49.207.232.175 ( talk ) t",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Selection_algorithm&oldid=1272480370",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:23.349314",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:23.349314",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:23.349314",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simplex_algorithm_1_1749013405470_2254",
    "text": "The possible results from Phase II are either an optimum basic feasible solution or an infinite edge on which the objective function is unbounded above. [ 13 ] [ 14 ] [ 15 ] Standard form [ edit ] The transformation of a linear program to one in standard form may be accomplished as follows. [ 16 ] First, for each variable with a lower bound other than 0, a new variable is introduced representing the difference between the variable and bound. The original variable can then be eliminated by substitution. For example, given the constraint x 1 ≥ 5 {\\displaystyle x_{1}\\geq 5} a new variable, y 1 {\\displaystyle y_{1}} , is introduced with y 1 = x 1 − 5 x 1 = y 1 + 5 {\\displaystyle {\\begin{aligned}y_{1}=x_{1}-5\\\\x_{1}=y_{1}+5\\end{aligned}}} The second equation may be used to eliminate x 1 {\\displaystyle x_{1}} from the linear program. In this way, all lower bound constraints may be changed to non-negativity restrictions.",
    "source_url": "https://en.wikipedia.org/wiki/Simplex_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:25.470637",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:25.470637",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:25.470637",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simplex_algorithm_1_1749013405527_1303",
    "text": "Third, each unrestricted variable is eliminated from the linear program. This can be done in two ways, one is by solving for the variable in one of the equations in which it appears and then eliminating the variable by substitution. The other is to replace the variable with the difference of two restricted variables. For example, if z 1 {\\displaystyle z_{1}} is unrestricted then write z 1 = z 1 + − z 1 − z 1 + , z 1 − ≥ 0 {\\displaystyle {\\begin{aligned}&z_{1}=z_{1}^{+}-z_{1}^{-}\\\\&z_{1}^{+},\\,z_{1}^{-}\\geq 0\\end{aligned}}} The equation may be used to eliminate z 1 {\\displaystyle z_{1}} from the linear program. When this process is complete the feasible region will be in the form A x = b , ∀ x i ≥ 0 {\\displaystyle \\mathbf {A} \\mathbf {x} =\\mathbf {b} ,\\,\\forall \\ x_{i}\\geq 0} It is also useful to assume that the rank of A {\\displaystyle \\mathbf {A} } is the number of rows.",
    "source_url": "https://en.wikipedia.org/wiki/Simplex_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:25.527484",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:25.527484",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:25.527484",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Floyd%E2%80%93Warshall_algorithm_1_1749013411385_8135",
    "text": "It does so by incrementally improving an estimate on the shortest path between two vertices, until the estimate is optimal. Consider a graph G {\\displaystyle G} with vertices V {\\displaystyle V} numbered 1 through N {\\displaystyle N} . Further consider a function s h o r t e s t P a t h ( i , j , k ) {\\displaystyle \\mathrm {shortestPath} (i,j,k)} that returns the length of the shortest possible path (if one exists) from i {\\displaystyle i} to j {\\displaystyle j} using vertices only from the set { 1 , 2 , … , k } {\\displaystyle \\{1,2,\\ldots ,k\\}} as intermediate points along the way. Now, given this function, our goal is to find the length of the shortest path from each i {\\displaystyle i} to each j {\\displaystyle j} using any vertex in { 1 , 2 , … , N } {\\displaystyle \\{1,2,\\ldots ,N\\}} . By definition, this is the value s h o r t e s t P a t h ( i , j , N ) {\\displaystyle \\mathrm {shortestPath} (i,j,N)} , which we will find recursively .",
    "source_url": "https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:31.385153",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:31.385153",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:31.385153",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Floyd%E2%80%93Warshall_algorithm_1_1749013411419_1761",
    "text": "{\\displaystyle \\mathrm {shortestPath} (i,j,N)} , which we will find recursively . Observe that s h o r t e s t P a t h ( i , j , k ) {\\displaystyle \\mathrm {shortestPath} (i,j,k)} must be less than or equal to s h o r t e s t P a t h ( i , j , k − 1 ) {\\displaystyle \\mathrm {shortestPath} (i,j,k-1)} : we have more flexibility if we are allowed to use the vertex k {\\displaystyle k} . If s h o r t e s t P a t h ( i , j , k ) {\\displaystyle \\mathrm {shortestPath} (i,j,k)} is in fact less than s h o r t e s t P a t h ( i , j , k − 1 ) {\\displaystyle \\mathrm {shortestPath} (i,j,k-1)} , then there must be a path from i {\\displaystyle i} to j {\\displaystyle j} using the vertices { 1 , 2 , … , k } {\\displaystyle \\{1,2,\\ldots ,k\\}} that is shorter than any such path that does not use the vertex k {\\displaystyle k} .",
    "source_url": "https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:31.419816",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:31.419816",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:31.419816",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Floyd%E2%80%93Warshall_algorithm_1_1749013411462_8684",
    "text": "Since there are no negative cycles this path can be decomposed as: (1) a path from i {\\displaystyle i} to k {\\displaystyle k} that uses the vertices { 1 , 2 , … , k − 1 } {\\displaystyle \\{1,2,\\ldots ,k-1\\}} , followed by (2) a path from k {\\displaystyle k} to j {\\displaystyle j} that uses the vertices { 1 , 2 , … , k − 1 } {\\displaystyle \\{1,2,\\ldots ,k-1\\}} . And of course, these must be a shortest such path (or several of them), otherwise we could further decrease the length. In other words, we have arrived at the recursive formula: s h o r t e s t P a t h ( i , j , k ) = {\\displaystyle \\mathrm {shortestPath} (i,j,k)=} m i n ( s h o r t e s t P a t h ( i , j , k − 1 ) , {\\displaystyle \\mathrm {min} {\\Big (}\\mathrm {shortestPath} (i,j,k-1),} s h o r t e s t P a t h ( i , k , k − 1 ) + s h o r t e s t P a t h ( k , j , k − 1 ) ) {\\displaystyle \\mathrm {shortestPath} (i,k,k-1)+\\mathrm {shortestPath} (k,j,k-1){\\Big )}} . The base case is given by s h o r t e s t P a t h ( i , j , 0 )",
    "source_url": "https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:31.462441",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:31.462441",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:31.462441",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Floyd%E2%80%93Warshall_algorithm_1_1749013411619_3314",
    "text": "At k = 2 , paths going through the vertices {1,2} are found. The red and blue boxes show how the path [4,2,1,3] is assembled from the two known paths [4,2] and [2,1,3] encountered in previous iterations, with 2 in the intersection. The path [4,2,3] is not considered, because [2,1,3] is the shortest path encountered so far from 2 to 3. At k = 3 , paths going through the vertices {1,2,3} are found. Finally, at k = 4 , all shortest paths are found. The distance matrix at each iteration of k , with the updated distances in bold , will be: k = 0 j 1 2 3 4 i 1 0 ∞ −2 ∞ 2 4 0 3 ∞ 3 ∞ ∞ 0 2 4 ∞ −1 ∞ 0 k = 1 j 1 2 3 4 i 1 0 ∞ −2 ∞ 2 4 0 2 ∞ 3 ∞ ∞ 0 2 4 ∞ −1 ∞ 0 k = 2 j 1 2 3 4 i 1 0 ∞ −2 ∞ 2 4 0 2 ∞ 3 ∞ ∞ 0 2 4 3 −1 1 0 k = 3 j 1 2 3 4 i 1 0 ∞ −2 0 2 4 0 2 4 3 ∞ ∞ 0 2 4 3 −1 1 0 k = 4 j 1 2 3 4 i 1 0 −1 −2 0 2 4 0 2 4 3 5 1 0 2 4 3 −1 1 0 Behavior with negative cycles [ edit ] A negative cycle is a cycle whose edges sum to a negative value.",
    "source_url": "https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:31.619115",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:31.619802",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:31.619802",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Heuristic_algorithm_1_1749013419322_7175",
    "text": "A heuristic method can accomplish its task by using search trees. However, instead of generating all possible solution branches, a heuristic selects branches more likely to produce outcomes than other branches. It is selective at each decision point, picking branches that are more likely to produce solutions. [ 5 ] Antivirus software [ edit ] Antivirus software often uses heuristic rules for detecting viruses and other forms of malware . Heuristic scanning looks for code and/or behavioral patterns common to a class or family of viruses, with different sets of rules for different viruses. If a file or executing process is found to contain matching code patterns and/or to be performing that set of activities, then the scanner infers that the file is infected. The most advanced part of behavior-based heuristic scanning is that it can work against highly randomized self-modifying/mutating ( polymorphic ) viruses that cannot be easily detected by simpler string scanning methods.",
    "source_url": "https://en.wikipedia.org/wiki/Heuristic_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:39.322711",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:39.322711",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:39.322711",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Heuristic_algorithm_1_1749013419351_2932",
    "text": "Heuristic scanning has the potential to detect future viruses without requiring the virus to be first detected somewhere else, submitted to the virus scanner developer, analyzed, and a detection update for the scanner provided to the scanner's users. Pitfalls [ edit ] Some heuristics have a strong underlying theory; they are either derived in a top-down manner from the theory or are arrived at based on either experimental or real world data. Others are just rules of thumb based on real-world observation or experience without even a glimpse of theory. The latter are exposed to a larger number of pitfalls. When a heuristic is reused in various contexts because it has been seen to \"work\" in one context, without having been mathematically proven to meet a given set of requirements, it is possible that the current data set does not necessarily represent future data sets (see: overfitting ) and that purported \"solutions\" turn out to be akin to noise.",
    "source_url": "https://en.wikipedia.org/wiki/Heuristic_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:39.351243",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:39.351243",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:39.351243",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Heuristic_algorithm_1_1749013419384_8240",
    "text": "Statistical analysis can be conducted when employing heuristics to estimate the probability of incorrect outcomes. To use a heuristic for solving a search problem or a knapsack problem , it is necessary to check that the heuristic is admissible . Given a heuristic function h ( v i , v g ) {\\displaystyle h(v_{i},v_{g})} meant to approximate the true optimal distance d ⋆ ( v i , v g ) {\\displaystyle d^{\\star }(v_{i},v_{g})} to the goal node v g {\\displaystyle v_{g}} in a directed graph G {\\displaystyle G} containing n {\\displaystyle n} total nodes or vertices labeled v 0 , v 1 , ⋯ , v n {\\displaystyle v_{0},v_{1},\\cdots ,v_{n}} , \"admissible\" means roughly that the heuristic underestimates the cost to the goal or formally that h ( v i , v g ) ≤ d ⋆ ( v i , v g ) {\\displaystyle h(v_{i},v_{g})\\leq d^{\\star }(v_{i},v_{g})} for all ( v i , v g ) {\\displaystyle (v_{i},v_{g})} where i , g ∈ [ 0 , 1 , . . . , n ] {\\displaystyle {i,g}\\in [0,1,...,n]} .",
    "source_url": "https://en.wikipedia.org/wiki/Heuristic_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:39.384086",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:39.384086",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:39.384086",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Genetic_algorithm&oldid=1292039994_1_1749013430187_9279",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by PeterGrant07 ( talk | contribs ) at 21:33, 24 May 2025 ( → Chromosome representation : adding early innovations in variable-length representations) . The present address (URL) is a permanent link to this version. Revision as of 21:33, 24 May 2025 by PeterGrant07 ( talk | contribs ) ( → Chromosome representation : adding early innovations in variable-length representations) ( diff ) ← Pre",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Genetic_algorithm&oldid=1292039994",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:50.187486",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:50.187486",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:50.187486",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Needleman%E2%80%93Wunsch_algorithm_1_1749013437289_8136",
    "text": "Jump to content From Wikipedia, the free encyclopedia Method for aligning biological sequences This article may be too technical for most readers to understand . Please help improve it to make it understandable to non-experts , without removing the technical details. ( September 2013 ) ( Learn how and when to remove this message ) Figure 1: Needleman-Wunsch pairwise sequence alignment Class Sequence alignment Worst-case performance O ( m n ) {\\displaystyle O(mn)} Worst-case space complexity O ( ",
    "source_url": "https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:03:57.289589",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:03:57.289589",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:03:57.289589",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Nested_sampling_algorithm_1_1749013451137_1653",
    "text": "Jump to content From Wikipedia, the free encyclopedia Part of a series on Bayesian statistics Posterior = Likelihood × Prior ÷ Evidence Background Bayesian inference Bayesian probability Bayes' theorem Bernstein–von Mises theorem Coherence Cox's theorem Cromwell's rule Likelihood principle Principle of indifference Principle of maximum entropy Model building Conjugate prior Linear regression Empirical Bayes Hierarchical model Posterior approximation Markov chain Monte Carlo Laplace's approximati",
    "source_url": "https://en.wikipedia.org/wiki/Nested_sampling_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:11.137497",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:11.137497",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:11.137497",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Linde%E2%80%93Buzo%E2%80%93Gray_algorithm_1_1749013451964_6547",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article is missing information about general information, usage in the field (mention cinepak?), optimality conditions, choice of 𝜖s, model instead of training data, ELBG. Please expand the article to include this information. Further details may exist on the talk page . ( December 2023 ) This article relies largely or entirely on a single source . Relevant discussion may be found on the talk page . Please help improve this article by in",
    "source_url": "https://en.wikipedia.org/wiki/Linde%E2%80%93Buzo%E2%80%93Gray_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:11.964843",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:11.965846",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:11.965846",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Fast_Cosine_Transform_1_1749013459496_5235",
    "text": "Jump to content From Wikipedia, the free encyclopedia (Redirected from Fast Cosine Transform ) Technique used in signal processing and data compression A discrete cosine transform ( DCT ) expresses a finite sequence of data points in terms of a sum of cosine functions oscillating at different frequencies . The DCT, first proposed by Nasir Ahmed in 1972, is a widely used transformation technique in signal processing and data compression . It is used in most digital media , including digital image",
    "source_url": "https://en.wikipedia.org/wiki/Fast_Cosine_Transform",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:19.496074",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:19.496074",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:19.496074",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Join_(SQL)_1_1749013461975_6002",
    "text": "Jump to content From Wikipedia, the free encyclopedia SQL clause A Venn diagram representing the full join SQL statement between tables A and B. A join clause in the Structured Query Language ( SQL ) combines columns from one or more tables into a new table. The operation corresponds to a join operation in relational algebra . Informally, a join stitches two tables and puts on the same row records with matching fields : INNER , LEFT OUTER , RIGHT OUTER , FULL OUTER and CROSS . Example tables [ e",
    "source_url": "https://en.wikipedia.org/wiki/Join_(SQL)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:21.975694",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:21.976695",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:21.976695",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Snapshot_algorithm_1_1749013463887_9586",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article's tone or style may not reflect the encyclopedic tone used on Wikipedia . See Wikipedia's guide to writing better articles for suggestions. ( November 2016 ) ( Learn how and when to remove this message ) This article needs additional citations for verification . Please help improve th",
    "source_url": "https://en.wikipedia.org/wiki/Snapshot_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:23.887587",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:23.888587",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:23.888587",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Portal:Computer_programming&oldid=1285333001_1_1749013472955_1354",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by HMSLavender ( talk | contribs ) at 02:46, 13 April 2025 ( Reverted edits by 2001:FB1:119:4398:1144:9891:D62:9654 ( talk ) to last version by Ormewood: unexplained content removal) . The present address (URL) is a permanent link to this version. Revision as of 02:46, 13 April 2025 by HMSLavender ( talk | contribs ) ( Reverted edits by 2001:FB1:119:4398:1144:9891:D62:9654 ( talk ) to last ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Portal:Computer_programming&oldid=1285333001",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:32.955698",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:32.955698",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:32.955698",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithm_aversion&oldid=1291719852_1_1749013475951_6522",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 23:45, 22 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 23:45, 22 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Bias",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithm_aversion&oldid=1291719852",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:35.951744",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:35.952735",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:35.952735",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithmic_bias_1_1749013481927_7836",
    "text": "Segregation age racial Jim Crow laws Nuremberg Laws Segregation academy religious sexual in Islam Social exclusion Sodomy law State atheism State religion Ugly law Voter suppression White Australia policy Countermeasures Affirmative action Anti-discrimination law Anti-racism Audit study Autism rights movement Blind audition Constitutional colorblindness Cross-sex friendship Cultural assimilation Cultural pluralism Diversity, equity, and inclusion Diversity training Empowerment Fat acceptance movement Feminism Fighting Discrimination Golden Rule Hate speech laws by country Human rights Intersex human rights Korenizatsiia LGBTQ rights Music in the movement against apartheid Nonviolence Racial integration Reappropriation Rock Against Sexism Self-determination Social integration Toleration Transgender rights movement Universal suffrage Women's rights Related topics Allophilia Alterity Amatonormativity Bias Cisnormativity Civil liberties Criminalization of homosexuality Dehumanization",
    "source_url": "https://en.wikipedia.org/wiki/Algorithmic_bias",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:41.927559",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:41.927559",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:41.927559",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Open-source_software_1_1749013484570_9795",
    "text": "Jump to content Checked From Wikipedia, the free encyclopedia This is the latest accepted revision , reviewed on 22 May 2025 . Software licensed to ensure source code usage rights Open-source software shares similarities with free software and is part of the broader term free and open-source software . For broader coverage of this topic, see open-source-software movement . A screenshot of Manjaro Linux running the Cinnamon desktop environment , Firefox accessing Wikipedia which uses MediaWiki , ",
    "source_url": "https://en.wikipedia.org/wiki/Open-source_software",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:44.570615",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:44.570615",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:44.570615",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithmic_bias&oldid=1293240757_1_1749013485346_5386",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by HudecEmil ( talk | contribs ) at 15:41, 31 May 2025 (crosslink) . The present address (URL) is a permanent link to this version. Revision as of 15:41, 31 May 2025 by HudecEmil ( talk | contribs ) (crosslink) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Technological phenomenon with social implications A flow chart showing the decisions made by a recomme",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithmic_bias&oldid=1293240757",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:45.346945",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:45.346945",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:45.346945",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithmic_entities_1_1749013490246_4709",
    "text": "[ 4 ] In some countries there have been made some exceptions to this in the form of the granting of an environmental personhood to rivers, waterfalls, forests and mountains. In the past, some form of personhood also existed for certain religious constructions such as churches and temples. [ 5 ] Certain countries – albeit for publicity purposes – have shown willingness to grant (some form of) legal personhood to robots . On the 27th of October 2017, Saudi Arabia became to first country in the world to grant citizenship to a robot when it gave “Sophia” a passport. In the same year, official residency status was granted to a chatbot named “Shibuya Mirai” in Tokyo, Japan. [ 6 ] The general consensus is that AI in any case cannot be regarded as a natural or real person and that granting AI (legal) personhood at this stage is unwanted from a societal point of view.",
    "source_url": "https://en.wikipedia.org/wiki/Algorithmic_entities",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:50.246915",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:50.246915",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:50.246915",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithmic_entities&oldid=1274932913_1_1749013491085_1436",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by GreenC bot ( talk | contribs ) at 02:42, 10 February 2025 (Move 1 url. Wayback Medic 2.5 per WP:URLREQ#carnegieendowment.org ) . The present address (URL) is a permanent link to this version. Revision as of 02:42, 10 February 2025 by GreenC bot ( talk | contribs ) (Move 1 url. Wayback Medic 2.5 per WP:URLREQ#carnegieendowment.org ) ( diff ) ← Previous revision | Latest revision (diff) | ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithmic_entities&oldid=1274932913",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:51.085486",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:51.085486",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:51.085486",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithmic_technique_1_1749013495898_2781",
    "text": "This approach is broad, and includes depth-first search , breadth-first search , tree traversal , and many specific variations that may include local optimizations and excluding search spaces that can be determined to be non-optimum or not possible. These techniques may be used to solve a variety of problems including shortest path and constraint satisfaction problems. [ 8 ] Greedy [ edit ] A greedy approach begins by evaluating one possible outcome from the set of possible outcomes, and then searches locally for an improvement on that outcome. When a local improvement is found, it will repeat the process and again search locally for additional improvements near this local optimum. A greedy technique is generally simple to implement, and these series of decisions can be used to find local optimums depending on where the search began. However, greedy techniques may not identify the global optimum across the entire set of possible outcomes., [ 9 ] Heuristic [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Algorithmic_technique",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:55.898928",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:55.898928",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:55.898928",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithmic_technique&oldid=1290996077_1_1749013496586_1300",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by 103.138.125.195 ( talk ) at 12:12, 18 May 2025 (Renamed \"Window Sliding to Sliding Window\", Added \"Two Pointers\" and \"Backtracking\".) . The present address (URL) is a permanent link to this version. Revision as of 12:12, 18 May 2025 by 103.138.125.195 ( talk ) (Renamed \"Window Sliding to Sliding Window\", Added \"Two Pointers\" and \"Backtracking\".) ( diff ) ← Previous revision | Latest revi",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithmic_technique&oldid=1290996077",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:04:56.586482",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:04:56.586482",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:04:56.586482",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Government_by_algorithm&oldid=1292105079_1_1749013507333_2180",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by SchlurcherBot ( talk | contribs ) at 06:43, 25 May 2025 (Bot: http → https) . The present address (URL) is a permanent link to this version. Revision as of 06:43, 25 May 2025 by SchlurcherBot ( talk | contribs ) (Bot: http → https) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Alternative form of government or social ordering Not to be confused with Regu",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Government_by_algorithm&oldid=1292105079",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:05:07.333303",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:05:07.333303",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:05:07.333303",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=List_of_algorithm_general_topics&oldid=1245681809_1_1749013510390_3307",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Shashvat Verma ( talk | contribs ) at 13:50, 14 September 2024 ( → top : the name is self sufficient no need of descriptions) . The present address (URL) is a permanent link to this version. Revision as of 13:50, 14 September 2024 by Shashvat Verma ( talk | contribs ) ( → top : the name is self sufficient no need of descriptions) ( diff ) ← Previous revision | Latest revision (diff) | Ne",
    "source_url": "https://en.wikipedia.org/w/index.php?title=List_of_algorithm_general_topics&oldid=1245681809",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:05:10.390556",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:05:10.390556",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:05:10.390556",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Regulation_of_algorithms&oldid=1292061849_1_1749013513944_6040",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 00:28, 25 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 00:28, 25 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Gove",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Regulation_of_algorithms&oldid=1292061849",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:05:13.944663",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:05:13.944663",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:05:13.944663",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_John_von_Neumann_1_1749013518449_8437",
    "text": "Jump to content From Wikipedia, the free encyclopedia Hungarian and American mathematician and physicist (1903–1957) The native form of this personal name is Neumann János Lajos . This article uses Western name order when mentioning individuals.",
    "source_url": "https://en.wikipedia.org/wiki/John_von_Neumann",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:05:18.449439",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:05:18.449439",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:05:18.449439",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithmic_paradigm&oldid=1210574096_1_1749013534775_5005",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by David Eppstein ( talk | contribs ) at 08:18, 27 February 2024 (Reverted edit by 197.28.224.21 ( talk ) to last version by David Eppstein) . The present address (URL) is a permanent link to this version. Revision as of 08:18, 27 February 2024 by David Eppstein ( talk | contribs ) (Reverted edit by 197.28.224.21 ( talk ) to last version by David Eppstein) ( diff ) ← Previous revision | Lat",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithmic_paradigm&oldid=1210574096",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:05:34.775758",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:05:34.775758",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:05:34.775758",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Domain_reduction_algorithm_1_1749013553631_7541",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article is an orphan , as no other articles link to it . Please introduce links to this page from related articles ; try the Find link tool for suggestions. ( August 2024 ) This article relies largely or entirely on a single source . Relevant discussion may be found on the talk page . Please ",
    "source_url": "https://en.wikipedia.org/wiki/Domain_reduction_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:05:53.631473",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:05:53.631473",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:05:53.631473",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lion_algorithm_1_1749013556040_5096",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article may be too technical for most readers to understand . Please help improve it to make it understandable to non-experts , without removing the technical details. ( February 2021 ) ( Learn how and when to remove this message ) This article may be confusing or unclear to readers . Please ",
    "source_url": "https://en.wikipedia.org/wiki/Lion_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:05:56.040363",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:05:56.040363",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:05:56.040363",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Medical_algorithm_1_1749013557191_6444",
    "text": "Jump to content From Wikipedia, the free encyclopedia You can help expand this article with text translated from the corresponding article in Russian . (September 2015) Click [show] for important translation instructions. Machine translation, like DeepL or Google Translate , is a useful starting point for translations, but translators must revise errors as necessary and confirm that the translation is accurate, rather than simply copy-pasting machine-translated text into the English Wikipedia. D",
    "source_url": "https://en.wikipedia.org/wiki/Medical_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:05:57.191726",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:05:57.192726",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:05:57.192726",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shapiro%E2%80%93Senapathy_algorithm_1_1749013559155_5373",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article contains promotional content . Please help improve it by removing promotional language and inappropriate external links , and by adding encyclopedic text written from a neutral point of view . ( April 2020 ) ( Learn how and when to remove this message ) This article is written like a ",
    "source_url": "https://en.wikipedia.org/wiki/Shapiro%E2%80%93Senapathy_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:05:59.155623",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:05:59.155623",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:05:59.155623",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Algorithms&oldid=1213126206_1_1749013561327_7164",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by John of Reading ( talk | contribs ) at 07:11, 11 March 2024 (Reverted 1 edit by 180.251.144.227 ( talk ) to last revision by Conan) . The present address (URL) is a permanent link to this version. Revision as of 07:11, 11 March 2024 by John of Reading ( talk | contribs ) (Reverted 1 edit by 180.251.144.227 ( talk ) to last revision by Conan) ( diff ) ← Previous revision | Latest rev",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Algorithms&oldid=1213126206",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:06:01.327529",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:06:01.327529",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:06:01.327529",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Extended_Euclidean_algorithm_1_1749013563735_1105",
    "text": "As a = r 0 {\\displaystyle a=r_{0}} and b = r 1 , {\\displaystyle b=r_{1},} we have a s i + b t i = r i {\\displaystyle as_{i}+bt_{i}=r_{i}} for i = 0 and 1. The relation follows by induction for all i > 1 {\\displaystyle i>1} : r i + 1 = r i − 1 − r i q i = ( a s i − 1 + b t i − 1 ) − ( a s i + b t i ) q i = ( a s i − 1 − a s i q i ) + ( b t i − 1 − b t i q i ) = a s i + 1 + b t i + 1 . { \\displaystyle r_{i+1}=r_{i-1}-r_{i}q_{i}=(as_{i-1}+bt_{i-1})-(as_{i}+bt_{i})q_{i}=(as_{i-1}-as_{i}q_{i})+(bt_{i-1}-bt_{i}q_{i})=as_{i+1}+bt_{i+1}.} Thus s k {\\displaystyle s_{k}} and t k {\\displaystyle t_{k}} are Bézout coefficients. Consider the matrix A i = ( s i − 1 s i t i − 1 t i ) . {\\displaystyle A_{i}={\\begin{pmatrix}s_{i-1}&s_{i}\\\\t_{i-1}&t_{i}\\end{pmatrix}}.} The recurrence relation may be rewritten in matrix form A i + 1 = A i ⋅ ( 0 1 1 − q i ) . {\\displaystyle A_{i+1}=A_{i}\\cdot {\\begin{pmatrix}0&1\\\\1&-q_{i}\\end{pmatrix}}.}",
    "source_url": "https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:06:03.735513",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:06:03.735513",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:06:03.735513",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Extended_Euclidean_algorithm_1_1749013563765_9000",
    "text": "{\\displaystyle A_{i+1}=A_{i}\\cdot {\\begin{pmatrix}0&1\\\\1&-q_{i}\\end{pmatrix}}.} The matrix A 1 {\\displaystyle A_{1}} is the identity matrix and its determinant is one. The determinant of the rightmost matrix in the preceding formula is −1. It follows that the determinant of A i {\\displaystyle A_{i}} is ( − 1 ) i − 1 . {\\displaystyle (-1)^{i-1}.} In particular, for i = k + 1 , {\\displaystyle i=k+1,} we have s k t k + 1 − t k s k + 1 = ( − 1 ) k . {\\displaystyle s_{k}t_{k+1}-t_{k}s_{k+1}=(-1)^{k}.} Viewing this as a Bézout's identity, this shows that s k + 1 {\\displaystyle s_{k+1}} and t k + 1 {\\displaystyle t_{k+1}} are coprime . The relation a s k + 1 + b t k + 1 = 0 {\\displaystyle as_{k+1}+bt_{k+1}=0} that has been proved above and Euclid's lemma show that s k + 1 {\\displaystyle s_{k+1}} divides b , that is that b = d s k + 1 {\\displaystyle b=ds_{k+1}} for some integer d .",
    "source_url": "https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:06:03.765716",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:06:03.765716",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:06:03.765716",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Extended_Euclidean_algorithm_1_1749013563800_5233",
    "text": "Dividing by s k + 1 {\\displaystyle s_{k+1}} the relation a s k + 1 + b t k + 1 = 0 {\\displaystyle as_{k+1}+bt_{k+1}=0} gives a = − d t k + 1 . {\\displaystyle a=-dt_{k+1}.} So, s k + 1 {\\displaystyle s_{k+1}} and − t k + 1 {\\displaystyle -t_{k+1}} are coprime integers that are the quotients of a and b by a common factor, which is thus their greatest common divisor or its opposite . To prove the last assertion, assume that a and b are both positive and gcd ( a , b ) ≠ min ( a , b ) {\\displaystyle \\gcd(a,b)\\neq \\min(a,b)} . Then, a ≠ b {\\displaystyle a\\neq b} , and  if a < b {\\displaystyle a<b} , it can be seen that the s and t sequences for ( a , b ) under the EEA are, up to initial 0s and 1s, the t and s sequences for ( b , a ). The definitions then show that the ( a , b ) case reduces to the ( b , a ) case. So assume that a > b {\\displaystyle a>b} without loss of generality .",
    "source_url": "https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:06:03.800240",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:06:03.801240",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:06:03.801240",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Extended_Euclidean_algorithm&oldid=1285730579_1_1749013565449_1687",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by D.Lazard ( talk | contribs ) at 12:32, 15 April 2025 ( → Simplification of fractions : fixing minus) . The present address (URL) is a permanent link to this version. Revision as of 12:32, 15 April 2025 by D.Lazard ( talk | contribs ) ( → Simplification of fractions : fixing minus) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Method for computing the rel",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Extended_Euclidean_algorithm&oldid=1285730579",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:06:05.449663",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:06:05.449663",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:06:05.449663",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Integer_relation_algorithm&oldid=1285523551_1_1749013568095_8819",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Altenmann ( talk | contribs ) at 06:13, 14 April 2025 (Reverted 1 edit by Harajaru345tyu ( talk ): Rv stupid ai spellchecker) . The present address (URL) is a permanent link to this version. Revision as of 06:13, 14 April 2025 by Altenmann ( talk | contribs ) (Reverted 1 edit by Harajaru345tyu ( talk ): Rv stupid ai spellchecker) ( diff ) ← Previous revision | Latest revision (diff) | Ne",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Integer_relation_algorithm&oldid=1285523551",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:06:08.095573",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:06:08.095573",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:06:08.095573",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm_1_1749013570134_1632",
    "text": "LLL reduction [ edit ] The precise definition of LLL-reduced is as follows: Given a basis B = { b 1 , b 2 , … , b n } , {\\displaystyle \\mathbf {B} =\\{\\mathbf {b} _{1},\\mathbf {b} _{2},\\dots ,\\mathbf {b} _{n}\\},} define its Gram–Schmidt process orthogonal basis B ∗ = { b 1 ∗ , b 2 ∗ , … , b n ∗ } , {\\displaystyle \\mathbf {B} ^{*}=\\{\\mathbf {b} _{1}^{*},\\mathbf {b} _{2}^{*},\\dots ,\\mathbf {b} _{n}^{*}\\},} and the Gram-Schmidt coefficients μ i , j = ⟨ b i , b j ∗ ⟩ ⟨ b j ∗ , b j ∗ ⟩ , {\\displaystyle \\mu _{ i,j}={\\frac {\\langle \\mathbf {b} _{i},\\mathbf {b} _{j}^{*}\\rangle }{\\langle \\mathbf {b} _{j}^{*},\\mathbf {b} _{j}^{*}\\rangle }},} for any 1 ≤ j < i ≤ n {\\displaystyle 1\\leq j<i\\leq n} . Then the basis B {\\displaystyle B} is LLL-reduced if there exists a parameter δ {\\displaystyle \\delta } in (0.25, 1] such that the following holds: (size-reduced) For 1 ≤ j < i ≤ n : | μ i , j | ≤ 0.5 {\\displaystyle 1\\leq j<i\\leq n\\colon \\left|\\mu _{i,j}\\right|\\leq 0.5} .",
    "source_url": "https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:06:10.134760",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:06:10.134760",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:06:10.134760",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm_1_1749013570358_1658",
    "text": "In particular, for δ = 3 / 4 {\\displaystyle \\delta =3/4} , this gives ‖ b 1 ‖ ≤ 2 ( n − 1 ) / 2 ⋅ λ 1 ( L ) {\\displaystyle \\Vert \\mathbf {b} _{1}\\Vert \\leq 2^{(n-1)/2}\\cdot \\lambda _{1}({\\mathcal {L}})} . [ 8 ] The first vector in the basis is also bounded by the determinant of the lattice: ‖ b 1 ‖ ≤ ( 2 / ( 4 δ − 1 ) ) ( n − 1 ) / 2 ⋅ ( det ( L ) ) 1 / n {\\displaystyle \\Vert \\mathbf {b} _{1}\\Vert \\leq (2/({\\sqrt {4\\delta -1}}))^{(n-1)/2}\\cdot (\\det({\\mathcal {L}}))^{1/n}} . In particular, for δ = 3 / 4 {\\displaystyle \\delta =3/4} , this gives ‖ b 1 ‖ ≤ 2 ( n − 1 ) / 4 ⋅ ( det ( L ) ) 1 / n {\\displaystyle \\Vert \\mathbf {b} _{1}\\Vert \\leq 2^{(n-1)/4}\\cdot (\\det({\\mathcal {L}}))^{1/n}} .",
    "source_url": "https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:06:10.358975",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:06:10.358975",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:06:10.358975",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm_1_1749013570460_4133",
    "text": "(The naive method is to recompute B * whenever b i changes: B * <- GramSchmidt({ b 1 , ..., b n }) = { b 1 * , ..., b n * }) end if end for if InnerProduct( b k * , b k * ) > ( δ − μ 2 k , k −1 ) InnerProduct( b k −1 * , b k −1 * ) then k <- k + 1; else Swap b k and b k −1 ; Update B * and the related μ i , j 's as needed. k <- max( k −1, 2); end if end while return B the LLL reduced basis of {b 1 , ..., b n } OUTPUT the reduced basis b 1 , b 2 , ..., b n in Z m Examples [ edit ] Example from Z 3 [ edit ] Let a lattice basis b 1 , b 2 , b 3 ∈ Z 3 {\\displaystyle \\mathbf {b} _{1},\\mathbf {b} _{2},\\mathbf {b} _{3}\\in \\mathbf {Z} ^{3}} , be given by the columns of [ 1 − 1 3 1 0 5 1 2 6 ] {\\displaystyle {\\begin{bmatrix}1&-1&3\\\\1&0&5\\\\1&2&6\\end{bmatrix}}} then the reduced basis is [ 0 1 − 1 1 0 0 0 1 2 ] , {\\displaystyle {\\begin{bmatrix}0&1&-1\\\\1&0&0\\\\0&1&2\\end{bmatrix}},} which is size-reduced, satisfies the Lovász condition, and is hence LLL-reduced, as described above. See W. Bosma.",
    "source_url": "https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:06:10.460518",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:06:10.460518",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:06:10.460518",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm_1_1749013570502_7681",
    "text": "See W. Bosma. [ 10 ] for details of the reduction process. Example from Z[ i ] 4 [ edit ] Likewise, for the basis over the complex integers given by the columns of the matrix below, [ − 2 + 2 i 7 + 3 i 7 + 3 i − 5 + 4 i 3 + 3 i − 2 + 4 i 6 + 2 i − 1 + 4 i 2 + 2 i − 8 + 0 i − 9 + 1 i − 7 + 5 i 8 + 2 i − 9 + 0 i 6 + 3 i − 4 + 4 i ] , {\\displaystyle {\\begin{bmatrix}-2+2i&7+3i&7+3i&-5+4i\\\\3+3i&-2+4i&6+2i&-1+4i\\\\2+2i&-8+0i&-9+1i&-7+5i\\\\8+2i&-9+0i&6+3i&-4+4i\\end{bmatrix}},} then the columns of the matrix below give an LLL-reduced basis. [ − 6 + 3 i − 2 + 2 i 2 − 2 i − 3 + 6 i 6 − 1 i 3 + 3 i 5 − 5 i 2 + 1 i 2 − 2 i 2 + 2 i − 3 − 1 i − 5 + 3 i − 2 + 1 i 8 + 2 i 7 + 1 i − 2 − 4 i ] . {\\displaystyle {\\begin{bmatrix}-6+3i&-2+2i&2-2i&-3+6i\\\\6-1i&3+3i&5-5i&2+1i\\\\2-2i&2+2i&-3-1i&-5+3i\\\\-2+1i&8+2i&7+1i&-2-4i\\\\\\end{bmatrix}}.}",
    "source_url": "https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:06:10.502074",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:06:10.502074",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:06:10.502074",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_mathematical_functions_1_1749014005037_4282",
    "text": "Jump to content From Wikipedia, the free encyclopedia In mathematics , some functions or groups of functions are important enough to deserve their own names. This is a listing of articles which explain some of these functions in more detail. There is a large theory of special functions which developed out of statistics and mathematical physics . A modern, abstract point of view contrasts large function spaces , which are infinite-dimensional and within which most functions are 'anonymous', with special functions picked out by properties such as symmetry , or relationship to harmonic analysis and group representations . See also List of types of functions Elementary functions [ edit ] Elementary functions are functions built from basic operations (e.g. addition, exponentials, logarithms...) Algebraic functions [ edit ] Algebraic functions are functions that can be expressed as the solution of a polynomial equation with integer coefficients.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_mathematical_functions",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:25.037934",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:25.037934",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:25.037934",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_mathematical_functions_1_1749014005062_4227",
    "text": "Polynomials : Can be generated solely by addition, multiplication, and raising to the power of a positive integer. Constant function : polynomial of degree zero, graph is a horizontal straight line Linear function : First degree polynomial, graph is a straight line. Quadratic function : Second degree polynomial, graph is a parabola . Cubic function : Third degree polynomial. Quartic function : Fourth degree polynomial. Quintic function : Fifth degree polynomial. Rational functions : A ratio of two polynomials. n th root Square root : Yields a number whose square is the given one. Cube root : Yields a number whose cube is the given one. Elementary transcendental functions [ edit ] Transcendental functions are functions that are not algebraic. Exponential function : raises a fixed number to a variable power. Hyperbolic functions : formally similar to the trigonometric functions .",
    "source_url": "https://en.wikipedia.org/wiki/List_of_mathematical_functions",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:25.062440",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:25.062440",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:25.062440",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_mathematical_functions_1_1749014005113_7972",
    "text": "See also Gudermannian function . Special functions [ edit ] Main article: Special functions Piecewise special functions [ edit ] Indicator function : maps x to either 1 or 0, depending on whether or not x belongs to some subset. Step function : A finite linear combination of indicator functions of half-open intervals . Heaviside step function : 0 for negative arguments and 1 for positive arguments. The integral of the Dirac delta function . Sawtooth wave Square wave Triangle wave Rectangular function Floor function : Largest integer less than or equal to a given number. Ceiling function : Smallest integer larger than or equal to a given number. Sign function : Returns only the sign of a number, as +1, −1 or 0. Absolute value : distance to the origin (zero point) Arithmetic functions [ edit ] Main article: Arithmetic function Sigma function : Sums of powers of divisors of a given natural number . Euler's totient function : Number of numbers coprime to (and not bigger than) a given one.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_mathematical_functions",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:25.113614",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:25.113614",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:25.113614",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_mathematical_functions_1_1749014005142_2994",
    "text": "Euler's totient function : Number of numbers coprime to (and not bigger than) a given one. Prime-counting function :  Number of primes less than or equal to a given number. Partition function :  Order-independent count of ways to write a given positive integer as a sum of positive integers. Möbius μ function : Sum of the nth primitive roots of unity, it depends on the prime factorization of n. Prime omega functions Chebyshev functions Liouville function , λ( n ) = (–1) Ω( n ) Von Mangoldt function , Λ( n ) = log p if n is a positive power of the prime p Carmichael function Antiderivatives of elementary functions [ edit ] Logarithmic integral function : Integral of the reciprocal of the logarithm, important in the prime number theorem . Exponential integral Trigonometric integral : Including Sine Integral and Cosine Integral Inverse tangent integral Error function : An integral important for normal random variables . Fresnel integral : related to the error function; used in optics .",
    "source_url": "https://en.wikipedia.org/wiki/List_of_mathematical_functions",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:25.142426",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:25.142426",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:25.142426",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_mathematical_proofs_1_1749014007241_4231",
    "text": "Jump to content From Wikipedia, the free encyclopedia A list of articles with mathematical proofs : Theorems of which articles are primarily devoted to proving them [ edit ] See also: Category:Article proofs Bertrand's postulate and a proof Estimation of covariance matrices Fermat's little theorem and some proofs Gödel's completeness theorem and its original proof Mathematical induction and a proof Proof that 0.999... equals 1 Proof that 22/7 exceeds π Proof that e is irrational Proof that π is irrational Proof that the sum of the reciprocals of the primes diverges Articles devoted to theorems of which a (sketch of a) proof is given [ edit ] See also: Category:Articles containing proofs Banach fixed-point theorem Banach–Tarski paradox Basel problem Bolzano–Weierstrass theorem Brouwer fixed-point theorem Buckingham π theorem (proof in progress) Burnside's lemma Cantor's theorem Cantor–Bernstein–Schroeder theorem Cayley's formula Cayley's theorem Clique problem (to do)",
    "source_url": "https://en.wikipedia.org/wiki/List_of_mathematical_proofs",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:27.241100",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:27.241100",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:27.241100",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_mathematical_proofs_1_1749014007263_4474",
    "text": "Compactness theorem (very compact proof) Erdős–Ko–Rado theorem Euler's formula Euler's four-square identity Euler's theorem Five color theorem Five lemma Fundamental theorem of arithmetic Gauss–Markov theorem (brief pointer to proof) Gödel's incompleteness theorem Gödel's first incompleteness theorem Gödel's second incompleteness theorem Goodstein's theorem Green's theorem (to do) Green's theorem when D is a simple region Heine–Borel theorem Intermediate value theorem Itô's lemma Kőnig's lemma Kőnig's theorem (set theory) Kőnig's theorem (graph theory) Lagrange's theorem (group theory) Lagrange's theorem (number theory) Liouville's theorem (complex analysis) Markov's inequality (proof of a generalization) Mean value theorem Multivariate normal distribution (to do)",
    "source_url": "https://en.wikipedia.org/wiki/List_of_mathematical_proofs",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:27.263607",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:27.263607",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:27.263607",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_mathematical_proofs_1_1749014007348_9557",
    "text": "Angle of parallelism Galois group Fundamental theorem of Galois theory (to do) Gödel number Gödel's incompleteness theorem Group (mathematics) Halting problem insolubility of the halting problem Harmonic series (mathematics) divergence of the (standard) harmonic series Highly composite number Area of hyperbolic sector , basis of hyperbolic angle Infinite series convergence of the geometric series with first term 1 and ratio 1/2 Integer partition Irrational number irrationality of log 2 3 irrationality of the square root of 2 Mathematical induction sum identity Power rule differential of x n Product and Quotient Rules Derivation of Product and Quotient rules for differentiating. Prime number Infinitude of the prime numbers Primitive recursive function Principle of bivalence no propositions are neither true nor false in intuitionistic logic Recursion Relational algebra (to do)",
    "source_url": "https://en.wikipedia.org/wiki/List_of_mathematical_proofs",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:27.348091",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:27.348091",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:27.348091",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_misnamed_theorems_1_1749014011739_6732",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is a list of misnamed theorems in mathematics . It includes theorems (and lemmas , corollaries, conjectures , laws, and perhaps even the odd object) that are well known in mathematics, but which are not named for the originator. That is, these items on this list illustrate Stigler's law of eponymy (which is not, of course, due to Stephen Stigler , who credits Robert K Merton ). Applied mathematics Benford's law Benford's law . This was first stated in 1881 by Simon Newcomb , [ 1 ] and rediscovered in 1938 by Frank Benford . [ 2 ] The first rigorous formulation and proof seems to be due to Ted Hill in 1988.; [ 3 ] see also the contribution by Persi Diaconis . [ 4 ] Bertrand's ballot theorem . This result concerning the probability that the winner of an election was ahead at each step of ballot counting was first published by W. A. Whitworth in 1878, but named after Joseph Louis François Bertrand who rediscovered it in 1887.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_misnamed_theorems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:31.739920",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:31.739920",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:31.739920",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_misnamed_theorems_1_1749014011768_7675",
    "text": "[ 5 ] A common proof uses André's reflection method , though the proof by Désiré André did not use any reflections. Algebra [ edit ] Burnside's lemma . This was stated and proved without attribution in Burnside's 1897 textbook, [ 6 ] but it had previously been discussed by Augustin Cauchy , in 1845, and by Georg Frobenius in 1887. Cayley–Hamilton theorem . The theorem was first proved in the easy special case of 2×2 matrices by Cayley , and later for the case of 4×4 matrices by Hamilton . But it was only proved in general by Frobenius in 1878. [ 7 ] Hölder's inequality . This inequality was first established by Leonard James Rogers , and published in 1888. Otto Hölder discovered it independently, and published it in 1889. Marden's theorem . This theorem relating the location of the zeros of a complex cubic polynomial to the zeros of its derivative was named by Dan Kalman after Kalman read it in a 1966 book by Morris Marden , who had first written about it in 1945.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_misnamed_theorems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:31.768446",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:31.768446",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:31.768446",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_misnamed_theorems_1_1749014011796_4706",
    "text": "[ 8 ] But, as Marden had himself written, its original proof was by Jörg Siebeck in 1864. [ 9 ] Pólya enumeration theorem . This was proven in 1927 in a difficult paper by J. H. Redfield . [ 10 ] Despite the prominence of the venue (the American Journal of Mathematics ), the paper was overlooked. Eventually, the theorem was independently rediscovered in 1936 by George Pólya . [ 11 ] Not until 1960 did Frank Harary unearth the much earlier paper by Redfield. See [ 12 ] for historical and other information. Analysis [ edit ] Frobenius theorem . This fundamental theorem was stated and proved in 1840 by Feodor Deahna . [ 13 ] Even though Frobenius cited Deahna's paper in his own 1875 paper, [ 14 ] it became known after Frobenius, not Deahna. See [ 15 ] for a historical review. L'Hôpital's rule . This rule first appeared in l'Hôpital's book L'Analyse des Infiniment Petits pour l'Intelligence des Lignes Courbes in 1696.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_misnamed_theorems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:31.796447",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:31.797439",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:31.797439",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_misnamed_theorems_1_1749014011852_1104",
    "text": "The theorem acquired its name from Stokes' habit of including it in the Cambridge prize examinations. In 1854 he asked his students to prove the theorem in an examination; it is not known if anyone was able to do so. [ 18 ] Geometry and topology [ edit ] Ceva's theorem . The oldest extant proof can be found in Yusuf al-Mu'taman ibn Hud 's 11th century Kitab al-Istikmal ( Book of Perfection ), about six centuries before Giovanni Ceva 's 1678 De lineis rectis ( On straight lines ). [ 19 ] Cramer's paradox . This was first noted by Colin Maclaurin in 1720, and then rediscovered by Leonhard Euler in 1748 (whose paper was not published for another two years, as Euler wrote his papers faster than his printers could print them). It was also discussed by Gabriel Cramer in 1750, who independently suggested the essential idea needed for the resolution, although providing a rigorous proof remained an outstanding open problem for much of the 19th century.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_misnamed_theorems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:31.852849",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:31.852849",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:31.852849",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_misnamed_theorems_1_1749014011874_5807",
    "text": "Even though Cramer had cited Maclaurin, the paradox became known after Cramer rather than Maclaurin. Georges Halphen , Arthur Cayley , and several other mathematicians contributed to the earliest more or less correct proof. See [ 20 ] for an excellent review. Heine–Borel theorem . This theorem was proved in 1872 by Émile Borel , not by Eduard Heine . Borel used techniques similar to those that Heine used to prove that continuous functions on closed intervals are uniformly continuous. Heine's name was attached because Schönflies noticed the similarity in Heine's and Borel's approaches. In fact, the theorem was first proved in 1852 by Peter Gustav Lejeune Dirichlet , but Lejeune Dirichlet's lecture notes were not published until 1904. [ 21 ] Models of hyperbolic geometry.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_misnamed_theorems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:31.874862",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:31.874862",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:31.874862",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_misnamed_theorems_1_1749014011901_6342",
    "text": "[ 21 ] Models of hyperbolic geometry. \"By one of the injustices of nomenclature that are so common in mathematics, the three models – which could appropriately be called Riemann-Beltrami, Liouville-Beltrami, and Cayley-Beltrami models – are usually known as the Poincaré disk model , the Poincaré half-plane model and the Klein disk model .\" [ 22 ] Morrie's law . The name is due to physicist Richard Feynman , who used to refer to the identity under that name. Feynman picked that name because he had learned the law during his childhood from a boy with the name Morrie Jacobs. [ 23 ] Plimpton 322, a tablet that contained several Pythagorean triples Pythagoras' theorem . This was known to ancient Mesopotamian mathematicians over one thousand years before Pythagoras was born. [ 24 ] Number theory [ edit ] Bézout's theorem . The statement may have been made first by Isaac Newton in 1665.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_misnamed_theorems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:31.901858",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:31.901858",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:31.901858",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_misnamed_theorems_1_1749014011929_9000",
    "text": "The statement may have been made first by Isaac Newton in 1665. The matter of a proof was taken up by Colin MacLaurin (c. 1720) and Leonhard Euler as well as Étienne Bézout (c. 1750). However, Bézout's \"proof\" was incorrect . The first correct proof seems to be due mostly to Georges-Henri Halphen in the 1870s. [ 25 ] Cramer's rule . It is named after Gabriel Cramer (1704–1752), who published the rule in his 1750 Introduction à l'analyse des lignes courbes algébriques , although Colin Maclaurin also published the method in his 1748 Treatise of Algebra (and probably knew of the method as early as 1729). [ 26 ] Pell's equation . The solution of the equation x 2 − dy 2 = 1, where x and y are unknown positive integers and where d is a known positive integer which is not a perfect square, is ascribed to John Pell . It seems to have been discovered by Fermat , who set it as a challenge problem in 1657.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_misnamed_theorems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:31.929922",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:31.929922",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:31.929922",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_misnamed_theorems_1_1749014011992_8407",
    "text": "The theorem was discovered by Chevalley in 1936, and published and attributed to Zorn by him in Bourbaki's Théorie des Ensembles in 1939. A very similar result was anticipated by S. Bochner in 1928. [ 29 ] See also [ edit ] List of examples of Stigler's law List of multiple discoveries List of theorems Matthew effect References [ edit ] ^ Newcomb, S. (1881). \"Note on the frequency of use of the different digits in natural numbers\". Amer. J. Math. 4 (1). The Johns Hopkins University Press: 39– 40. Bibcode : 1881AmJM....4...39N . doi : 10.2307/2369148 . JSTOR 2369148 . ^ Benford, F. (1938). \"The law of anomalous numbers\". Proc. Am. Philos. Soc. 78 : 551– 572. Bibcode : 1938PAPhS..78..551B . ^ Hill, Theodore P. (April 1995). \"The Significant Digit Phenomenon\" . Amer. Math. Monthly . 102 (4). Mathematical Association of America: 322– 327. doi : 10.2307/2974952 . JSTOR 2974952 . ^ Diaconis, Persi (1977). \"The distribution of leading digits and uniform distribution mod 1\" . Ann. Probab.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_misnamed_theorems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:31.992448",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:31.992448",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:31.992448",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_alternative_set_theories_1_1749014013681_2549",
    "text": "Jump to content From Wikipedia, the free encyclopedia Alternative to the standard Zermelo–Fraenkel set theory This article relies largely or entirely on a single source . Relevant discussion may be found on the talk page . Please help improve this article by introducing  citations to additional sources . Find sources: \"List of alternative set theories\" – news · newspapers · books · scholar · JSTOR ( September 2023 ) See also: Vopěnka's alternative set theory In mathematical logic , an alternative set theory is any of the alternative mathematical approaches to the concept of set and any alternative to the de facto standard set theory described in axiomatic set theory by the axioms of Zermelo–Fraenkel set theory .",
    "source_url": "https://en.wikipedia.org/wiki/List_of_alternative_set_theories",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:33.681913",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:33.681913",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:33.681913",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_alternative_set_theories_1_1749014013739_9919",
    "text": "Stanford Encyclopedia of Philosophy . Retrieved 17 January 2020 . v t e Set theory Overview Set (mathematics) Axioms Adjunction Choice countable dependent global Constructibility (V=L) Determinacy projective Extensionality Infinity Limitation of size Pairing Power set Regularity Union Martin's axiom Axiom schema replacement specification Operations Cartesian product Complement (i.e. set difference) De Morgan's laws Disjoint union Identities Intersection Power set Symmetric difference Union Concepts Methods Almost Cardinality Cardinal number ( large ) Class Constructible universe Continuum hypothesis Diagonal argument Element ordered pair tuple Family Forcing One-to-one correspondence Ordinal number Set-builder notation Transfinite induction Venn diagram Set types Amorphous Countable Empty Finite ( hereditarily ) Filter base subbase Ultrafilter Fuzzy Infinite ( Dedekind-infinite ) Recursive Singleton Subset ·",
    "source_url": "https://en.wikipedia.org/wiki/List_of_alternative_set_theories",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:33.739244",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:33.739244",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:33.739244",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_by_Paul_Erd%C5%91s_1_1749014015804_6503",
    "text": "The Erdős conjecture on arithmetic progressions in sequences with divergent sums of reciprocals. The Erdős–Szekeres conjecture on the number of points needed to ensure that a point set contains a large convex polygon. The Erdős–Turán conjecture on additive bases of natural numbers. A conjecture on quickly growing integer sequences with rational reciprocal series . A conjecture with Norman Oler [ 2 ] on circle packing in an equilateral triangle with a number of circles one less than a triangular number . The minimum overlap problem to estimate the limit of M ( n ). A conjecture that the ternary expansion of 2 n {\\displaystyle 2^{n}} contains at least one digit 2 for every n > 8 {\\displaystyle n>8} . [ 3 ] The conjecture that the Erdős–Moser equation , 1 k + 2 k + ⋯ + ( m − 1) k = m k , has no solutions except 1 1 + 2 1 = 3 1 . Solved [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures_by_Paul_Erd%C5%91s",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:35.804798",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:35.804798",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:35.804798",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_by_Paul_Erd%C5%91s_1_1749014015833_8950",
    "text": "= m k , has no solutions except 1 1 + 2 1 = 3 1 . Solved [ edit ] The Erdős–Faber–Lovász conjecture on coloring unions of cliques, proved (for all large n) by Dong Yeap Kang, Tom Kelly, Daniela Kühn , Abhishek Methuku, and Deryk Osthus . [ 4 ] The Erdős sumset conjecture on sets, proven by Joel Moreira, Florian Karl Richter, Donald Robertson in 2018. The proof has appeared in \" Annals of Mathematics \" in March 2019. [ 5 ] The Burr–Erdős conjecture on Ramsey numbers of graphs, proved by Choongbum Lee in 2015. [ 6 ] [ 7 ] A conjecture on equitable colorings proven in 1970 by András Hajnal and Endre Szemerédi and now known as the Hajnal–Szemerédi theorem . [ 8 ] A conjecture that would have strengthened the Furstenberg–Sárközy theorem to state that the number of elements in a square-difference-free set of positive integers could only exceed the square root of its largest value by a polylogarithmic factor, disproved by András Sárközy in 1978.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures_by_Paul_Erd%C5%91s",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:35.833859",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:35.834867",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:35.834867",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_by_Paul_Erd%C5%91s_1_1749014015894_7768",
    "text": "[ 16 ] The Erdős–Rankin conjecture on prime gaps, proved by Ford , Green , Konyagin , and Tao in 2014. [ 17 ] The Erdős discrepancy problem on partial sums of ±1-sequences. Terence Tao announced a solution in September 2015; it was published in 2016. [ 18 ] The Erdős squarefree conjecture that central binomial coefficients C(2 n , n ) are never squarefree for n > 4 was proved in 1996. [ 19 ] [ 20 ] The Erdős primitive set conjecture that the sum ∑ n ∈ A 1 n log ⁡ n {\\displaystyle \\sum _{n\\in A}{\\frac {1}{n\\log n}}} for any primitive set A (a set where no member of the set divides another member) attains its maximum at the set of primes numbers, proved by Jared Duker Lichtman in 2022. [ 21 ] [ 22 ] [ 23 ] The Erdős-Sauer problem about maximum number of edges an n-vertex graph can have without containing a k- regular subgraph, solved by Oliver Janzer and Benny Sudakov [ 24 ] [ 25 ] See also [ edit ] List of things named after Paul Erdős References [ edit ] ^",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures_by_Paul_Erd%C5%91s",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:35.894394",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:35.895386",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:35.895386",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_by_Paul_Erd%C5%91s_1_1749014015929_8990",
    "text": "Erdős, P. ; Hajnal, A. (1989), \"Ramsey-type theorems\", Combinatorics and complexity (Chicago, IL, 1987), Discrete Applied Mathematics , 25 ( 1– 2): 37– 52, doi : 10.1016/0166-218X(89)90045-0 , MR 1031262 . ^ Oler, Norman (1961), \"A finite packing problem\", Canadian Mathematical Bulletin , 4 (2): 153– 155, doi : 10.4153/CMB-1961-018-7 , MR 0133065 . ^ Lagarias, Jeffrey C. (2009), \"Ternary expansions of powers of 2\", Journal of the London Mathematical Society , Second Series, 79 (3): 562– 588, arXiv : math/0512006 , doi : 10.1112/jlms/jdn080 , MR 2506687 , S2CID 15615918 ^ Houston-Edwards, Kelsey (5 April 2021), \"Mathematicians Settle Erdős Coloring Conjecture\" , Quanta Magazine , retrieved 2021-04-05 ^ Moreira, J.; Richter, F. K.; Robertson, D. (2019), \"A proof of a sumset conjecture of Erdős\", Annals of Mathematics , 189 (2): 605– 652, arXiv : 1803.00498 , doi : 10.4007/annals.2019.189.2.4 , MR 3919363 , S2CID 119158401 , Zbl 1407.05236 . ^",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures_by_Paul_Erd%C5%91s",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:35.929836",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:35.929836",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:35.929836",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_by_Paul_Erd%C5%91s_1_1749014015964_5346",
    "text": "1803.00498 , doi : 10.4007/annals.2019.189.2.4 , MR 3919363 , S2CID 119158401 , Zbl 1407.05236 . ^ Kalai, Gil (May 22, 2015), \"Choongbum Lee proved the Burr-Erdős conjecture\" , Combinatorics and more , retrieved 2015-05-22 ^ Lee, Choongbum (2017), \"Ramsey numbers of degenerate graphs\", Annals of Mathematics , 185 (3): 791– 829, arXiv : 1505.04773 , doi : 10.4007/annals.2017.185.3.2 , S2CID 7974973 ^ Hajnal, A. ; Szemerédi, E. (1970), \"Proof of a conjecture of P. Erdős\", Combinatorial theory and its applications, II (Proc. Colloq., Balatonfüred, 1969) , North-Holland, pp. 601– 623, MR 0297607 . ^ Sárközy, A. (1978), \"On difference sets of sequences of integers. II\", Annales Universitatis Scientiarum Budapestinensis de Rolando Eötvös Nominatae , 21 : 45–53 (1979), MR 0536201 . ^ Deza, M. (1974), \"Solution d'un problème de Erdős-Lovász\", Journal of Combinatorial Theory , Series B (in French), 16 (2): 166– 167, doi : 10.1016/0095-8956(74)90059-8 , MR 0337635 .",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures_by_Paul_Erd%C5%91s",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:35.964025",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:35.964025",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:35.964025",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_by_Paul_Erd%C5%91s_1_1749014016032_5084",
    "text": "Green, Ben (2004), \"The Cameron-Erdős conjecture\", Bulletin of the London Mathematical Society , 36 (6): 769– 778, arXiv : math.NT/0304058 , doi : 10.1112/S0024609304003650 , MR 2083752 , S2CID 119615076 . ^ Aharoni, Ron ; Berger, Eli (2009), \"Menger's Theorem for infinite graphs\", Inventiones Mathematicae , 176 (1): 1– 62, arXiv : math/0509397 , Bibcode : 2009InMat.176....1A , doi : 10.1007/s00222-008-0157-3 , S2CID 15355399 . ^ Guth, Larry ; Katz, Nets H. (2015), \"On the Erdős distinct distances problem in the plane\", Annals of Mathematics , Second series, 181 (1): 155– 190, arXiv : 1011.4105 , doi : 10.4007/annals.2015.181.1.2 . ^ Ford, Kevin; Green, Ben; Konyagin, Sergei; Tao, Terence (2016), \"Large gaps between consecutive prime numbers\", Annals of Mathematics , Second series, 183 (3): 935– 974, arXiv : 1408.4505 , doi : 10.4007/annals.2016.183.3.4 ^ Tao, Terence (2016). \"The Erdős discrepancy problem\". Discrete Analysis : 1– 29. arXiv : 1509.05363 . doi : 10.19086/da.609 .",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures_by_Paul_Erd%C5%91s",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:36.032441",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:36.032441",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:36.032441",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_by_Paul_Erd%C5%91s_1_1749014016065_9184",
    "text": "Discrete Analysis : 1– 29. arXiv : 1509.05363 . doi : 10.19086/da.609 . ISSN 2397-3129 . MR 3533300 . S2CID 59361755 . ^ Sárközy, A. (1985), \"On divisors of binomial coefficients. I\", Journal of Number Theory , 20 (1): 70– 80, doi : 10.1016/0022-314X(85)90017-4 , MR 0777971 ^ Ramaré, Olivier; Granville, Andrew (1996), \"Explicit bounds on exponential sums and the scarcity of squarefree binomial coefficients\", Mathematika , 43 (1): 73– 107, doi : 10.1112/S0025579300011608 ^ Lichtman, Jared Duker (2023). \"A proof of the Erdős primitive set conjecture\". Forum of Mathematics, Pi . 11 . arXiv : 2202.02384 . doi : 10.1017/fmp.2023.16 . ^ Cepelewicz, Jordana (2022-06-06). \"Graduate Student's Side Project Proves Prime Number Conjecture\" . Quanta Magazine . Retrieved 2022-06-06 . ^ Haran, Brady (16 June 2022). \"Primes and Primitive Sets\" . Numberphile . Retrieved 2022-06-21 . ^ Janzer, Oliver; Sudakov, Benny (2022-04-26).",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures_by_Paul_Erd%C5%91s",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:36.065443",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:36.065443",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:36.065443",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_conjectures_by_Paul_Erd%C5%91s_1_1749014016090_6266",
    "text": "Numberphile . Retrieved 2022-06-21 . ^ Janzer, Oliver; Sudakov, Benny (2022-04-26). \"Resolution of the Erdős-Sauer problem on regular subgraphs\". arXiv : 2204.12455 [ math.CO ]. ^ \"New Proof Shows When Structure Must Emerge in Graphs\" . Quanta Magazine . 2022-06-23 . Retrieved 2022-06-26 . External links [ edit ] Fan Chung, \"Open problems of Paul Erdős in graph theory\" Fan Chung, living version of \"Open problems of Paul Erdős in graph theory\" \"Erdős Problems\" . Erdős Problems . Retrieved 31 October 2024 . Retrieved from \" https://en.wikipedia.org/w/index.php?title=List_of_conjectures_by_Paul_Erdős&oldid=1289105164 \" Categories : Conjectures Paul Erdős Mathematics-related lists Hidden categories: CS1 French-language sources (fr) Articles with short description Short description is different from Wikidata List of conjectures by Paul Erdős Add topic",
    "source_url": "https://en.wikipedia.org/wiki/List_of_conjectures_by_Paul_Erd%C5%91s",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:36.090457",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:36.090457",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:36.090457",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Category:Theorems_in_mathematical_analysis_1_1749014017559_5166",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia Contents Top 0–9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z Subcategories This category has the following 12 subcategories, out of 12 total. Theorems in calculus (2 C, 40 P) A Theorems in analytic number theory (26 P) Theorems in approximation theory (16 P) C Theorems in complex analysis (1 C, 113 P) Convergence tests (17 P) F Fixed-point theorems (38 P) Theorems in functional analysis (124 P) H Theorems in harmonic analysis (1 C, 13 P) L Lemmas in mathematical analysis (35 P) M Theorems in measure theory (65 P) R Theorems in real analysis (2 C, 45 P) T Tauberian theorems (7 P) Pages in category \"Theorems in mathematical analysis\" The following 131 pages are in this category, out of  131 total. This list may not reflect recent changes .",
    "source_url": "https://en.wikipedia.org/wiki/Category:Theorems_in_mathematical_analysis",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:37.559949",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:37.559949",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:37.559949",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Category:Theorems_in_mathematical_analysis_1_1749014017573_5373",
    "text": "This list may not reflect recent changes . A Agmon's inequality Agnew's theorem Agranovich–Dynin formula Ahlfors finiteness theorem Ahlfors measure conjecture Atkinson–Mingarelli theorem ATS theorem B Babuška–Lax–Milgram theorem Bauer–Fike theorem Beer's theorem Besicovitch covering theorem Beurling–Lax theorem Bipolar theorem Brezis–",
    "source_url": "https://en.wikipedia.org/wiki/Category:Theorems_in_mathematical_analysis",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:37.573984",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:37.573984",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:37.573984",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Category:Theorems_in_mathematical_analysis_1_1749014017831_8525",
    "text": "decomposition Hobby–Rice theorem Hölder's theorem Holmgren's uniqueness theorem I Implicit function Infinite-dimensional Lebesgue measure Initial value theorem Integral of inverse functions Integration by parts Integration using Euler's formula Inverse function rule J Jensen's inequality K Kantorovich inequality Kantorovich theorem Kellogg's theorem Khintchine inequality Kneser's theorem (differential equations) Komlós' theorem Krein's condition L Lagrange reversion theorem Laplace principle (large deviations",
    "source_url": "https://en.wikipedia.org/wiki/Category:Theorems_in_mathematical_analysis",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:37.831791",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:37.831791",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:37.831791",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Category:Theorems_in_mathematical_analysis_1_1749014017839_2278",
    "text": "Lax equivalence theorem Lax–Milgram theorem Lax–Wendroff theorem Lebesgue integrability condition Levi–Lechicki theorem Lévy–Steinitz theorem Linearity of differentiation Liouville's theorem (conformal mappings)",
    "source_url": "https://en.wikipedia.org/wiki/Category:Theorems_in_mathematical_analysis",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:37.839790",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:37.840790",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:37.840790",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Category:Theorems_in_mathematical_analysis_1_1749014017863_4697",
    "text": "Littlewood's 4/3 inequality M Mahler's theorem Malgrange preparation theorem Malgrange–Ehrenpreis theorem Malmquist's theorem Markov brothers' inequality Maximum theorem Mountain pass theorem N Namioka's theorem Narasimhan–Seshadri theorem P Peano existence theorem Peano kernel theorem Picard–Lindelöf theorem Poincaré inequality Poisson summation formula Pontryagin duality Portmanteau theorem Power rule Prékopa–Leindler inequality Product rule Q Quotient rule R Rademacher–Menchov theorem Reciprocal rule Rellich–Kondrachov theorem Remez inequality Riemann–Lebesgue lemma S Sarason interpolation theorem Sard's theorem User:Sasha foxxo/sandbox Shift theorem Silverman–Toeplitz theorem Stahl's theorem Stirling's approximation Stone–Weierstrass theorem Straightening theorem for vector fields Strichartz estimate Sturm separation theorem Sturm–Picone comparison theorem Symmetry of second derivatives Szegő limit theorems T Tannery's theorem Tonelli–Hobson test Triple product rule Trudinger's",
    "source_url": "https://en.wikipedia.org/wiki/Category:Theorems_in_mathematical_analysis",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:37.863794",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:37.863794",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:37.863794",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Category:Theorems_in_mathematical_analysis_1_1749014017876_6509",
    "text": "theorem U Unique homomorphic extension theorem Universal approximation theorem Universal chord theorem W Whitney extension theorem Wirtinger's inequality for functions Retrieved from \" https://en.wikipedia.org/w/index.php?title=Category:Theorems_in_mathematical_analysis&oldid=1286472238 \" Categories : Mathematical theorems Mathematical analysis Hidden categories: Template Category TOC via Automatic category TOC on category with 101–200 pages Automatic category TOC generates standard Category TOC Category : Theorems in mathematical analysis Add",
    "source_url": "https://en.wikipedia.org/wiki/Category:Theorems_in_mathematical_analysis",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:37.876306",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:37.876306",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:37.876306",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Algorithms_and_data_structures&oldid=1245766542_1_1749014022810_7129",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Jlwoodwa ( talk | contribs ) at 23:48, 14 September 2024 (Undid revision 1245766465 by Jlwoodwa ( talk ): probably doesn't require frequent maintenance) . The present address (URL) is a permanent link to this version. Revision as of 23:48, 14 September 2024 by Jlwoodwa ( talk | contribs ) (Undid revision 1245766465 by Jlwoodwa ( talk ): probably doesn't require frequent maintenance)",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Algorithms_and_data_structures&oldid=1245766542",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:42.810469",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:42.810469",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:42.810469",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Binary_GCD_algorithm_1_1749014024793_8816",
    "text": "= v {\\displaystyle \\gcd(0,v)=v} , gcd ( 2 u , v ) = gcd ( u , v ) {\\displaystyle \\gcd(2u,v)=\\gcd(u,v)} if v {\\displaystyle v} is odd, etc.",
    "source_url": "https://en.wikipedia.org/wiki/Binary_GCD_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:44.793219",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:44.793219",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:44.793219",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Computational_complexity_of_mathematical_operations_1_1749014034360_6007",
    "text": "\\displaystyle O(n\\log n)} Division Two n {\\displaystyle n} -digit numbers One n {\\displaystyle n} -digit number Schoolbook long division O ( n 2 ) {\\displaystyle O{\\mathord {\\left(n^{2}\\right)}}} Burnikel–Ziegler Divide-and-Conquer Division [ 5 ] O ( M ( n ) log ⁡ n ) {\\displaystyle O(M(n)\\log n)} Newton–Raphson division O ( M ( n ) ) {\\displaystyle O(M(n)) } Square root One n {\\displaystyle n} -digit number One n / 2 {\\displaystyle n/2} -digit number Newton's method O ( M ( n ) ) {\\displaystyle O(M(n))",
    "source_url": "https://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:13:54.360702",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:13:54.360702",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:13:54.360702",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Implicit_computational_complexity_1_1749014054135_5362",
    "text": "= y , Q ( ; x i , y , z 0 , z 1 ) = z i {\\displaystyle Q(;\\varepsilon ,y,z_{0},z_{1})=y,Q(;xi,y,z_{0},z_{1})=z_{i}} tally product : × ( x , y ; ) = 1 | x | × | y | {\\displaystyle \\times (x,y;)=1^{|x|\\times |y|}} . We can combine functions to form new ones using a composition scheme and a recursion scheme. Given g , r → , s → {\\displaystyle g,{\\vec {r}},{\\vec {s}}} , their predicative composition , f = g ∘ ( r → ; s → ) {\\displaystyle f=g\\circ ({\\vec {r}};{\\vec {s}})} is defined by f ( x → ; y → ) = g ( r → ( x → ; ) ; s → ( x → ; y → ) ) . {\\displaystyle f({\\vec {x}};{\\vec {y}})=g({\\vec {r}}({\\vec {x}};);{\\vec {s}}({\\vec {x}};{\\vec {y}})).} Given g , h 0 , h 1 {\\displaystyle g,h_{0},h_{1}} , the predicative recursion on notation scheme defines a function f {\\displaystyle f} by f ( ε , x → ; y → ) = g ( x → ; y → ) , f ( z i , x → ; y → ) = h i ( z , x → ; y → , f ( z , x → ; y → ) ) .",
    "source_url": "https://en.wikipedia.org/wiki/Implicit_computational_complexity",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:14.135389",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:14.135389",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:14.135389",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Binary_GCD_algorithm&oldid=1272402879_1_1749014057460_4471",
    "text": "As GCD is commutative ( gcd ( u , v ) = gcd ( v , u ) {\\displaystyle \\gcd(u,v)=\\gcd(v,u)} ), those identities still apply if the operands are swapped: gcd ( 0 , v ) = v {\\displaystyle \\gcd(0,v)=v} , gcd ( 2 u , v ) = gcd ( u , v ) {\\displaystyle \\gcd(2u,v)=\\gcd(u,v)} if v {\\displaystyle v} is odd, etc.",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Binary_GCD_algorithm&oldid=1272402879",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:17.460224",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:17.460224",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:17.460224",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quantum_complexity_theory_1_1749014080686_1515",
    "text": "{\\displaystyle \\Omega (T(n))} , and Θ ( T ( n ) ) {\\displaystyle \\Theta (T(n))} . O ( T ( n ) ) {\\displaystyle O(T(n))} expresses that something is bounded above by c T ( n ) {\\displaystyle cT(n)} where c {\\displaystyle c} is a constant such that c > 0 {\\displaystyle c>0} and T ( n ) {\\displaystyle T(n)} is a function of n {\\displaystyle n} , Ω ( T ( n ) ) {\\displaystyle \\Omega (T(n))} expresses that something is bounded below by c T ( n ) {\\displaystyle cT(n)} where c {\\displaystyle c} is a constant such that c > 0 {\\displaystyle c>0} and T ( n ) {\\displaystyle T(n)} is a function of n {\\displaystyle n} , and Θ ( T ( n ) ) {\\displaystyle \\Theta (T(n))} expresses both O ( T ( n ) ) {\\displaystyle O(T(n))} and Ω ( T ( n ) ) {\\displaystyle \\Omega (T(n))} . [ 3 ] These notations also have their own names. O ( T ( n ) ) {\\displaystyle O(T(n))} is called Big O notation , Ω ( T ( n ) ) {\\displaystyle \\Omega (T(n))} is called Big Omega notation, and Θ ( T ( n ) )",
    "source_url": "https://en.wikipedia.org/wiki/Quantum_complexity_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:40.686710",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:40.686710",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:40.686710",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quantum_complexity_theory_1_1749014080712_1459",
    "text": "{\\displaystyle \\Omega (T(n))} is called Big Omega notation, and Θ ( T ( n ) ) {\\displaystyle \\Theta (T(n))} is called Big Theta notation. Overview of complexity classes [ edit ] The important complexity classes P, BPP, BQP, PP, and PSPACE can be compared based on promise problems . A promise problem is a decision problem which has an input assumed to be selected from the set of all possible input strings. A promise problem is a pair A = ( A yes , A no ) {\\displaystyle A=(A_{\\text{yes}},A_{\\text{no}})} , where A yes {\\displaystyle A_{\\text{yes}}} is the set of yes instances and A no {\\displaystyle A_{\\text{no}}} is the set of no instances, and the intersection of these sets is empty: A yes ∩ A no = ∅ {\\displaystyle A_{\\text{yes}}\\cap A_{\\text{no}}=\\varnothing } . All of the previous complexity classes contain promise problems.",
    "source_url": "https://en.wikipedia.org/wiki/Quantum_complexity_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:40.712726",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:40.712726",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:40.712726",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quantum_complexity_theory_1_1749014080996_4935",
    "text": "[0,1]} , there exists a polynomial time generated family of quantum circuits Q = { Q n : n ∈ N } {\\displaystyle Q={\\{Q_{n}:n\\in \\mathbb {N} \\}}} , where Q n {\\displaystyle Q_{n}} is a circuit which accepts n {\\displaystyle n} qubits and gives an output of one qubit. An element x {\\displaystyle x} of A yes {\\displaystyle A_{\\text{yes}}} is accepted by Q {\\displaystyle Q} with a probability greater than or equal to a ( | x | ) {\\displaystyle a(\\left\\vert x\\right\\vert )} . An element x {\\displaystyle x} of A no {\\displaystyle A_{\\text{no}}} is accepted by Q {\\displaystyle Q} with a probability less than or equal to b ( | x | ) {\\displaystyle b(\\left\\vert x\\right\\vert )} .",
    "source_url": "https://en.wikipedia.org/wiki/Quantum_complexity_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:40.996198",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:40.996198",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:40.996198",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quantum_algorithm_for_linear_systems_of_equations_1_1749014085295_5507",
    "text": "i = ⁡ 1 N β i λ j − 1 | u j ⟩ = A − 1 | b ⟩ = | x ⟩ , {\\displaystyle \\sum _{i\\mathop {=} 1}^{N}\\beta _{i}\\lambda _{j}^{-1}|u_{j}\\rangle =A^{-1}|b\\rangle =|x\\rangle ,} where | x ⟩ {\\displaystyle |x\\rangle } is a quantum-mechanical representation of the desired solution vector x . To read out all components of x would require the procedure be repeated at least N times. However, it is often the case that one is not interested in x {\\displaystyle x} itself, but rather some expectation value of a linear operator M acting on x . By mapping M to a quantum-mechanical operator and performing the quantum measurement corresponding to M , we obtain an estimate of the expectation value ⟨ x | M | x ⟩ {\\displaystyle \\langle x|M|x\\rangle } . This allows for a wide variety of features of the vector x to be extracted including normalization, weights in different parts of the state space, and moments without actually computing all the values of the solution vector x .",
    "source_url": "https://en.wikipedia.org/wiki/Quantum_algorithm_for_linear_systems_of_equations",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:45.295684",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:45.296684",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:45.296684",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quantum_algorithm_for_linear_systems_of_equations_1_1749014085450_5633",
    "text": "Apply the conditional Hamiltonian evolution (sum) 3. Apply the Fourier transform to the register C . Denote the resulting basis states with | k ⟩ {\\displaystyle |k\\rangle } for k = 0, ..., T − 1. Define λ k := 2 π k / t 0 {\\displaystyle \\lambda _{k}:=2\\pi k/t_{0}} . 4. Adjoin a three-dimensional register S in the state | h ( λ k ) ⟩ S := 1 − f ( λ k ) 2 − g ( λ k ) 2 | n o t h i n g ⟩ S + f ( λ k ) | w e l l ⟩ S + g ( λ k ) | i l l ⟩ S , {\\displaystyle |h(\\lambda _{k})\\rangle ^{S}:={\\sqrt {1-f(\\lambda _{k})^{2}-g(\\lambda _{k})^{2}}}|\\mathrm {nothing} \\rangle ^{S}+f(\\lambda _{k})|\\mathrm {well} \\rangle ^{S}+g(\\lambda _{k})|\\mathrm {ill} \\rangle ^{S},} 5. Reverse steps 1–3, uncomputing any garbage produced along the way. The phase estimation procedure in steps 1-3 allows for the estimation of eigenvalues of A up to error ϵ {\\displaystyle \\epsilon } .",
    "source_url": "https://en.wikipedia.org/wiki/Quantum_algorithm_for_linear_systems_of_equations",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:45.450977",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:45.450977",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:45.450977",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=HHL_algorithm&oldid=1292278960_1_1749014088018_2951",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 04:21, 26 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 04:21, 26 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Quan",
    "source_url": "https://en.wikipedia.org/w/index.php?title=HHL_algorithm&oldid=1292278960",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:48.018045",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:48.018045",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:48.018045",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Computational_complexity_of_games_1_1749014089971_7977",
    "text": "[ 1 ] When this is too hard to calculate, an upper bound can often be computed by also counting (some) illegal positions (positions that can never arise in the course of a game). Game tree size [ edit ] The game tree size is the total number of possible games that can be played. This is the number of leaf nodes in the game tree rooted at the game's initial position. The game tree is typically vastly larger than the state-space because the same positions can occur in many games by making moves in a different order (for example, in a tic-tac-toe game with two X and one O on the board, this position could have been reached in two different ways depending on where the first X was placed). An upper bound for the size of the game tree can sometimes be computed by simplifying the game in a way that only increases the size of the game tree (for example, by allowing illegal moves) until it becomes tractable.",
    "source_url": "https://en.wikipedia.org/wiki/Computational_complexity_of_games",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:49.971994",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:49.971994",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:49.971994",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Computational_complexity_of_games_1_1749014089997_8581",
    "text": "For games where the number of moves is not limited (for example by the size of the board, or by a rule about repetition of position) the game tree is generally infinite. Decision trees [ edit ] A decision tree is a subtree of the game tree, with each position labelled \"player A wins\", \"player B wins\", or \"draw\" if that position can be proved to have that value (assuming best play by both sides) by examining only other positions in the graph. Terminal positions can be labelled directly—with player A to move, a position can be labelled \"player A wins\" if any successor position is a win for A; \"player B wins\" if all successor positions are wins for B; or \"draw\" if all successor positions are either drawn or wins for B. (With player B to move, corresponding positions are marked similarly.) The following two methods of measuring game complexity use decision trees:",
    "source_url": "https://en.wikipedia.org/wiki/Computational_complexity_of_games",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:49.997994",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:49.998994",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:49.998994",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Computational_complexity_of_games_1_1749014090024_2466",
    "text": "The following two methods of measuring game complexity use decision trees: Decision complexity [ edit ] Decision complexity of a game is the number of leaf nodes in the smallest decision tree that establishes the value of the initial position. Game-tree complexity [ edit ] Game-tree complexity of a game is the number of leaf nodes in the smallest full-width decision tree that establishes the value of the initial position. [ 1 ] A full-width tree includes all nodes at each depth. This is an estimate of the number of positions one would have to evaluate in a minimax search to determine the value of the initial position. It is hard even to estimate the game-tree complexity, but for some games an approximation can be given by G T C ≥ b d {\\displaystyle GTC\\geq b^{d}} , where b is the game's average branching factor and d is the number of plies in an average game.",
    "source_url": "https://en.wikipedia.org/wiki/Computational_complexity_of_games",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:50.024554",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:50.025554",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:50.025554",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Computational_complexity_of_games_1_1749014090197_6219",
    "text": "[ 4 ] Complexities of some well-known games [ edit ] Due to the large size of game complexities, this table gives the ceiling of their logarithm to base 10. (In other words, the number of digits). All of the following numbers should be considered with caution: seemingly minor changes to the rules of a game can change the numbers (which are often rough estimates anyway) by tremendous factors, which might easily be much greater than the numbers shown.",
    "source_url": "https://en.wikipedia.org/wiki/Computational_complexity_of_games",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:50.197248",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:50.197248",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:50.197248",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Computational_complexity_of_games_1_1749014090225_4026",
    "text": "Game Board size (positions) State-space complexity (as log to base 10) Game-tree complexity (as log to base 10) Average game length ( plies ) Branching factor Ref Complexity class of suitable generalized game Tic-tac-toe 9 3 5 9 4 PSPACE-complete [ 5 ] Sim 15 3 8 14 3.7 PSPACE-complete [ 6 ] Pentominoes 64 12 18 10 75 [ 7 ] [ 8 ] ?, but in PSPACE Kalah [ 9 ] 14 13 18 50 [ 7 ] Generalization is unclear Connect Four 42 13 21 36 4 [ 1 ] [ 10 ] ?, but in PSPACE Domineering (8 × 8) 64 15 27 30 8 [ 7 ] ?, but in PSPACE ; in P for certain dimensions [ 11 ] Congkak 14 15 33 [ 7 ] English draughts (8x8) (checkers) 32 20 or 18 40 70 2.8 [ 1 ] [ 12 ] [ 13 ] EXPTIME-complete [ 14 ] Awari [ 15 ] 12 12 32 60 3.5 [ 1 ]",
    "source_url": "https://en.wikipedia.org/wiki/Computational_complexity_of_games",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:50.225637",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:50.225637",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:50.225637",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Computational_complexity_of_games_1_1749014090247_9143",
    "text": "Generalization is unclear Qubic 64 30 34 20 54.2 [ 1 ] PSPACE-complete [ 5 ] Double dummy bridge [ nb 1 ] (52) <17 <40 52 5.6 PSPACE-complete [ 16 ] Fanorona 45 21 46 44 11 [ 17 ] ?, but in EXPTIME Nine men's morris 24 10 50 50 10 [ 1 ] ?, but in EXPTIME Tablut 81 27 [ 18 ] International draughts (10x10) 50 30 54 90 4 [ 1 ] EXPTIME-complete [ 14 ] Chinese checkers (2 sets) 121 23 180 [ 19 ] EXPTIME -complete [ 20 ] Chinese checkers (6 sets) 121 78 600 [ 19 ] EXPTIME -complete [ 20 ] Reversi (Othello)",
    "source_url": "https://en.wikipedia.org/wiki/Computational_complexity_of_games",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:50.247144",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:50.247144",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:50.247144",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Geometric_Folding_Algorithms_1_1749014097687_6166",
    "text": "[ 6 ] It is a monograph rather than a textbook, and in particular does not include sets of exercises. [ 4 ] The Basic Library List Committee of the Mathematical Association of America has recommended this book for inclusion in undergraduate mathematics libraries. [ 1 ] Topics and organization [ edit ] The book is organized into three sections, on linkages, origami, and polyhedra. [ 1 ] [ 2 ] Topics in the section on linkages include\nthe Peaucellier–Lipkin linkage for converting rotary motion into linear motion, [ 4 ] Kempe's universality theorem that any algebraic curve can be traced out by a linkage, [ 1 ] [ 4 ] the existence of linkages for angle trisection , [ 1 ] and the carpenter's rule problem on straightening two-dimensional polygonal chains . [ 4 ] This part of the book also includes applications to motion planning for robotic arms , and to protein folding . [ 1 ] [ 2 ] The second section of the book concerns the mathematics of paper folding , and mathematical origami .",
    "source_url": "https://en.wikipedia.org/wiki/Geometric_Folding_Algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:57.687451",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:57.688452",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:57.688452",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Geometric_Folding_Algorithms_1_1749014097708_9757",
    "text": "It includes the NP-completeness of testing flat foldability, [ 2 ] the problem of map folding (determining whether a pattern of mountain and valley folds forming a square grid can be folded flat), [ 2 ] [ 4 ] the work of Robert J. Lang using tree structures and circle packing to automate the design of origami folding patterns, [ 2 ] [ 4 ] the fold-and-cut theorem according to which any polygon can be constructed by folding a piece of paper and then making a single straight cut, [ 2 ] [ 4 ] origami-based angle trisection, [ 4 ] rigid origami , [ 2 ] and the work of David A. Huffman on curved folds.",
    "source_url": "https://en.wikipedia.org/wiki/Geometric_Folding_Algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:57.708465",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:57.708465",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:57.708465",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Geometric_Folding_Algorithms&oldid=1267520922_1_1749014098213_5489",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by MichaelMaggs ( talk | contribs ) at 13:48, 5 January 2025 (Adding short description : \"2007 mathematics book by Demaine and O'Rourke\") . The present address (URL) is a permanent link to this version. Revision as of 13:48, 5 January 2025 by MichaelMaggs ( talk | contribs ) (Adding short description : \"2007 mathematics book by Demaine and O'Rourke\") ( diff ) ← Previous revision | Latest re",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Geometric_Folding_Algorithms&oldid=1267520922",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:58.213231",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:58.213818",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:58.213818",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Fundamental_theorem_of_Boolean_algebra_1_1749014099846_1125",
    "text": "= X 1 ⋅ f ( 1 , X 2 , … , X n ) + X 1 ′ ⋅ f ( 0 , X 2 , … , X n ) {\\displaystyle f(X_{1},X_{2},\\dots ,X_{n})=X_{1}\\cdot f(1,X_{2},\\dots ,X_{n})+X_{1}'\\cdot f(0,X_{2},\\dots ,X_{n})} Variations and implications [ edit ] XOR-Form The statement also holds when the disjunction \"+\" is replaced by the XOR operator: f ( X 1 , X 2 , … , X n ) = X 1 ⋅ f ( 1 , X 2 , … , X n ) ⊕ X 1 ′ ⋅ f ( 0 , X 2 , … , X n ) {\\displaystyle f(X_{1},X_{2},\\dots ,X_{n})=X_{1}\\cdot f(1,X_{2},\\dots ,X_{n})\\oplus X_{1}'\\cdot f(0,X_{2},\\dots ,X_{n})} Dual form There is a dual form of the Shannon expansion (which does not have a related XOR form): f ( X 1 , X 2 , … , X n ) = ( X 1 + f ( 0 , X 2 , … , X n ) ) ⋅ ( X 1 ′ + f ( 1 , X 2 , … , X n ) ) {\\displaystyle f(X_{1},X_{2},\\dots ,X_{n})=(X_{1}+f(0,X_{2},\\dots ,X_{n}))\\cdot (X_{1}'+f(1,X_{2},\\dots ,X_{n}))} Repeated application for each argument leads to the Sum of Products (SoP) canonical form of the Boolean function f {\\displaystyle f} .",
    "source_url": "https://en.wikipedia.org/wiki/Fundamental_theorem_of_Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:59.846263",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:59.846263",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:59.846263",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Fundamental_theorem_of_Boolean_algebra_1_1749014099879_1765",
    "text": "For example for n = 2 {\\displaystyle n=2} that would be f ( X 1 , X 2 ) = X 1 ⋅ f ( 1 , X 2 ) + X 1 ′ ⋅ f ( 0 , X 2 ) = X 1 X 2 ⋅ f ( 1 , 1 ) + X 1 X 2 ′ ⋅ f ( 1 , 0 ) + X 1 ′ X 2 ⋅ f ( 0 , 1 ) + X 1 ′ X 2 ′ ⋅ f ( 0 , 0 ) {\\displaystyle {\\begin{aligned}f(X_{1},X_{2})&=X_{1}\\cdot f(1,X_{2})+X_{1}'\\cdot f(0,X_{2})\\\\&=X_{1}X_{2}\\cdot f(1,1)+X_{1}X_{2}'\\cdot f(1,0)+X_{1}'X_{2}\\cdot f(0,1)+X_{1}'X_{2}'\\cdot f(0,0)\\end{aligned}}} Likewise, application of the dual form leads to the Product of Sums (PoS) canonical form (using the distributivity law of + {\\displaystyle +} over ⋅ {\\displaystyle \\cdot } ): f ( X 1 , X 2 ) = ( X 1 + f ( 0 , X 2 ) ) ⋅ ( X 1 ′ + f ( 1 , X 2 ) ) = ( X 1 + X 2 + f ( 0 , 0 ) ) ⋅ ( X 1 + X 2 ′ + f ( 0 , 1 ) ) ⋅ ( X 1 ′ + X 2 + f ( 1 , 0 ) ) ⋅ ( X 1 ′ + X 2 ′ + f ( 1 , 1 ) )",
    "source_url": "https://en.wikipedia.org/wiki/Fundamental_theorem_of_Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:14:59.879262",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:14:59.879262",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:14:59.879262",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Genetic_algorithm&oldid=1292039994_1_1749014108683_7826",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by PeterGrant07 ( talk | contribs ) at 21:33, 24 May 2025 ( → Chromosome representation : adding early innovations in variable-length representations) . The present address (URL) is a permanent link to this version. Revision as of 21:33, 24 May 2025 by PeterGrant07 ( talk | contribs ) ( → Chromosome representation : adding early innovations in variable-length representations) ( diff ) ← Pre",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Genetic_algorithm&oldid=1292039994",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:15:08.683662",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:15:08.683662",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:15:08.683662",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann_conjecture_1_1749014109938_3419",
    "text": "The historically first potential counterexample is Thompson group F . While its amenability is a wide- open problem , the general conjecture was shown to be false in 1980 by Alexander Ol'shanskii ; he demonstrated that Tarski monster groups , constructed by him, which are easily seen not to have free subgroups of rank 2, are not amenable. Two years later, Sergei Adian showed that certain Burnside groups are also counterexamples. None of these counterexamples are finitely presented , and for some years it was considered possible that the conjecture held for finitely presented groups. However, in 2003, Alexander Ol'shanskii and Mark Sapir exhibited a collection of finitely presented groups which do not satisfy the conjecture. In 2013, Nicolas Monod found an easy counterexample to the conjecture. Given by piecewise projective homeomorphisms of the line, the group is remarkably simple to understand.",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann_conjecture",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:15:09.938263",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:15:09.938263",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:15:09.938263",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann_conjecture_1_1749014109997_9682",
    "text": "Nauk (in Russian), 35 (4): 199– 200, Zbl 0452.20032 Ol'shanskii, Alexander; Sapir, Mark (2003), \"Non-amenable finitely presented torsion-by-cyclic groups\", Publications Mathématiques de l'IHÉS , 96 (1): 43– 169, arXiv : math/0208237 , doi : 10.1007/s10240-002-0006-7 , S2CID 122990460 , Zbl 1050.20019 Monod, Nicolas (2013), \"Groups of piecewise projective homeomorphisms\", Proceedings of the National Academy of Sciences of the United States of America , 110 (12): 4524– 4527, arXiv : 1209.5229 , Bibcode : 2013PNAS..110.4524M , doi : 10.1073/pnas.1218426110 , Zbl 1305.57002 Lodha, Yash; Moore, Justin Tatch (2016), \"A nonamenable finitely presented group of piecewise projective homeomorphisms\", Groups, Geometry, and Dynamics , 10 (1): 177– 200, arXiv : 1308.4250v3 , doi : 10.4171/GGD/347 , MR 3460335 Lodha, Yash (2020), \"A nonamenable type F ∞ {\\displaystyle F_{\\infty }} group of piecewise projective homeomorphisms\", Journal of Topology , 13 (4): 1767– 1838, doi : 10.1112/topo.12172 ,",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann_conjecture",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:15:09.997760",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:15:09.997760",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:15:09.997760",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Needleman%E2%80%93Wunsch_algorithm_1_1749014123518_7369",
    "text": "Jump to content From Wikipedia, the free encyclopedia Method for aligning biological sequences This article may be too technical for most readers to understand . Please help improve it to make it understandable to non-experts , without removing the technical details. ( September 2013 ) ( Learn how and when to remove this message ) Figure 1: Needleman-Wunsch pairwise sequence alignment Class Sequence alignment Worst-case performance O ( m n ) {\\displaystyle O(mn)} Worst-case space complexity O ( ",
    "source_url": "https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:15:23.519945",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:15:23.519945",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:15:23.519945",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Risch_algorithm_1_1749014126147_1984",
    "text": "Jump to content From Wikipedia, the free encyclopedia Method for evaluating indefinite integrals Part of a series of articles about Calculus ∫ a b f ′ ( t ) d t = f ( b ) − f ( a ) {\\displaystyle \\int _{a}^{b}f'(t)\\,dt=f(b)-f(a)} Fundamental theorem Limits Continuity Rolle's theorem Mean value theorem Inverse function theorem Differential Definitions Derivative ( generalizations ) Differential infinitesimal of a function total Concepts Differentiation notation Second derivative Implicit differen",
    "source_url": "https://en.wikipedia.org/wiki/Risch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:15:26.147705",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:15:26.147705",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:15:26.147705",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Nested_sampling_algorithm_1_1749014139003_4891",
    "text": "Jump to content From Wikipedia, the free encyclopedia Part of a series on Bayesian statistics Posterior = Likelihood × Prior ÷ Evidence Background Bayesian inference Bayesian probability Bayes' theorem Bernstein–von Mises theorem Coherence Cox's theorem Cromwell's rule Likelihood principle Principle of indifference Principle of maximum entropy Model building Conjugate prior Linear regression Empirical Bayes Hierarchical model Posterior approximation Markov chain Monte Carlo Laplace's approximati",
    "source_url": "https://en.wikipedia.org/wiki/Nested_sampling_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:15:39.003185",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:15:39.003185",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:15:39.003185",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Linde%E2%80%93Buzo%E2%80%93Gray_algorithm_1_1749014139810_9758",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article is missing information about general information, usage in the field (mention cinepak?), optimality conditions, choice of 𝜖s, model instead of training data, ELBG. Please expand the article to include this information. Further details may exist on the talk page . ( December 2023 ) This article relies largely or entirely on a single source . Relevant discussion may be found on the talk page . Please help improve this article by in",
    "source_url": "https://en.wikipedia.org/wiki/Linde%E2%80%93Buzo%E2%80%93Gray_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:15:39.810752",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:15:39.810752",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:15:39.810752",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Fast_Cosine_Transform_1_1749014148678_4723",
    "text": "Jump to content From Wikipedia, the free encyclopedia (Redirected from Fast Cosine Transform ) Technique used in signal processing and data compression A discrete cosine transform ( DCT ) expresses a finite sequence of data points in terms of a sum of cosine functions oscillating at different frequencies . The DCT, first proposed by Nasir Ahmed in 1972, is a widely used transformation technique in signal processing and data compression . It is used in most digital media , including digital image",
    "source_url": "https://en.wikipedia.org/wiki/Fast_Cosine_Transform",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:15:48.678395",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:15:48.678395",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:15:48.678395",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Join_(SQL)_1_1749014151245_9242",
    "text": "Jump to content From Wikipedia, the free encyclopedia SQL clause A Venn diagram representing the full join SQL statement between tables A and B. A join clause in the Structured Query Language ( SQL ) combines columns from one or more tables into a new table. The operation corresponds to a join operation in relational algebra . Informally, a join stitches two tables and puts on the same row records with matching fields : INNER , LEFT OUTER , RIGHT OUTER , FULL OUTER and CROSS . Example tables [ e",
    "source_url": "https://en.wikipedia.org/wiki/Join_(SQL)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:15:51.245243",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:15:51.245243",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:15:51.245243",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Snapshot_algorithm_1_1749014152804_6345",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article's tone or style may not reflect the encyclopedic tone used on Wikipedia . See Wikipedia's guide to writing better articles for suggestions. ( November 2016 ) ( Learn how and when to remove this message ) This article needs additional citations for verification . Please help improve th",
    "source_url": "https://en.wikipedia.org/wiki/Snapshot_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:15:52.804688",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:15:52.804688",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:15:52.804688",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithm_BSTW&oldid=1261412276_1_1749014161591_1042",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by IznoRepeat ( talk | contribs ) at 23:50, 5 December 2024 ( → External links : add WP:TEMPLATECAT to remove from template; genfixes) . The present address (URL) is a permanent link to this version. Revision as of 23:50, 5 December 2024 by IznoRepeat ( talk | contribs ) ( → External links : add WP:TEMPLATECAT to remove from template; genfixes) ( diff ) ← Previous revision | Latest revision",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithm_BSTW&oldid=1261412276",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:01.591431",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:01.591431",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:01.591431",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Adaptive_Huffman_coding_1_1749014162852_5596",
    "text": "Invariant : For each weight w, all leaves of weight w precede all internal nodes having weight w. In other terms, when we have built the Huffman tree, if several nodes had the same value, we prioritized merging the leaves over the internal nodes. Blocks : Nodes of same weight and same type (i.e. either leaf node or internal node) form a Block. Leader : Highest numbered node in a block. Blocks are interlinked by increasing order of their weights. A leaf block always precedes internal block of same weight, thus maintaining the invariant. NYT (Not Yet Transferred) is a special node used to represent symbols which are 'not yet transferred' . Slide_And_Increment(leaf node) sliding starts. P is a leaf node. Slide_And_Increment(leaf node) sliding step 2. As P is leaf node, it slides in front of next block nodes of equal weight. Slide_And_Increment(leaf node) sliding step 3. Here we increase the current weight by 1. Slide_And_Increment(leaf node) sliding step 4. Method comes to an end.",
    "source_url": "https://en.wikipedia.org/wiki/Adaptive_Huffman_coding",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:02.852066",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:02.852066",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:02.852066",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Adaptive_Huffman_coding_1_1749014162921_8220",
    "text": "= parent of new symbol leaf node\n        leaf_to_increment := Right Child of p else Swap p with leader of its block if (new p is sibling to NYT) then leaf_to_increment := p p := parent of p while (p ≠ NULL) do Slide_And_Increment(p) if (leaf_to_increment != NULL) then Slide_And_Increment(leaf_to_increment) function Slide_And_Increment(p) is previous_p : = parent of p if (p is an internal node) then Slide p in the tree higher than the leaf nodes of weight wt + 1\n        increase weight of p by 1 p := previous_p else Slide p in the tree higher than the internal nodes of weight wt\n        increase weight of p by 1 p := new parent of p . Encoder and decoder start with only the root node, which has the maximum number. In the beginning it is our initial NYT node. When we transmit an NYT symbol, we have to transmit code for the NYT node, then for its generic code. For every symbol that is already in the tree, we only have to transmit code for its leaf node.",
    "source_url": "https://en.wikipedia.org/wiki/Adaptive_Huffman_coding",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:02.921898",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:02.921898",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:02.921898",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithmic_efficiency&oldid=1286247421_1_1749014167191_3472",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Widefox ( talk | contribs ) at 17:38, 18 April 2025 ( → top : fix sect WP:ORDER , fix hatnote) . The present address (URL) is a permanent link to this version. Revision as of 17:38, 18 April 2025 by Widefox ( talk | contribs ) ( → top : fix sect WP:ORDER , fix hatnote) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Not to be confused with program optimiza",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithmic_efficiency&oldid=1286247421",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:07.191301",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:07.191301",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:07.191301",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Recursive_language_1_1749014168769_6676",
    "text": "[ 5 ] Thus, this is an example of a language that is decidable but not context-sensitive. Closure properties [ edit ] Recursive languages are closed under the following operations. That is, if L and P are two recursive languages, then the following languages are recursive as well: The Kleene star L ∗ {\\displaystyle L^{*}} The image φ(L) under an e-free homomorphism φ The concatenation L ∘ P {\\displaystyle L\\circ P} The union L ∪ P {\\displaystyle L\\cup P} The intersection L ∩ P {\\displaystyle L\\cap P} The complement of L {\\displaystyle L} The set difference L − P {\\displaystyle L-P} The last property follows from the fact that the set difference can be expressed in terms of intersection and complement. See also [ edit ] Recursively enumerable language Computable set Recursion References [ edit ] ^ Sipser (2012) . ^ Sipser (1997) . ^ Chomsky (1959) . ^ Fischer & Rabin (1974) . ^ Oppen (1978) . Chomsky, Noam (1959). \"On certain formal properties of grammars\". Information and Control .",
    "source_url": "https://en.wikipedia.org/wiki/Recursive_language",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:08.769836",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:08.769836",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:08.769836",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithm_V_1_1749014170908_9706",
    "text": "Invariant : For each weight w, all leaves of weight w precede all internal nodes having weight w. In other terms, when we have built the Huffman tree, if several nodes had the same value, we prioritized merging the leaves over the internal nodes. Blocks : Nodes of same weight and same type (i.e. either leaf node or internal node) form a Block. Leader : Highest numbered node in a block. Blocks are interlinked by increasing order of their weights. A leaf block always precedes internal block of same weight, thus maintaining the invariant. NYT (Not Yet Transferred) is a special node used to represent symbols which are 'not yet transferred' . Slide_And_Increment(leaf node) sliding starts. P is a leaf node. Slide_And_Increment(leaf node) sliding step 2. As P is leaf node, it slides in front of next block nodes of equal weight. Slide_And_Increment(leaf node) sliding step 3. Here we increase the current weight by 1. Slide_And_Increment(leaf node) sliding step 4. Method comes to an end.",
    "source_url": "https://en.wikipedia.org/wiki/Algorithm_V",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:10.908724",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:10.908724",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:10.908724",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithm_V_1_1749014170976_9364",
    "text": "= parent of new symbol leaf node\n        leaf_to_increment := Right Child of p else Swap p with leader of its block if (new p is sibling to NYT) then leaf_to_increment := p p := parent of p while (p ≠ NULL) do Slide_And_Increment(p) if (leaf_to_increment != NULL) then Slide_And_Increment(leaf_to_increment) function Slide_And_Increment(p) is previous_p : = parent of p if (p is an internal node) then Slide p in the tree higher than the leaf nodes of weight wt + 1\n        increase weight of p by 1 p := previous_p else Slide p in the tree higher than the internal nodes of weight wt\n        increase weight of p by 1 p := new parent of p . Encoder and decoder start with only the root node, which has the maximum number. In the beginning it is our initial NYT node. When we transmit an NYT symbol, we have to transmit code for the NYT node, then for its generic code. For every symbol that is already in the tree, we only have to transmit code for its leaf node.",
    "source_url": "https://en.wikipedia.org/wiki/Algorithm_V",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:10.976346",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:10.977338",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:10.977338",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Alternating_Turing_machine_1_1749014174879_6652",
    "text": "Q × Γ → P ( Q × Γ × { L , R } ) {\\displaystyle \\delta :Q\\times \\Gamma \\rightarrow {\\mathcal {P}}(Q\\times \\Gamma \\times \\{L,R\\})} is called the transition function ( L shifts the head left and R shifts the head right) q 0 ∈ Q {\\displaystyle q_{0}\\in Q} is the initial state g : Q → { ∧ , ∨ , a c c e p t , r e j e c t } {\\displaystyle g:Q\\rightarrow \\{\\wedge ,\\vee ,accept,reject\\}} specifies the type of each state If M is in a state q ∈ Q {\\displaystyle q\\in Q} with g ( q ) = a c c e p t {\\displaystyle g(q)=accept} then that configuration is said to be accepting , and if g ( q ) = r e j e c t {\\displaystyle g(q)=reject} the configuration is said to be rejecting . A configuration with g ( q ) = ∧ {\\displaystyle g(q)=\\wedge } is said to be accepting if all configurations reachable in one step are accepting, and rejecting if some configuration reachable in one step is rejecting.",
    "source_url": "https://en.wikipedia.org/wiki/Alternating_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:14.879475",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:14.879475",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:14.879475",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Alternating_Turing_machine_1_1749014174933_9986",
    "text": "In particular, an existential configuration can be labelled as accepting if any successor configuration is found to be accepting, and a universal configuration can be labelled as rejecting if any successor configuration is found to be rejecting. An ATM decides a formal language in time t ( n ) {\\displaystyle t(n)} if, on any input of length n , examining configurations only up to t ( n ) {\\displaystyle t(n)} steps is sufficient to label the initial configuration as accepting or rejecting. An ATM decides a language in space s ( n ) {\\displaystyle s(n)} if examining configurations that do not modify tape cells beyond the s ( n ) {\\displaystyle s(n)} cell from the left is sufficient. A language that is decided by some ATM in time c ⋅ t ( n ) {\\displaystyle c\\cdot t(n)} for some constant c > 0 {\\displaystyle c>0} is said to be in the class A T I M E ( t ( n ) )",
    "source_url": "https://en.wikipedia.org/wiki/Alternating_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:14.933904",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:14.933904",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:14.933904",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Alternating_Turing_machine_1_1749014174959_9324",
    "text": "( t ( n ) ) {\\displaystyle {\\mathsf {ATIME}}(t(n))} , and a language decided in space c ⋅ s ( n ) {\\displaystyle c\\cdot s(n)} is said to be in the class A S P A C E ( s ( n ) ) {\\displaystyle {\\mathsf {ASPACE}}(s(n))} . Example [ edit ] Perhaps the most natural problem for alternating machines to solve is the quantified Boolean formula problem , which is a generalization of the Boolean satisfiability problem in which each variable can be bound by either an existential or a universal quantifier. The alternating machine branches existentially to try all possible values of an existentially quantified variable and universally to try all possible values of a universally quantified variable, in the left-to-right order in which they are bound. After deciding a value for all quantified variables, the machine accepts if the resulting Boolean formula evaluates to true, and rejects if it evaluates to false.",
    "source_url": "https://en.wikipedia.org/wiki/Alternating_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:14.959904",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:14.959904",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:14.959904",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Post%E2%80%93Turing_machine_1_1749014176073_2373",
    "text": "Jump to content From Wikipedia, the free encyclopedia Abstract calculator This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article contains instructions, advice, or how-to content . Please help rewrite the content so that it is more encyclopedic or move it to Wikiversity , Wikibooks , or Wikivoyage . ( August 2020 ) This article is written like a research paper or a scientific journal . Please",
    "source_url": "https://en.wikipedia.org/wiki/Post%E2%80%93Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:16.073525",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:16.073525",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:16.073525",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Raita_algorithm_1_1749014179771_4990",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) The topic of this article may not meet Wikipedia's general notability guideline . Please help to demonstrate the notability of the topic by citing reliable secondary sources that are independent of the topic and provide significant coverage of it beyond a mere trivial mention. If notability cannot",
    "source_url": "https://en.wikipedia.org/wiki/Raita_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:19.771496",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:19.771496",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:19.771496",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Apostolico–Giancarlo_algorithm&oldid=1279904834_1_1749014180249_3740",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Froglegseternal ( talk | contribs ) at 07:58, 11 March 2025 (switching to using Template:mvar and Template:math instead of math tag as to get rid of error) . The present address (URL) is a permanent link to this version. Revision as of 07:58, 11 March 2025 by Froglegseternal ( talk | contribs ) (switching to using Template:mvar and Template:math instead of math tag as to get rid of error",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Apostolico–Giancarlo_algorithm&oldid=1279904834",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:20.249773",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:20.249773",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:20.249773",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoid_method_1_1749014183639_6317",
    "text": "Jump to content From Wikipedia, the free encyclopedia Iterative method for minimizing convex functions Example of graph. In mathematical optimization , the ellipsoid method is an iterative method for minimizing convex functions over convex sets . The ellipsoid method generates a sequence of ellipsoids whose volume uniformly decreases at every step, thus enclosing a minimizer of a convex function . When specialized to solving feasible linear optimization problems with rational data, the ellipsoid",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoid_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:23.639280",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:23.639280",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:23.639280",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Approximation_algorithm&oldid=1287316159_1_1749014185243_6388",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by 2001:638:708:306:290e:2b4c:e37e:90ea ( talk ) at 12:31, 25 April 2025 ( → Performance guarantees : fixed a typo) . The present address (URL) is a permanent link to this version. Revision as of 12:31, 25 April 2025 by 2001:638:708:306:290e:2b4c:e37e:90ea ( talk ) ( → Performance guarantees : fixed a typo) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Clas",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Approximation_algorithm&oldid=1287316159",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:25.243110",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:25.243110",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:25.243110",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_A*_search_algorithm_1_1749014187658_8938",
    "text": "Record it! cameFrom [ neighbor ] := current gScore [ neighbor ] := tentative_gScore fScore [ neighbor ] := tentative_gScore + h ( neighbor ) if neighbor not in openSet openSet . add ( neighbor ) // Open set is empty but goal was never reached return failure Remark: In this pseudocode, if a node is reached by one path, removed from openSet, and subsequently reached by a cheaper path, it will be added to openSet again. This is essential to guarantee that the path returned is optimal if the heuristic function is admissible but not consistent . If the heuristic is consistent, when a node is removed from openSet the path to it is guaranteed to be optimal so the test ‘ tentative_gScore < gScore[neighbor] ’ will always fail if the node is reached again. The pseudocode implemented here is sometimes called the graph-search version of A*.",
    "source_url": "https://en.wikipedia.org/wiki/A*_search_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:27.658786",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:27.658786",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:27.658786",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Baum_Welch_algorithm_1_1749014192094_3614",
    "text": "We also assume the observation given the \"hidden\" state is time independent. The probability of a certain observation y i {\\displaystyle y_{i}} at time t {\\displaystyle t} for state X t = j {\\displaystyle X_{t}=j} is given by b j ( y i ) = P ( Y t = y i ∣ X t = j ) . {\\displaystyle b_{j}(y_{i})=P(Y_{t}=y_{i}\\mid X_{t}=j).} Taking into account all the possible values of Y t {\\displaystyle Y_{t}} and X t {\\displaystyle X_{t}} , we obtain the N × K {\\displaystyle N\\times K} matrix B = { b j ( y i ) } {\\displaystyle B=\\{b_{j}(y_{i})\\}} where b j {\\displaystyle b_{j}} belongs to all the possible states and y i {\\displaystyle y_{i}} belongs to all the observations. An observation sequence is given by Y = ( Y 1 = y 1 , Y 2 = y 2 , … , Y T = y T ) {\\displaystyle Y=(Y_{1}=y_{1},Y_{2}=y_{2},\\ldots ,Y_{T}=y_{T})} . Thus we can describe a hidden Markov chain by θ = ( A , B , π ) {\\displaystyle \\theta =(A,B,\\pi )} .",
    "source_url": "https://en.wikipedia.org/wiki/Baum_Welch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:32.094277",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:32.094277",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:32.094277",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Baum_Welch_algorithm_1_1749014192222_7750",
    "text": "Backward procedure [ edit ] Let β i ( t ) = P ( Y t + 1 = y t + 1 , … , Y T = y T ∣ X t = i , θ ) {\\displaystyle \\beta _{i}(t)=P(Y_{t+1}=y_{t+1},\\ldots ,Y_{T}=y_{T}\\mid X_{t}=i,\\theta )} that is the probability of the ending partial sequence y t + 1 , … , y T {\\displaystyle y_{t+1},\\ldots ,y_{T}} given starting state i {\\displaystyle i} at time t {\\displaystyle t} . We calculate β i ( t ) {\\displaystyle \\beta _{i}(t)} as, β i ( T ) = 1 , {\\displaystyle \\beta _{i}(T)=1,} β i ( t ) = ∑ j = 1 N β j ( t + 1 ) a i j b j ( y t + 1 ) . {\\displaystyle \\beta _{i}(t)=\\sum _{j=1}^{N}\\beta _{j}(t+1)a_{ij}b_{j}(y_{t+1}).} Update [ edit ] We can now calculate the temporary variables, according to Bayes' theorem: γ i ( t ) = P ( X t = i ∣ Y , θ ) = P ( X t = i , Y ∣ θ ) P ( Y ∣ θ ) = α i ( t ) β i ( t ) ∑ j = 1 N α j ( t )",
    "source_url": "https://en.wikipedia.org/wiki/Baum_Welch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:32.222018",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:32.222018",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:32.222018",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Baum_Welch_algorithm_1_1749014192252_3280",
    "text": "= i ∣ Y , θ ) = P ( X t = i , Y ∣ θ ) P ( Y ∣ θ ) = α i ( t ) β i ( t ) ∑ j = 1 N α j ( t ) β j ( t ) , {\\displaystyle \\gamma _{i}(t)=P(X_{t}=i\\mid Y,\\theta )={\\frac {P(X_{t}=i,Y\\mid \\theta )}{P(Y\\mid \\theta )}}={\\frac {\\alpha _{i}(t)\\beta _{i}(t)}{\\sum _{j=1}^{N}\\alpha _{j}(t)\\beta _{j}(t)}},} which is the probability of being in state i {\\displaystyle i} at time t {\\displaystyle t} given the observed sequence Y {\\displaystyle Y} and the parameters θ {\\displaystyle \\theta } ξ i j ( t ) = P ( X t = i , X t + 1 = j ∣ Y , θ ) = P ( X t = i , X t + 1 = j , Y ∣ θ ) P ( Y ∣ θ ) = α i ( t ) a i j β j ( t + 1 ) b j ( y t + 1 ) ∑",
    "source_url": "https://en.wikipedia.org/wiki/Baum_Welch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:32.252503",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:32.253496",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:32.253496",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Baum_Welch_algorithm_1_1749014192286_2800",
    "text": "= P ( X t = i , X t + 1 = j , Y ∣ θ ) P ( Y ∣ θ ) = α i ( t ) a i j β j ( t + 1 ) b j ( y t + 1 ) ∑ k = 1 N ∑ w = 1 N α k ( t ) a k w β w ( t + 1 ) b w ( y t + 1 ) , {\\displaystyle \\xi _{ij}(t)=P(X_{t}=i,X_{t+1}=j\\mid Y,\\theta )={\\frac {P(X_{t}=i,X_{t+1}=j,Y\\mid \\theta )}{P(Y\\mid \\theta )}}={\\frac {\\alpha _{i}(t)a_{ij}\\beta _{j}(t+1)b_{j}(y_{t+1})}{\\sum _{k=1}^{N}\\sum _{w=1}^{N}\\alpha _{k}(t)a_{kw}\\beta _{w}(t+1)b_{w}(y_{t+1})}},} which is the probability of being in state i {\\displaystyle i} and j {\\displaystyle j} at times t {\\displaystyle t} and t + 1 {\\displaystyle t+1} respectively given the observed sequence Y {\\displaystyle Y} and parameters θ {\\displaystyle \\theta } . The denominators of γ i ( t ) {\\displaystyle \\gamma _{i}(t)} and ξ i j ( t ) {\\displaystyle \\xi _{ij}(t)} are the same ; they represent the probability of making the observation Y {\\displaystyle Y} given the parameters θ {\\displaystyle \\theta } .",
    "source_url": "https://en.wikipedia.org/wiki/Baum_Welch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:32.286495",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:32.287502",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:32.287502",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Baum_Welch_algorithm_1_1749014192317_5419",
    "text": "The parameters of the  hidden Markov model θ {\\displaystyle \\theta } can now be updated: π i ∗ = γ i ( 1 ) , {\\displaystyle \\pi _{i}^{*}=\\gamma _{i}(1),} which is the expected frequency spent in state i {\\displaystyle i} at time 1 {\\displaystyle 1} . a i j ∗ = ∑ t = 1 T − 1 ξ i j ( t ) ∑ t = 1 T − 1 γ i ( t ) , {\\displaystyle a_{ij}^{*}={\\frac {\\sum _{t=1}^{T-1}\\xi _{ij}(t)}{\\sum _{t=1}^{T-1}\\gamma _{i}(t)}},} which is the expected number of transitions from state i to state j compared to the expected total number of transitions away from state i . To clarify, the number of transitions away from state i does not mean transitions to a different state j , but to any state including itself. This is equivalent to the number of times state i is observed in the sequence from t = 1 to t = T − 1. b i ∗ ( v k ) = ∑ t = 1 T 1 y t = v k γ i ( t )",
    "source_url": "https://en.wikipedia.org/wiki/Baum_Welch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:32.317213",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:32.318218",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:32.318218",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Baum–Welch_algorithm&oldid=1283493044_1_1749014194184_3252",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by DA1312 ( talk | contribs ) at 21:05, 1 April 2025 ( → Multiple sequences : length of observation string should be T, not N) . The present address (URL) is a permanent link to this version. Revision as of 21:05, 1 April 2025 by DA1312 ( talk | contribs ) ( → Multiple sequences : length of observation string should be T, not N) ( diff ) ← Previous revision | Latest revision (diff) | Newer ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Baum–Welch_algorithm&oldid=1283493044",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:34.184399",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:34.185902",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:34.185902",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bellman%E2%80%93Ford_algorithm_1_1749014196421_9543",
    "text": "The distance from the source to itself is zero\n    distance[source] := 0 // Step 2: relax edges repeatedly repeat |V|−1 times : for each edge (u, v) with weight w in edges do if distance[u] + w < distance[v] then distance[v] := distance[u] + w\n                predecessor[v] := u // Step 3: check for negative-weight cycles for each edge (u, v) with weight w in edges do if distance[u] + w < distance[v] then predecessor[v] := u // A negative cycle exists; // find a vertex on the cycle visited := list of size n initialized with false visited[v] := true while not visited[u] do visited[u] := true u := predecessor[u] // u is a vertex in a negative cycle, // find the cycle itself ncycle := [u]\n            v := predecessor[u] while v !",
    "source_url": "https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:36.421748",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:36.422757",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:36.422757",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bellman%E2%80%93Ford_algorithm_1_1749014196569_1618",
    "text": "Then, for the source vertex, source.distance = 0 , which is correct. For other vertices u , u.distance = infinity , which is also correct because there is no path from source to u with 0 edges. For the inductive case, we first prove the first part. Consider a moment when a vertex's distance is updated by v.distance := u.distance + uv.weight . By inductive assumption, u.distance is the length of some path from source to u . Then u.distance + uv.weight is the length of the path from source to v that follows the path from source to u and then goes to v . For the second part, consider a shortest path P (there may be more than one) from source to v with at most i edges. Let u be the last vertex before v on this path.",
    "source_url": "https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:36.569037",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:36.569037",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:36.569037",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bellman%E2%80%93Ford_algorithm_1_1749014196595_1873",
    "text": "Let u be the last vertex before v on this path. Then, the part of the path from source to u is a shortest path from source to u with at most i-1 edges, since if it were not, then there must be some strictly shorter path from source to u with at most i-1 edges, and we could then append the edge uv to this path to obtain a path with at most i edges that is strictly shorter than P —a contradiction. By inductive assumption, u.distance after i −1 iterations is at most the length of this path from source to u . Therefore, uv.weight + u.distance is at most the length of P . In the i th iteration, v.distance gets compared with uv.weight + u.distance , and is set equal to it if uv.weight + u.distance is smaller. Therefore, after i iterations, v.distance is at most the length of P , i.e., the length of the shortest path from source to v that uses at most i edges.",
    "source_url": "https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:36.595039",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:36.596030",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:36.596030",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Bellman–Ford_algorithm&oldid=1291957379_1_1749014197858_1468",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Shycha ( talk | contribs ) at 11:38, 24 May 2025 (Re-flow comments in the BellmanFord function. Without re-flowing some of the lines that contain comments are wrapped around, which reduces readability in standard text + standard width appearance.) . The present address (URL) is a permanent link to this version. Revision as of 11:38, 24 May 2025 by Shycha ( talk | contribs ) (Re-flow comm",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Bellman–Ford_algorithm&oldid=1291957379",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:37.858945",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:37.859943",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:37.859943",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Boyer–Moore_string-search_algorithm&oldid=1292002112_1_1749014200616_6332",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 17:10, 24 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 17:10, 24 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Stri",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Boyer–Moore_string-search_algorithm&oldid=1292002112",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:40.616677",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:40.616677",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:40.616677",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bresenham%27s_line_algorithm_1_1749014205252_9811",
    "text": "Then, using algebraic manipulation, y = m x + b y = Δ y Δ x x + b ( Δ x ) y = ( Δ y ) x + ( Δ x ) b 0 = ( Δ y ) x − ( Δ x ) y + ( Δ x ) b {\\displaystyle {\\begin{aligned}y&=mx+b\\\\y&={\\frac {\\Delta y}{\\Delta x}}x+b\\\\(\\Delta x)y&=(\\Delta y)x+(\\Delta x)b\\\\0&=(\\Delta y)x-(\\Delta x)y+(\\Delta x)b\\end{aligned}}} Letting this last equation be a function of x {\\displaystyle x} and y {\\displaystyle y} , it can be written as f ( x , y ) : = A x + B y + C = 0 {\\displaystyle f(x,y):=Ax+By+C=0} where the constants are A = Δ y = y 1 − y 0 {\\displaystyle A=\\Delta y=y_{1}-y_{0}} B = − Δ x = − ( x 1 − x 0 ) {\\displaystyle B=-\\Delta x=-(x_{1}-x_{0})} C = ( Δ x ) b = ( x 1 − x 0 ) b {\\displaystyle C=(\\Delta x)b=(x_{1}-x_{0})b} The line is then defined for some constants A {\\displaystyle A} , B {\\displaystyle B} , and C {\\displaystyle C} anywhere f ( x , y ) = 0 {\\displaystyle f(x,y)=0} . That is, for any ( x , y ) {\\displaystyle (x,y)} not on the line, f ( x , y ) ≠ 0 {\\displaystyle f(x,y)\\neq 0} .",
    "source_url": "https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:45.252599",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:45.252599",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:45.252599",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bresenham%27s_line_algorithm_1_1749014205288_7087",
    "text": "This form involves only integers if x {\\displaystyle x} and y {\\displaystyle y} are integers, since the constants A {\\displaystyle A} , B {\\displaystyle B} , and C {\\displaystyle C} are defined as integers. As an example, the line y = 1 2 x + 1 {\\textstyle y={\\frac {1}{2}}x+1} then this could be written as f ( x , y ) = x − 2 y + 2 {\\displaystyle f(x,y)=x-2y+2} . The point (2,2) is on the line f ( 2 , 2 ) = x − 2 y + 2 = ( 2 ) − 2 ( 2 ) + 2 = 2 − 4 + 2 = 0 {\\displaystyle f(2,2)=x-2y+2=(2)-2(2)+2=2-4+2=0} and the point (2,3) is not on the line f ( 2 , 3 ) = ( 2 ) − 2 ( 3 ) + 2 = 2 − 6 + 2 = − 2 {\\displaystyle f(2,3)=(2)-2(3)+2=2-6+2=-2} and neither is the point (2,1) f ( 2 , 1 ) = ( 2 ) − 2 ( 1 ) + 2 = 2 − 2 + 2 = 2 {\\displaystyle f(2,1)=(2)-2(1)+2=2-2+2=2} Notice that the points (2,1) and (2,3) are on opposite sides of the line and f ( x , y ) {\\displaystyle f(x,y)} evaluates to positive or negative.",
    "source_url": "https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:45.288599",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:45.289599",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:45.289599",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bresenham%27s_line_algorithm_1_1749014205367_9981",
    "text": "If it is closer to the former then include the former point on the line, if the latter then the latter. To answer this, evaluate the line function at the midpoint between these two points: f ( x 0 + 1 , y 0 + 1 2 ) {\\displaystyle f(x_{0}+1,y_{0}+{\\tfrac {1}{2}})} If the value of this is positive then the ideal line is below the midpoint and closer to the candidate point ( x 0 + 1 , y 0 + 1 ) {\\displaystyle (x_{0}+1,y_{0}+1)} ; i.e. the y coordinate should increase. Otherwise, the ideal line passes through or above the midpoint, and the y coordinate should stay the same; in which case the point ( x 0 + 1 , y 0 ) {\\displaystyle (x_{0}+1,y_{0})} is chosen. The value of the line function at this midpoint is the sole determinant of which point should be chosen. The adjacent image shows the blue point (2,2) chosen to be on the line with two candidate points in green (3,2) and (3,3). The black point (3, 2.5) is the midpoint between the two candidate points.",
    "source_url": "https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:45.367804",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:45.367804",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:45.367804",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Line_drawing_algorithm_1_1749014206471_2491",
    "text": "Jump to content From Wikipedia, the free encyclopedia Methods of approximating line segments for pixel displays You can help expand this article with text translated from the corresponding article in German . (December 2009) Click [show] for important translation instructions. View a machine-translated version of the German article. Machine translation, like DeepL or Google Translate , is a useful starting point for translations, but translators must revise errors as necessary and confirm that t",
    "source_url": "https://en.wikipedia.org/wiki/Line_drawing_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:46.471881",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:46.472151",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:46.472151",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Bresenham%27s_line_algorithm&oldid=1279068183_1_1749014207013_6171",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Citation bot ( talk | contribs ) at 09:07, 6 March 2025 (Altered title. | Use this bot . Report bugs . | Suggested by Dominic3203 | Category:Digital geometry | #UCB_Category 38/43) . The present address (URL) is a permanent link to this version. Revision as of 09:07, 6 March 2025 by Citation bot ( talk | contribs ) (Altered title. | Use this bot . Report bugs . | Suggested by Dominic3203",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Bresenham%27s_line_algorithm&oldid=1279068183",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:47.013990",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:47.013990",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:47.013990",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=British_Museum_algorithm&oldid=1292751629_1_1749014209033_6968",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 16:28, 28 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 16:28, 28 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) The ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=British_Museum_algorithm&oldid=1292751629",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:49.033803",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:49.033803",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:49.033803",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Cayley%E2%80%93Purser_algorithm_1_1749014210043_8840",
    "text": "For example, if n =5, we could write: [ 0 1 2 3 ] + [ 1 2 3 4 ] = [ 1 3 5 7 ] ≡ [ 1 3 0 2 ] {\\displaystyle {\\begin{bmatrix}0&1\\\\2&3\\end{bmatrix}}+{\\begin{bmatrix}1&2\\\\3&4\\end{bmatrix}}={\\begin{bmatrix}1&3\\\\5&7\\end{bmatrix}}\\equiv {\\begin{bmatrix}1&3\\\\0&2\\end{bmatrix}}} [ 0 1 2 3 ] [ 1 2 3 4 ] = [ 3 4 11 16 ] ≡ [ 3 4 1 1 ] {\\displaystyle {\\begin{bmatrix}0&1\\\\2&3\\end{bmatrix}}{\\begin{bmatrix}1&2\\\\3&4\\end{bmatrix}}={\\begin{bmatrix}3&4\\\\11&16\\end{bmatrix}}\\equiv {\\begin{bmatrix}3&4\\\\1&1\\end{bmatrix}}} This group is chosen because it has large order (for large semiprime n ), equal to ( p 2 −1)( p 2 − p )( q 2 −1)( q 2 − q ). Let χ {\\displaystyle \\chi } and α {\\displaystyle \\alpha } be two such matrices from GL(2, n ) chosen such that χ α ≠ α χ {\\displaystyle \\chi \\alpha \\not =\\alpha \\chi } . Choose some natural number r and compute: β = χ − 1 α − 1 χ , {\\displaystyle \\beta =\\chi ^{-1}\\alpha ^{-1}\\chi ,} γ = χ r . { \\displaystyle \\gamma =\\chi ^{r}.}",
    "source_url": "https://en.wikipedia.org/wiki/Cayley%E2%80%93Purser_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:50.043650",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:50.043650",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:50.043650",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Cayley%E2%80%93Purser_algorithm_1_1749014210071_9399",
    "text": "{ \\displaystyle \\gamma =\\chi ^{r}.} The public key is n {\\displaystyle n} , α {\\displaystyle \\alpha } , β {\\displaystyle \\beta } , and γ {\\displaystyle \\gamma } . The private key is χ {\\displaystyle \\chi } . Encryption [ edit ] The sender begins by generating a random natural number s and computing: δ = γ s {\\displaystyle \\delta =\\gamma ^{s}} ϵ = δ − 1 α δ {\\displaystyle \\epsilon =\\delta ^{-1}\\alpha \\delta } κ = δ − 1 β δ {\\displaystyle \\kappa =\\delta ^{-1}\\beta \\delta } Then, to encrypt a message, each message block is encoded as a number (as in RSA) and they are placed four at a time as elements of a plaintext matrix μ {\\displaystyle \\mu } . Each μ {\\displaystyle \\mu } is encrypted using: μ ′ = κ μ κ . {\\displaystyle \\mu '=\\kappa \\mu \\kappa .} Then μ ′ {\\displaystyle \\mu '} and ϵ {\\displaystyle \\epsilon } are sent to the receiver. Decryption [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Cayley%E2%80%93Purser_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:50.071729",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:50.071729",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:50.071729",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Christofides_algorithm_1_1749014214432_4055",
    "text": "Then the minimum spanning tree will be given by the path, of length n − 1 , and the only two odd vertices will be the path endpoints, whose perfect matching consists of a single edge with weight approximately n /2 . The union of the tree and the matching is a cycle, with no possible shortcuts, and with weight approximately 3 n /2 . However, the optimal solution uses the edges of weight 1 + ε together with two weight- 1 edges incident to the endpoints of the path,\nand has total weight (1 + ε )( n − 2) + 2 , close to n for small values of ε . Hence we obtain an approximation ratio of 3/2. [ 5 ] Example [ edit ] Given: complete graph whose edge weights obey the triangle inequality Calculate minimum spanning tree T Calculate the set of vertices O with odd degree in T Form the subgraph of G using only the vertices of O",
    "source_url": "https://en.wikipedia.org/wiki/Christofides_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:54.432806",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:54.432806",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:54.432806",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Confluently_persistent_data_structure_1_1749014217361_4244",
    "text": "(It is assumed that each modification touches one pointer or similar field.) If the node's modification box is empty, then it is filled with the modification. Otherwise, the modification box is full. A copy of the node is made, but using only the latest values. The modification is performed directly on the new node, without using the modification box. (One of the new node's fields is overwritten and its modification box stays empty.) Finally, this change is cascaded to the node's parent, just like path copying. (This may involve filling the parent's modification box, or making a copy of the parent recursively. If the node has no parent—it's the root—it is added the new root to a sorted array of roots.)",
    "source_url": "https://en.wikipedia.org/wiki/Confluently_persistent_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:16:57.361668",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:16:57.361668",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:16:57.361668",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Deterministic_algorithm_1_1749014226887_7712",
    "text": "Disadvantages of determinism [ edit ] It is advantageous, in some cases, for a program to exhibit nondeterministic behavior. The behavior of a card shuffling program used in a game of blackjack , for example, should not be predictable by players — even if the source code of the program is visible. The use of a pseudorandom number generator is often not sufficient to ensure that players are unable to predict the outcome of a shuffle. A clever gambler might guess precisely the numbers the generator will choose and so determine the entire contents of the deck ahead of time, allowing him to cheat; for example, the Software Security Group at Reliable Software Technologies was able to do this for an implementation of Texas Hold 'em Poker that is distributed by ASF Software, Inc, allowing them to consistently predict the outcome of hands ahead of time.",
    "source_url": "https://en.wikipedia.org/wiki/Deterministic_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:06.887486",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:06.888487",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:06.888487",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Deutsch%E2%80%93Jozsa_algorithm_1_1749014229182_6859",
    "text": "⟩ {\\displaystyle |0\\rangle } and the final bit is | 1 ⟩ {\\displaystyle |1\\rangle } . A Hadamard gate is applied to each bit to obtain the state 1 2 n + 1 ∑ x = 0 2 n − 1 | x ⟩ ( | 0 ⟩ − | 1 ⟩ ) , {\\displaystyle {\\frac {1}{\\sqrt {2^{n+1}}}}\\sum _{x=0}^{2^{n}-1}|x\\rangle (|0\\rangle -|1\\rangle ),} where x {\\displaystyle x} runs over all n {\\displaystyle n} -bit strings, which each may be represented by a number from 0 {\\displaystyle 0} to 2 n − 1 {\\displaystyle 2^{n}-1} . We have the function f {\\displaystyle f} implemented as a quantum oracle. The oracle maps its input state | x ⟩ | y ⟩ {\\displaystyle |x\\rangle |y\\rangle } to | x ⟩ | y ⊕ f ( x ) ⟩ {\\displaystyle |x\\rangle |y\\oplus f(x)\\rangle } , where ⊕ {\\displaystyle \\oplus } denotes addition modulo 2. Applying the quantum oracle gives; 1 2 n + 1 ∑ x = 0 2 n − 1 | x ⟩ ( | 0 ⊕ f ( x ) ⟩ − | 1 ⊕ f ( x ) ⟩ ) . {\\displaystyle {\\frac {1}{\\sqrt {2^{n+1}}}}\\sum _{x=0}^{2^{n}-1}|x\\rangle (|0\\oplus f(x)\\rangle -|1\\oplus f(x)\\rangle ).}",
    "source_url": "https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:09.182930",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:09.182930",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:09.182930",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Deutsch%E2%80%93Jozsa_algorithm_1_1749014229471_8105",
    "text": "For each x , f ( x ) {\\displaystyle x,f(x)} is either 0 or 1. Testing these two possibilities, we see the above state is equal to 1 2 n + 1 ∑ x = 0 2 n − 1 ( − 1 ) f ( x ) | x ⟩ ( | 0 ⟩ − | 1 ⟩ ) . {\\displaystyle {\\frac {1}{\\sqrt {2^{n+1}}}}\\sum _{x=0}^{2^{n}-1}(-1)^{f(x)}|x\\rangle (|0\\rangle -|1\\rangle ).} At this point the last qubit | 0 ⟩ − | 1 ⟩ 2 {\\displaystyle {\\frac {|0\\rangle -|1\\rangle }{\\sqrt {2}}}} may be ignored and the following remains: 1 2 n ∑ x = 0 2 n − 1 ( − 1 ) f ( x ) | x ⟩ . {\\displaystyle {\\frac {1}{\\sqrt {2^{n}}}}\\sum _{x=0}^{2^{n}-1}(-1)^{f(x)}|x\\rangle .} Next, we will have each qubit go through a Hadamard gate . The total transformation over all n {\\displaystyle n} qubits can be expressed with the following identity: H ⊗ n | k ⟩ = 1 2 n ∑ j = 0 2 n − 1 ( − 1 ) k ⋅ j | j ⟩ {\\displaystyle H^{\\otimes n}|k\\rangle ={\\frac {1}{\\sqrt {2^{n}}}}\\sum _{j=0}^{2^{n}-1}(-1)^{k\\cdot j}|j\\rangle } ( j ⋅ k = j 0 k 0",
    "source_url": "https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:09.471638",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:09.472639",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:09.472639",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Deutsch%E2%80%93Jozsa_algorithm_1_1749014229505_4079",
    "text": "⊕ j 1 k 1 ⊕ ⋯ ⊕ j n − 1 k n − 1 {\\displaystyle j\\cdot k=j_{0}k_{0}\\oplus j_{1}k_{1}\\oplus \\cdots \\oplus j_{n-1}k_{n-1}} is the sum of the bitwise product). This results in 1 2 n ∑ x = 0 2 n − 1 ( − 1 ) f ( x ) [ 1 2 n ∑ y = 0 2 n − 1 ( − 1 ) x ⋅ y | y ⟩ ] = ∑ y = 0 2 n − 1 [ 1 2 n ∑ x = 0 2 n − 1 ( − 1 ) f ( x ) ( − 1 ) x ⋅ y ] | y ⟩ . {\\displaystyle {\\frac {1}{\\sqrt {2^{n}}}}\\sum _{x=0}^{2^{n}-1}(-1)^{f(x)}\\left[{\\frac {1}{\\sqrt {2^{n}}}}\\sum _{y=0}^{2^{n}-1}{\\left(-1\\right)}^{x\\cdot y}|y\\rangle \\right]=\\sum _{y=0}^{2^{n}-1}\\left[{\\frac {1}{2^{n}}}\\sum _{x=0}^{2^{n}-1}(-1)^{f(x)}(-1)^{x\\cdot y}\\right]|y\\rangle .} From this, we can see that the probability for a state k {\\displaystyle k} to be measured is | 1 2 n ∑ x = 0 2 n − 1 ( − 1 ) f ( x ) ( − 1 ) x ⋅ k | 2 {\\displaystyle \\left|{\\frac {1}{2^{n}}}\\sum _{x=0}^{2^{n}-1}{\\left(-1\\right)}^{f(x)}{\\left(-1\\right)}^{x\\cdot k}\\right|^{2}} The probability of measuring k = 0 {\\displaystyle k=0} , corresponding to | 0",
    "source_url": "https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:09.505073",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:09.505073",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:09.505073",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Deutsch%E2%80%93Jozsa_algorithm_1_1749014229587_1712",
    "text": "We need to check the condition f ( 0 ) = f ( 1 ) {\\displaystyle f(0)=f(1)} . It is equivalent to check f ( 0 ) ⊕ f ( 1 ) {\\displaystyle f(0)\\oplus f(1)} (where ⊕ {\\displaystyle \\oplus } is addition modulo 2, which can also be viewed as a quantum XOR gate implemented as a Controlled NOT gate ), if zero, then f {\\displaystyle f} is constant, otherwise f {\\displaystyle f} is not constant. We begin with the two-qubit state | 0 ⟩ | 1 ⟩ {\\displaystyle |0\\rangle |1\\rangle } and apply a Hadamard gate to each qubit. This yields 1 2 ( | 0 ⟩ + | 1 ⟩ ) ( | 0 ⟩ − | 1 ⟩ ) . {\\displaystyle {\\frac {1}{2}}(|0\\rangle +|1\\rangle )(|0\\rangle -|1\\rangle ).} We are given a quantum implementation of the function f {\\displaystyle f} that maps | x ⟩ | y ⟩ {\\displaystyle |x\\rangle |y\\rangle } to | x ⟩ | f ( x ) ⊕ y ⟩ {\\displaystyle |x\\rangle |f(x)\\oplus y\\rangle } . Applying this function to our current state we obtain 1 2 ( | 0 ⟩ ( | f ( 0 ) ⊕ 0 ⟩ − | f ( 0 ) ⊕ 1 ⟩ ) + | 1 ⟩ ( | f ( 1 ) ⊕ 0",
    "source_url": "https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:09.587734",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:09.587734",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:09.587734",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Dictionary_(data_structure)_1_1749014232491_4987",
    "text": "The argument to this operation is the key, and the value is returned from the operation. If no value is found, some lookup functions raise an exception , while others return a default value (such as zero, null, or a specific value passed to the constructor). Associative arrays may also include other operations such as determining the number of mappings or constructing an iterator to loop over all the mappings. For such operations, the order in which the mappings are returned is usually implementation-defined. A multimap generalizes an associative array by allowing multiple values to be associated with a single key. [ 10 ] A bidirectional map is a related abstract data type in which the mappings operate in both directions: each value must be associated with a unique key, and a second lookup operation takes a value as an argument and looks up the key associated with that value. Properties [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Dictionary_(data_structure)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:12.491064",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:12.492057",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:12.492057",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Dictionary_(data_structure)_1_1749014232597_2461",
    "text": "However, it is easy to implement and the constant factors in its running time are small. [ 3 ] [ 11 ] Another very simple implementation technique, usable when the keys are restricted to a narrow range, is direct addressing into an array: the value for a given key k is stored at the array cell A [ k ], or if there is no mapping for k then the cell stores a special sentinel value that indicates the lack of a mapping. This technique is simple and fast, with each dictionary operation taking constant time. However, the space requirement for this structure is the size of the entire keyspace, making it impractical unless the keyspace is small. [ 5 ] The two major approaches for implementing dictionaries are a hash table or a search tree .",
    "source_url": "https://en.wikipedia.org/wiki/Dictionary_(data_structure)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:12.597822",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:12.597822",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:12.597822",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Dijkstra%27s_algorithm_1_1749014235545_1634",
    "text": "Every other intersection is initially labeled with a distance of infinity. This is done to note that no path to these intersections has yet been established. At each iteration one intersection becomes the current intersection. For the first iteration, this is the starting point. From the current intersection, the distance to every neighbor (directly-connected) intersection is assessed by summing the label (value) of the current intersection and the distance to the neighbor and then relabeling the neighbor with the lesser of that sum and the neighbor's existing label. I.e., the neighbor is relabeled if the path to it through the current intersection is shorter than previously assessed paths. If so, mark the road to the neighbor with an arrow pointing to it, and erase any other arrow that points to it. After the distances to each of the current intersection's neighbors have been assessed, the current intersection is marked as visited.",
    "source_url": "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:15.545783",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:15.545783",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:15.545783",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Dijkstra%27s_algorithm_1_1749014235574_4123",
    "text": "The unvisited intersection with the smallest label becomes the current intersection and the process repeats until all nodes with labels less than the destination's label have been visited. Once no unvisited nodes remain with a label smaller than the destination's label, the remaining arrows show the shortest path. Pseudocode [ edit ] In the following pseudocode , dist is an array that contains the current distances from the source to other vertices, i.e. dist[ u ] is the current distance from the source to the vertex u . The prev array contains pointers to previous-hop nodes on the shortest path from source to the given vertex (equivalently, it is the next-hop on the path from the given vertex to the source). The code u ← vertex in Q with min dist[u] , searches for the vertex u in the vertex set Q that has the least dist[ u ] value. Graph. Edges( u , v ) returns the length of the edge joining (i.e. the distance between) the two neighbor-nodes u and v .",
    "source_url": "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:15.574307",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:15.574307",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:15.574307",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Parallel_all-pairs_shortest_path_algorithm_1_1749014238638_3697",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article includes a list of references , related reading , or external links , but its sources remain unclear because it lacks inline citations . Please help improve this article by introducing more precise citations. ( March 2018 ) ( Learn how and when to remove this message ) This article co",
    "source_url": "https://en.wikipedia.org/wiki/Parallel_all-pairs_shortest_path_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:18.638900",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:18.638900",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:18.638900",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Dijkstra%27s_algorithm&oldid=1293697584_1_1749014240094_7597",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Gymate ( talk | contribs ) at 05:42, 3 June 2025 (Move value of deprecated Template:Rp parameter to a new one) . The present address (URL) is a permanent link to this version. Revision as of 05:42, 3 June 2025 by Gymate ( talk | contribs ) (Move value of deprecated Template:Rp parameter to a new one) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Algorith",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Dijkstra%27s_algorithm&oldid=1293697584",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:20.094189",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:20.095183",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:20.095183",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Euclidean_algorithm_1_1749014253473_6472",
    "text": "A 24×60 rectangle is covered with ten 12×12 square tiles, where 12 is the GCD of 24 and 60. More generally, an a × b rectangle can be covered with square tiles of side-length c only if c is a common divisor of a and b . Let g = gcd( a , b ) . Since a and b are both multiples of g , they can be written a = mg and b = ng , and there is no larger number G > g for which this is true. The natural numbers m and n must be coprime, since any common factor could be factored out of m and n to make g greater. Thus, any other number c that divides both a and b must also divide g . The greatest common divisor g of a and b is the unique (positive) common divisor of a and b that is divisible by any other common divisor c . [ 6 ] The greatest common divisor can be visualized as follows. [ 7 ] Consider a rectangular area a by b , and any common divisor c that divides both a and b exactly.",
    "source_url": "https://en.wikipedia.org/wiki/Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:33.473339",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:33.474341",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:33.474341",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Euclidean_algorithm_1_1749014253651_3776",
    "text": "This determines r 0 = 147 {\\displaystyle r_{0}=147} and so the sequence is now { 1071 , 462 , r 0 = 147 } {\\displaystyle \\{1071,\\ 462,\\ r_{0}=147\\}} . The next step is to continue the sequence to find r 1 {\\displaystyle r_{1}} by finding integers q 1 {\\displaystyle q_{1}} and r 1 < r 0 {\\displaystyle r_{1}<r_{0}} such that: 462 = q 1 ⋅ 147 + r 1 {\\displaystyle 462=q_{1}\\cdot 147+r_{1}} . This is the quotient q 1 = 3 {\\displaystyle q_{1}=3} since 462 = 3 ⋅ 147 + 21 {\\displaystyle 462=3\\cdot 147+21} . This determines r 1 = 21 {\\displaystyle r_{1}=21} and so the sequence is now { 1071 , 462 , 147 , r 1 = 21 } {\\displaystyle \\{1071,\\ 462,\\ 147,\\ r_{1}=21\\}} . The next step is to continue the sequence to find r 2 {\\displaystyle r_{2}} by finding integers q 2 {\\displaystyle q_{2}} and r 2 < r 1 {\\displaystyle r_{2}<r_{1}} such that: 147 = q 2 ⋅ 21 + r 2 {\\displaystyle 147=q_{2}\\cdot 21+r_{2}} .",
    "source_url": "https://en.wikipedia.org/wiki/Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:33.651898",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:33.651898",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:33.651898",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Euclidean_algorithm_1_1749014253724_4175",
    "text": "r N −2 = q N r N −1 since the final remainder r N is zero. r N −1 also divides its next predecessor r N −3 r N −3 = q N −1 r N −2 + r N −1 because it divides both terms on the right-hand side of the equation. Iterating the same argument, r N −1 divides all the preceding remainders, including a and b . None of the preceding remainders r N −2 , r N −3 , etc. divide a and b , since they leave a remainder. Since r N −1 is a common divisor of a and b , r N −1 ≤ g . In the second step, any natural number c that divides both a and b (in other words, any common divisor of a and b ) divides the remainders r k . By definition, a and b can be written as multiples of c : a = mc and b = nc , where m and n are natural numbers. Therefore, c divides the initial remainder r 0 , since r 0 = a − q 0 b = mc − q 0 nc = ( m − q 0 n ) c . An analogous argument shows that c also divides the subsequent remainders r 1 , r 2 , etc.",
    "source_url": "https://en.wikipedia.org/wiki/Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:33.724672",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:33.724672",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:33.724672",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Euclidean_algorithm&oldid=1288126959_1_1749014256683_8629",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Citation bot ( talk | contribs ) at 16:35, 30 April 2025 (Add: location, issue. | Use this bot . Report bugs . | Suggested by Dominic3203 | Linked from User:Mathbot/Most_linked_math_articles | #UCB_webform_linked 659/1913) . The present address (URL) is a permanent link to this version. Revision as of 16:35, 30 April 2025 by Citation bot ( talk | contribs ) (Add: location, issue. | Use t",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Euclidean_algorithm&oldid=1288126959",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:36.683669",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:36.683669",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:36.683669",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Euclid%27s_algorithm_1_1749014260038_2977",
    "text": "A 24×60 rectangle is covered with ten 12×12 square tiles, where 12 is the GCD of 24 and 60. More generally, an a × b rectangle can be covered with square tiles of side-length c only if c is a common divisor of a and b . Let g = gcd( a , b ) . Since a and b are both multiples of g , they can be written a = mg and b = ng , and there is no larger number G > g for which this is true. The natural numbers m and n must be coprime, since any common factor could be factored out of m and n to make g greater. Thus, any other number c that divides both a and b must also divide g . The greatest common divisor g of a and b is the unique (positive) common divisor of a and b that is divisible by any other common divisor c . [ 6 ] The greatest common divisor can be visualized as follows. [ 7 ] Consider a rectangular area a by b , and any common divisor c that divides both a and b exactly.",
    "source_url": "https://en.wikipedia.org/wiki/Euclid%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:40.038586",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:40.039589",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:40.039589",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Euclid%27s_algorithm_1_1749014260214_3143",
    "text": "This determines r 0 = 147 {\\displaystyle r_{0}=147} and so the sequence is now { 1071 , 462 , r 0 = 147 } {\\displaystyle \\{1071,\\ 462,\\ r_{0}=147\\}} . The next step is to continue the sequence to find r 1 {\\displaystyle r_{1}} by finding integers q 1 {\\displaystyle q_{1}} and r 1 < r 0 {\\displaystyle r_{1}<r_{0}} such that: 462 = q 1 ⋅ 147 + r 1 {\\displaystyle 462=q_{1}\\cdot 147+r_{1}} . This is the quotient q 1 = 3 {\\displaystyle q_{1}=3} since 462 = 3 ⋅ 147 + 21 {\\displaystyle 462=3\\cdot 147+21} . This determines r 1 = 21 {\\displaystyle r_{1}=21} and so the sequence is now { 1071 , 462 , 147 , r 1 = 21 } {\\displaystyle \\{1071,\\ 462,\\ 147,\\ r_{1}=21\\}} . The next step is to continue the sequence to find r 2 {\\displaystyle r_{2}} by finding integers q 2 {\\displaystyle q_{2}} and r 2 < r 1 {\\displaystyle r_{2}<r_{1}} such that: 147 = q 2 ⋅ 21 + r 2 {\\displaystyle 147=q_{2}\\cdot 21+r_{2}} .",
    "source_url": "https://en.wikipedia.org/wiki/Euclid%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:40.214201",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:40.215194",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:40.215194",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Euclid%27s_algorithm_1_1749014260285_9794",
    "text": "r N −2 = q N r N −1 since the final remainder r N is zero. r N −1 also divides its next predecessor r N −3 r N −3 = q N −1 r N −2 + r N −1 because it divides both terms on the right-hand side of the equation. Iterating the same argument, r N −1 divides all the preceding remainders, including a and b . None of the preceding remainders r N −2 , r N −3 , etc. divide a and b , since they leave a remainder. Since r N −1 is a common divisor of a and b , r N −1 ≤ g . In the second step, any natural number c that divides both a and b (in other words, any common divisor of a and b ) divides the remainders r k . By definition, a and b can be written as multiples of c : a = mc and b = nc , where m and n are natural numbers. Therefore, c divides the initial remainder r 0 , since r 0 = a − q 0 b = mc − q 0 nc = ( m − q 0 n ) c . An analogous argument shows that c also divides the subsequent remainders r 1 , r 2 , etc.",
    "source_url": "https://en.wikipedia.org/wiki/Euclid%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:40.285234",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:40.285234",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:40.285234",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Extended_Euclidean_algorithm_1_1749014264650_2475",
    "text": "As a = r 0 {\\displaystyle a=r_{0}} and b = r 1 , {\\displaystyle b=r_{1},} we have a s i + b t i = r i {\\displaystyle as_{i}+bt_{i}=r_{i}} for i = 0 and 1. The relation follows by induction for all i > 1 {\\displaystyle i>1} : r i + 1 = r i − 1 − r i q i = ( a s i − 1 + b t i − 1 ) − ( a s i + b t i ) q i = ( a s i − 1 − a s i q i ) + ( b t i − 1 − b t i q i ) = a s i + 1 + b t i + 1 . { \\displaystyle r_{i+1}=r_{i-1}-r_{i}q_{i}=(as_{i-1}+bt_{i-1})-(as_{i}+bt_{i})q_{i}=(as_{i-1}-as_{i}q_{i})+(bt_{i-1}-bt_{i}q_{i})=as_{i+1}+bt_{i+1}.} Thus s k {\\displaystyle s_{k}} and t k {\\displaystyle t_{k}} are Bézout coefficients. Consider the matrix A i = ( s i − 1 s i t i − 1 t i ) . {\\displaystyle A_{i}={\\begin{pmatrix}s_{i-1}&s_{i}\\\\t_{i-1}&t_{i}\\end{pmatrix}}.} The recurrence relation may be rewritten in matrix form A i + 1 = A i ⋅ ( 0 1 1 − q i ) . {\\displaystyle A_{i+1}=A_{i}\\cdot {\\begin{pmatrix}0&1\\\\1&-q_{i}\\end{pmatrix}}.}",
    "source_url": "https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:44.650531",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:44.650531",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:44.650531",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Extended_Euclidean_algorithm_1_1749014264680_6710",
    "text": "{\\displaystyle A_{i+1}=A_{i}\\cdot {\\begin{pmatrix}0&1\\\\1&-q_{i}\\end{pmatrix}}.} The matrix A 1 {\\displaystyle A_{1}} is the identity matrix and its determinant is one. The determinant of the rightmost matrix in the preceding formula is −1. It follows that the determinant of A i {\\displaystyle A_{i}} is ( − 1 ) i − 1 . {\\displaystyle (-1)^{i-1}.} In particular, for i = k + 1 , {\\displaystyle i=k+1,} we have s k t k + 1 − t k s k + 1 = ( − 1 ) k . {\\displaystyle s_{k}t_{k+1}-t_{k}s_{k+1}=(-1)^{k}.} Viewing this as a Bézout's identity, this shows that s k + 1 {\\displaystyle s_{k+1}} and t k + 1 {\\displaystyle t_{k+1}} are coprime . The relation a s k + 1 + b t k + 1 = 0 {\\displaystyle as_{k+1}+bt_{k+1}=0} that has been proved above and Euclid's lemma show that s k + 1 {\\displaystyle s_{k+1}} divides b , that is that b = d s k + 1 {\\displaystyle b=ds_{k+1}} for some integer d .",
    "source_url": "https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:44.680533",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:44.681526",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:44.681526",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Extended_Euclidean_algorithm_1_1749014264973_3452",
    "text": "Dividing by s k + 1 {\\displaystyle s_{k+1}} the relation a s k + 1 + b t k + 1 = 0 {\\displaystyle as_{k+1}+bt_{k+1}=0} gives a = − d t k + 1 . {\\displaystyle a=-dt_{k+1}.} So, s k + 1 {\\displaystyle s_{k+1}} and − t k + 1 {\\displaystyle -t_{k+1}} are coprime integers that are the quotients of a and b by a common factor, which is thus their greatest common divisor or its opposite . To prove the last assertion, assume that a and b are both positive and gcd ( a , b ) ≠ min ( a , b ) {\\displaystyle \\gcd(a,b)\\neq \\min(a,b)} . Then, a ≠ b {\\displaystyle a\\neq b} , and  if a < b {\\displaystyle a<b} , it can be seen that the s and t sequences for ( a , b ) under the EEA are, up to initial 0s and 1s, the t and s sequences for ( b , a ). The definitions then show that the ( a , b ) case reduces to the ( b , a ) case. So assume that a > b {\\displaystyle a>b} without loss of generality .",
    "source_url": "https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:44.973956",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:44.973956",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:44.973956",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Extended_Euclidean_algorithm&oldid=1285730579_1_1749014266486_6226",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by D.Lazard ( talk | contribs ) at 12:32, 15 April 2025 ( → Simplification of fractions : fixing minus) . The present address (URL) is a permanent link to this version. Revision as of 12:32, 15 April 2025 by D.Lazard ( talk | contribs ) ( → Simplification of fractions : fixing minus) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Method for computing the rel",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Extended_Euclidean_algorithm&oldid=1285730579",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:46.486321",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:46.486321",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:46.487320",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_External_memory_algorithm_1_1749014267704_7739",
    "text": "[ 4 ] External sorting is sorting in an external memory setting. External sorting can be done via distribution sort, which is similar to quicksort , or via a M B {\\displaystyle {\\tfrac {M}{B}}} -way merge sort . Both variants achieve the asymptotically optimal runtime of O ( N B log M B ⁡ N B ) {\\displaystyle O\\left({\\frac {N}{B}}\\log _{\\frac {M}{B}}{\\frac {N}{B}}\\right)} to sort N objects. This bound also applies to the fast Fourier transform in the external memory model. [ 2 ] The permutation problem is to rearrange N elements into a specific permutation . This can either be done either by sorting, which requires the above sorting runtime, or inserting each element in order and ignoring the benefit of locality. Thus, permutation can be done in O ( min ( N , N B log M B ⁡ N B ) ) {\\displaystyle O\\left(\\min \\left(N,{\\frac {N}{B}}\\log _{\\frac {M}{B}}{\\frac {N}{B}}\\right)\\right)} time. Applications [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/External_memory_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:47.704598",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:47.704598",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:47.704598",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Integer_relation_algorithm&oldid=1285523551_1_1749014272572_4019",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Altenmann ( talk | contribs ) at 06:13, 14 April 2025 (Reverted 1 edit by Harajaru345tyu ( talk ): Rv stupid ai spellchecker) . The present address (URL) is a permanent link to this version. Revision as of 06:13, 14 April 2025 by Altenmann ( talk | contribs ) (Reverted 1 edit by Harajaru345tyu ( talk ): Rv stupid ai spellchecker) ( diff ) ← Previous revision | Latest revision (diff) | Ne",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Integer_relation_algorithm&oldid=1285523551",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:52.572530",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:52.573523",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:52.573523",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Floyd%E2%80%93Warshall_algorithm_1_1749014274382_1426",
    "text": "It does so by incrementally improving an estimate on the shortest path between two vertices, until the estimate is optimal. Consider a graph G {\\displaystyle G} with vertices V {\\displaystyle V} numbered 1 through N {\\displaystyle N} . Further consider a function s h o r t e s t P a t h ( i , j , k ) {\\displaystyle \\mathrm {shortestPath} (i,j,k)} that returns the length of the shortest possible path (if one exists) from i {\\displaystyle i} to j {\\displaystyle j} using vertices only from the set { 1 , 2 , … , k } {\\displaystyle \\{1,2,\\ldots ,k\\}} as intermediate points along the way. Now, given this function, our goal is to find the length of the shortest path from each i {\\displaystyle i} to each j {\\displaystyle j} using any vertex in { 1 , 2 , … , N } {\\displaystyle \\{1,2,\\ldots ,N\\}} . By definition, this is the value s h o r t e s t P a t h ( i , j , N ) {\\displaystyle \\mathrm {shortestPath} (i,j,N)} , which we will find recursively .",
    "source_url": "https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:54.382082",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:54.382082",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:54.382082",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Floyd%E2%80%93Warshall_algorithm_1_1749014274415_5346",
    "text": "{\\displaystyle \\mathrm {shortestPath} (i,j,N)} , which we will find recursively . Observe that s h o r t e s t P a t h ( i , j , k ) {\\displaystyle \\mathrm {shortestPath} (i,j,k)} must be less than or equal to s h o r t e s t P a t h ( i , j , k − 1 ) {\\displaystyle \\mathrm {shortestPath} (i,j,k-1)} : we have more flexibility if we are allowed to use the vertex k {\\displaystyle k} . If s h o r t e s t P a t h ( i , j , k ) {\\displaystyle \\mathrm {shortestPath} (i,j,k)} is in fact less than s h o r t e s t P a t h ( i , j , k − 1 ) {\\displaystyle \\mathrm {shortestPath} (i,j,k-1)} , then there must be a path from i {\\displaystyle i} to j {\\displaystyle j} using the vertices { 1 , 2 , … , k } {\\displaystyle \\{1,2,\\ldots ,k\\}} that is shorter than any such path that does not use the vertex k {\\displaystyle k} .",
    "source_url": "https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:54.415257",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:54.415257",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:54.415257",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Floyd%E2%80%93Warshall_algorithm_1_1749014274457_5754",
    "text": "Since there are no negative cycles this path can be decomposed as: (1) a path from i {\\displaystyle i} to k {\\displaystyle k} that uses the vertices { 1 , 2 , … , k − 1 } {\\displaystyle \\{1,2,\\ldots ,k-1\\}} , followed by (2) a path from k {\\displaystyle k} to j {\\displaystyle j} that uses the vertices { 1 , 2 , … , k − 1 } {\\displaystyle \\{1,2,\\ldots ,k-1\\}} . And of course, these must be a shortest such path (or several of them), otherwise we could further decrease the length. In other words, we have arrived at the recursive formula: s h o r t e s t P a t h ( i , j , k ) = {\\displaystyle \\mathrm {shortestPath} (i,j,k)=} m i n ( s h o r t e s t P a t h ( i , j , k − 1 ) , {\\displaystyle \\mathrm {min} {\\Big (}\\mathrm {shortestPath} (i,j,k-1),} s h o r t e s t P a t h ( i , k , k − 1 ) + s h o r t e s t P a t h ( k , j , k − 1 ) ) {\\displaystyle \\mathrm {shortestPath} (i,k,k-1)+\\mathrm {shortestPath} (k,j,k-1){\\Big )}} . The base case is given by s h o r t e s t P a t h ( i , j , 0 )",
    "source_url": "https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:54.457395",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:54.457395",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:54.457395",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Floyd%E2%80%93Warshall_algorithm_1_1749014274603_7622",
    "text": "At k = 2 , paths going through the vertices {1,2} are found. The red and blue boxes show how the path [4,2,1,3] is assembled from the two known paths [4,2] and [2,1,3] encountered in previous iterations, with 2 in the intersection. The path [4,2,3] is not considered, because [2,1,3] is the shortest path encountered so far from 2 to 3. At k = 3 , paths going through the vertices {1,2,3} are found. Finally, at k = 4 , all shortest paths are found. The distance matrix at each iteration of k , with the updated distances in bold , will be: k = 0 j 1 2 3 4 i 1 0 ∞ −2 ∞ 2 4 0 3 ∞ 3 ∞ ∞ 0 2 4 ∞ −1 ∞ 0 k = 1 j 1 2 3 4 i 1 0 ∞ −2 ∞ 2 4 0 2 ∞ 3 ∞ ∞ 0 2 4 ∞ −1 ∞ 0 k = 2 j 1 2 3 4 i 1 0 ∞ −2 ∞ 2 4 0 2 ∞ 3 ∞ ∞ 0 2 4 3 −1 1 0 k = 3 j 1 2 3 4 i 1 0 ∞ −2 0 2 4 0 2 4 3 ∞ ∞ 0 2 4 3 −1 1 0 k = 4 j 1 2 3 4 i 1 0 −1 −2 0 2 4 0 2 4 3 5 1 0 2 4 3 −1 1 0 Behavior with negative cycles [ edit ] A negative cycle is a cycle whose edges sum to a negative value.",
    "source_url": "https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:54.603926",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:54.603926",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:54.603926",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ford%E2%80%93Fulkerson_algorithm_1_1749014278070_2503",
    "text": "When no more paths in step 2 can be found, s will not be able to reach t in the residual\nnetwork. If S is the set of nodes reachable by s in the residual network, then the total\ncapacity in the original network of edges from S to the remainder of V is on the one hand\nequal to the total flow we found from s to t ,\nand on the other hand serves as an upper bound for all such flows. This proves that the flow we found is maximal. See also Max-flow Min-cut theorem . If the graph G ( V , E ) {\\displaystyle G(V,E)} has multiple sources and sinks, we act as follows:\nSuppose that T = { t ∣ t is a sink } {\\displaystyle T=\\{t\\mid t{\\text{ is a sink}}\\}} and S = { s ∣ s is a source } {\\displaystyle S=\\{s\\mid s{\\text{ is a source}}\\}} . Add a new source s ∗ {\\displaystyle s^{*}} with an edge ( s ∗ , s ) {\\displaystyle (s^{*},s)} from s ∗ {\\displaystyle s^{*}} to every node s ∈ S {\\displaystyle s\\in S} , with capacity c ( s ∗ , s )",
    "source_url": "https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:58.070694",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:58.070694",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:58.070694",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ford%E2%80%93Fulkerson_algorithm_1_1749014278236_2428",
    "text": "Flow is sent along the augmenting path A , B , C , D {\\displaystyle A,B,C,D} . Here, the bottleneck is the B {\\displaystyle B} – C {\\displaystyle C} edge, so only one unit of flow is possible. Here, one unit of flow is sent along the augmenting path A , C , B , D {\\displaystyle A,C,B,D} . In this case, flow is \"pushed back\" from C {\\displaystyle C} to B {\\displaystyle B} . The flow into C {\\displaystyle C} that originally came from B {\\displaystyle B} now comes from A {\\displaystyle A} , and B {\\displaystyle B} is now free to send flow to D {\\displaystyle D} directly. As a result, the B {\\displaystyle B} – C {\\displaystyle C} edge is left with zero flow, but the overall flow increases by one. 1998 intermediate steps are omitted here. The final flow network, with a total flow of 2000 units.",
    "source_url": "https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:58.236354",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:58.237541",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:58.237541",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ford%E2%80%93Fulkerson_algorithm_1_1749014278269_1428",
    "text": "1998 intermediate steps are omitted here. The final flow network, with a total flow of 2000 units. Non-terminating example [ edit ] Consider the flow network shown on the right, with source s {\\displaystyle s} , sink t {\\displaystyle t} , capacities of edges e 1 = 1 {\\displaystyle e_{1}=1} , e 2 = r = ( 5 − 1 ) / 2 {\\displaystyle e_{2}=r=({\\sqrt {5}}-1)/2} and e 3 = 1 {\\displaystyle e_{3}=1} , and the capacity of all other edges some integer M ≥ 2 {\\displaystyle M\\geq 2} . The constant r {\\displaystyle r} was chosen so, that r 2 = 1 − r {\\displaystyle r^{2}=1-r} . We use augmenting paths according to the following table, where p 1 = { s , v 4 , v 3 , v 2 , v 1 , t } {\\displaystyle p_{1}=\\{s,v_{4},v_{3},v_{2},v_{1},t\\}} , p 2 = { s , v 2 , v 3 , v 4 , t } {\\displaystyle p_{2}=\\{s,v_{2},v_{3},v_{4},t\\}} and p 3 = { s , v 1 , v 2 , v 3 , t } {\\displaystyle p_{3}=\\{s,v_{1},v_{2},v_{3},t\\}} .",
    "source_url": "https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:17:58.269548",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:17:58.269548",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:17:58.269548",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Fully_persistent_data_structure_1_1749014281155_4852",
    "text": "(It is assumed that each modification touches one pointer or similar field.) If the node's modification box is empty, then it is filled with the modification. Otherwise, the modification box is full. A copy of the node is made, but using only the latest values. The modification is performed directly on the new node, without using the modification box. (One of the new node's fields is overwritten and its modification box stays empty.) Finally, this change is cascaded to the node's parent, just like path copying. (This may involve filling the parent's modification box, or making a copy of the parent recursively. If the node has no parent—it's the root—it is added the new root to a sorted array of roots.)",
    "source_url": "https://en.wikipedia.org/wiki/Fully_persistent_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:01.155991",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:01.156990",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:01.156990",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Functional_data_structure_1_1749014284731_2817",
    "text": "[ clarification needed ] Example: queue [ edit ] Amortized queues [ 1 ] : 65 [ 1 ] : 73 are composed of two singly-linked lists: the front and the reversed rear. Elements are added to the rear list and are removed from the front list. Furthermore, whenever the front queue is empty, the rear queue is reversed and becomes the front, while the rear queue becomes empty. The amortized time complexity of each operation is constant. Each cell of the list is added, reversed and removed at most once. In order to avoid an inefficient operation where the rear list is reversed, real-time queues add the restriction that the rear list is only as long as the front list. To ensure that the front list stays longer than the rear list, the rear list is reversed and appended to the front list. Since this operation is inefficient, it is not performed immediately. Instead, it is spread out over the subsequent operations.",
    "source_url": "https://en.wikipedia.org/wiki/Functional_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:04.731749",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:04.731749",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:04.731749",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Hungarian_algorithm_1_1749014295354_1964",
    "text": "c ( i , j ) {\\displaystyle y(i)+y(j)\\leq c(i,j)} for each i ∈ S , j ∈ T {\\displaystyle i\\in S,j\\in T} . The value of potential y is the sum of the potential over all vertices: ∑ v ∈ S ∪ T y ( v ) {\\displaystyle \\sum _{v\\in S\\cup T}y(v)} . The cost of each perfect matching is at least the value of each potential: the total cost of the matching is the sum of costs of all edges it contains; the cost of each edge is at least the sum of potentials of its endpoints; since the matching is perfect, each vertex is an endpoint of exactly one edge; hence the total cost is at least the total potential. The Hungarian method finds a perfect matching and a potential such that the matching cost equals the potential value. This proves that both of them are optimal. In fact, the Hungarian method finds a perfect matching of tight edges : an edge i j {\\displaystyle ij} is called tight for a potential y if y ( i ) + y ( j ) = c ( i , j ) {\\displaystyle y(i)+y(j)=c(i,j)} .",
    "source_url": "https://en.wikipedia.org/wiki/Hungarian_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:15.354690",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:15.354690",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:15.354690",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Hungarian_algorithm_1_1749014295423_1466",
    "text": "We maintain the invariant that all the edges of M are tight. We are done if M is a perfect matching. In a general step, let R S ⊆ S {\\displaystyle R_{S}\\subseteq S} and R T ⊆ T {\\displaystyle R_{T}\\subseteq T} be the vertices not covered by M (so R S {\\displaystyle R_{S}} consists of the vertices in S with no incoming edge and R T {\\displaystyle R_{T}} consists of the vertices in T with no outgoing edge). Let Z be the set of vertices reachable in G y → {\\displaystyle {\\overrightarrow {G_{y}}}} from R S {\\displaystyle R_{S}} by a directed path. This can be computed by breadth-first search . If R T ∩ Z {\\displaystyle R_{T}\\cap Z} is nonempty, then reverse the orientation of all edges along a directed path in G y → {\\displaystyle {\\overrightarrow {G_{y}}}} from R S {\\displaystyle R_{S}} to R T {\\displaystyle R_{T}} . Thus the size of the corresponding matching increases by 1. If R T ∩ Z {\\displaystyle R_{T}\\cap Z} is empty, then let Δ := min { c ( i , j )",
    "source_url": "https://en.wikipedia.org/wiki/Hungarian_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:15.423865",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:15.423865",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:15.423865",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Hungarian_algorithm_1_1749014295455_3587",
    "text": "If R T ∩ Z {\\displaystyle R_{T}\\cap Z} is empty, then let Δ := min { c ( i , j ) − y ( i ) − y ( j ) : i ∈ Z ∩ S , j ∈ T ∖ Z } . {\\displaystyle \\Delta :=\\min\\{c(i,j)-y(i)-y(j):i\\in Z\\cap S,j\\in T\\setminus Z\\}.} Δ is well defined because at least one such edge i j {\\displaystyle ij} must exist whenever the matching is not yet of maximum possible size (see the following section); it is positive because there are no tight edges between Z ∩ S {\\displaystyle Z\\cap S} and T ∖ Z {\\displaystyle T\\setminus Z} . Increase y by Δ on the vertices of Z ∩ S {\\displaystyle Z\\cap S} and decrease y by Δ on the vertices of Z ∩ T {\\displaystyle Z\\cap T} . The resulting y is still a potential, and although the graph G y {\\displaystyle G_{y}} changes, it still contains M (see the next subsections). We orient the new edges from S to T . By the definition of Δ the set Z of vertices reachable from R S {\\displaystyle R_{S}} increases (note that the number of tight edges does not necessarily increase).",
    "source_url": "https://en.wikipedia.org/wiki/Hungarian_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:15.455873",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:15.456866",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:15.456866",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Hungarian_algorithm_1_1749014295532_8616",
    "text": "G y {\\displaystyle G_{y}} contains an augmenting path. G contains a loose-tailed path : a path from some vertex in R S {\\displaystyle R_{S}} to a vertex in T ∖ Z {\\displaystyle T\\setminus Z} that consists of any number (possibly zero) of tight edges followed by a single loose edge. The trailing loose edge of a loose-tailed path is thus from Z ∩ S {\\displaystyle Z\\cap S} , guaranteeing that Δ is well defined. If M is of maximum possible size, we are of course finished. Otherwise, by Berge's lemma , there must exist an augmenting path P with respect to M in the underlying graph G . However, this path may not exist in G y {\\displaystyle G_{y}} : Although every even-numbered edge in P is tight by the definition of M , odd-numbered edges may be loose and thus absent from G y {\\displaystyle G_{y}} . One endpoint of P is in R S {\\displaystyle R_{S}} , the other in R T {\\displaystyle R_{T}} ; w.l.o.g., suppose it begins in R S {\\displaystyle R_{S}} .",
    "source_url": "https://en.wikipedia.org/wiki/Hungarian_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:15.532076",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:15.532076",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:15.532076",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Hungarian_algorithm_1_1749014295558_9821",
    "text": "If every edge on P is tight, then it remains an augmenting path in G y {\\displaystyle G_{y}} and we are done. Otherwise, let u v {\\displaystyle uv} be the first loose edge on P . If v ∉ Z {\\displaystyle v\\notin Z} then we have found a loose-tailed path and we are done. Otherwise, v is reachable from some other path Q of tight edges from a vertex in R S {\\displaystyle R_{S}} . Let P v {\\displaystyle P_{v}} be the subpath of P beginning at v and continuing to the end, and let P ′ {\\displaystyle P'} be the path formed by traveling along Q until a vertex on P v {\\displaystyle P_{v}} is reached, and then continuing to the end of P v {\\displaystyle P_{v}} . Observe that P ′ {\\displaystyle P'} is an augmenting path in G with at least one fewer loose edge than P .",
    "source_url": "https://en.wikipedia.org/wiki/Hungarian_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:15.558980",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:15.558980",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:15.558980",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Hybrid_algorithm&oldid=1137295461_1_1749014299806_7446",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by CoolTomato33 ( talk | contribs ) at 22:03, 3 February 2023 (Improved leading sentence and irrelevant statement about C++) . The present address (URL) is a permanent link to this version. Revision as of 22:03, 3 February 2023 by CoolTomato33 ( talk | contribs ) (Improved leading sentence and irrelevant statement about C++) ( diff ) ← Previous revision | Latest revision (diff) | Newer revi",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Hybrid_algorithm&oldid=1137295461",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:19.806825",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:19.806825",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:19.806825",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Johnson%27s_algorithm_1_1749014307419_7542",
    "text": "Correctness [ edit ] In the reweighted graph, all paths between a pair s and t of nodes have the same quantity h ( s ) − h ( t ) added to them. The previous statement can be proven as follows: Let p be an ⁠ s − t {\\displaystyle s-t} ⁠ path. Its weight W in the reweighted graph is given by the following expression: ( w ( s , p 1 ) + h ( s ) − h ( p 1 ) ) + ( w ( p 1 , p 2 ) + h ( p 1 ) − h ( p 2 ) ) + . . . + ( w ( p n , t ) + h ( p n ) − h ( t ) ) . {\\displaystyle \\left(w(s,p_{1})+h(s)-h(p_{1})\\right)+\\left(w(p_{1},p_{2})+h(p_{1})-h(p_{2})\\right)+...+\\left(w(p_{n},t)+h(p_{n})-h(t)\\right).} Every + h ( p i ) {\\displaystyle +h(p_{i})} is cancelled by − h ( p i ) {\\displaystyle -h(p_{i})} in the previous bracketed expression; therefore, we are left with the following expression for W : ( w ( s , p 1 ) + w ( p 1 , p 2 ) + ⋯ + w ( p n , t ) ) + h ( s ) − h ( t ) {\\displaystyle \\left(w(s,p_{1})+w(p_{1},p_{2})+\\cdots +w(p_{n},t)\\right)+h(s)-h(t)}",
    "source_url": "https://en.wikipedia.org/wiki/Johnson%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:27.419897",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:27.420899",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:27.420899",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Johnson%27s_algorithm&oldid=1258202975_1_1749014308385_9743",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by BD2412 ( talk | contribs ) at 18:17, 18 November 2024 (Clean up spacing around commas and other punctuation fixes, replaced: ,v → , v (2),  ,  → ,) . The present address (URL) is a permanent link to this version. Revision as of 18:17, 18 November 2024 by BD2412 ( talk | contribs ) (Clean up spacing around commas and other punctuation fixes, replaced: ,v → , v (2),  ,  → ,) ( diff ) ← Pre",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Johnson%27s_algorithm&oldid=1258202975",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:28.385444",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:28.385444",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:28.385444",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm_1_1749014309767_8320",
    "text": "Within each block, the positions in which n {\\displaystyle n} is placed occur either in descending or ascending order, and the blocks alternate between these two orders: the placements of n {\\displaystyle n} in the first block are in descending order, in the second block they are in ascending order, in the third block they are in descending order, and so on. [ 2 ] Thus, from the single permutation on one element, 1 one may place the number 2 in each possible position in descending order to form a list of two permutations on two elements, 1 2 2 1 Then, one may place the number 3 in each of three different positions for these two permutations, in descending order for the first permutation 1 2, and then in ascending order for the permutation 2 1: 1 2 3 1 3 2 3 1 2 3 2 1 2 3 1 2 1 3 The same placement pattern, alternating between descending and ascending placements of n {\\displaystyle n} , applies for any larger value of n {\\displaystyle n} .",
    "source_url": "https://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:29.767500",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:29.767500",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:29.767500",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Karmarkar%27s_algorithm_1_1749014313005_4133",
    "text": "[ 14 ] Input:  A, b, c, x 0 {\\displaystyle x^{0}} , stopping criterion , γ . k ← 0 {\\displaystyle k\\leftarrow 0} do while stopping criterion not satisfied v k ← b − A x k {\\displaystyle v^{k}\\leftarrow b-Ax^{k}} D v ← diag ⁡ ( v 1 k , … , v m k ) {\\displaystyle D_{v}\\leftarrow \\operatorname {diag} (v_{1}^{k},\\ldots ,v_{m}^{k})} h x ← ( A T D v − 2 A ) − 1 c {\\displaystyle h_{x}\\leftarrow (A^{T}D_{v}^{-2}A)^{-1}c} h v ← − A h x {\\displaystyle h_{v}\\leftarrow -Ah_{x}} if h v ≥ 0 {\\displaystyle h_{v}\\geq 0} then return unbounded end if α ← γ ⋅ min { − v i k / ( h v ) i | ( h v ) i < 0 , i = 1 , … , m } {\\displaystyle \\alpha \\leftarrow \\gamma \\cdot \\min\\{-v_{i}^{k}/(h_{v})_{i}\\,\\,|\\,\\,(h_{v})_{i}<0,\\,i=1,\\ldots ,m\\}} x k + 1 ← x k + α h x {\\displaystyle x^{k+1}\\leftarrow x^{k}+\\alpha h_{x}} k ← k + 1 {\\displaystyle k\\leftarrow k+1} end do \"←\" denotes assignment . For instance, \" largest ← item \" means that the value of largest changes to the value of item . \"",
    "source_url": "https://en.wikipedia.org/wiki/Karmarkar%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:33.005103",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:33.005103",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:33.005103",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Karmarkar%27s_algorithm&oldid=1289852059_1_1749014314241_9591",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by David Eppstein ( talk | contribs ) at 06:57, 11 May 2025 ( → Patent controversy : any senate debate appears to have occurred long after the patent was granted) . The present address (URL) is a permanent link to this version. Revision as of 06:57, 11 May 2025 by David Eppstein ( talk | contribs ) ( → Patent controversy : any senate debate appears to have occurred long after the patent was",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Karmarkar%27s_algorithm&oldid=1289852059",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:34.241064",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:34.242067",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:34.242067",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Knuth–Morris–Pratt_algorithm&oldid=1246760417_1_1749014321548_2812",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by 177.9.76.226 ( talk ) at 22:30, 20 September 2024 (Changed the Big O notation to Theta notation because it is talking about the expected/average performance, not the worst case (which is discussed below).) . The present address (URL) is a permanent link to this version. Revision as of 22:30, 20 September 2024 by 177.9.76.226 ( talk ) (Changed the Big O notation to Theta notation because ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Knuth–Morris–Pratt_algorithm&oldid=1246760417",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:41.548558",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:41.548558",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:41.548558",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Kruskal%27s_algorithm_1_1749014322700_4687",
    "text": "Example [ edit ] Image Description AD and CE are the shortest edges, with length 5, and AD has been arbitrarily chosen, so it is highlighted. CE is now the shortest edge that does not form a cycle, with length 5, so it is highlighted as the second edge. The next edge, DF with length 6, is highlighted using much the same method. The next-shortest edges are AB and BE , both with length 7. AB is chosen arbitrarily, and is highlighted. The edge BD has been highlighted in red, because there already exists a path (in green) between B and D , so it would form a cycle ( ABD ) if it were chosen. The process continues to highlight the next-smallest edge, BE with length 7. Many more edges are highlighted in red at this stage: BC because it would form the loop BCE , DE because it would form the loop DEBA , and FE because it would form FEBAD . Finally, the process finishes with the edge EG of length 9, and the minimum spanning tree is found.",
    "source_url": "https://en.wikipedia.org/wiki/Kruskal%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:42.700518",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:42.700518",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:42.700518",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimum_spanning_tree_1_1749014323542_6861",
    "text": "Jump to content From Wikipedia, the free encyclopedia Least-weight tree connecting graph vertices A planar graph and its minimum spanning tree. Each edge is labeled with its weight, which here is roughly proportional to its length. A minimum spanning tree ( MST ) or minimum weight spanning tree is a subset of the edges of a connected , edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. [ 1 ] That is, it is a",
    "source_url": "https://en.wikipedia.org/wiki/Minimum_spanning_tree",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:43.542835",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:43.542835",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:43.542835",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Las_Vegas_algorithm_1_1749014325987_8071",
    "text": "The time complexity thus ranges from getting \"lucky\" and finding the content immediately, to being \"unlucky\" and spending large amounts of time. Once the right website is found, then there is no possibility of error. [ 6 ] Randomized quicksort [ edit ] INPUT : # A is an array of n elements def randomized_quicksort ( A ): if n == 1 : return A # A is sorted. else : i = random . randrange ( 1 , n ) # Will take a random number in the range 1~n X = A [ i ] # The pivot element \"\"\"Partition A into elements < x, x, and >x  # as shown in the figure above. Execute Quicksort on A[1 to i-1] and A[i+1 to n]. Combine the responses in order to obtain a sorted array.\" \"\" A simple example is randomized quicksort , where the pivot is chosen randomly, and divides the elements into three partitions: elements less than pivot, elements equal to pivot, and elements greater than pivot. QuickSort always generates the solution, which in this case the sorted array.",
    "source_url": "https://en.wikipedia.org/wiki/Las_Vegas_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:45.987941",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:45.987941",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:45.987941",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Las_Vegas_algorithm_1_1749014326297_3079",
    "text": "QuickSort always generates the solution, which in this case the sorted array. Unfortunately, the time complexity is not that obvious. It turns out that the runtime depends on which element we pick as a pivot. The worst case Θ( n 2 ) when the pivot is the smallest or the largest element. T ( n ) = T ( 0 ) + T ( n − 1 ) + Θ ( n ) {\\displaystyle T(n)=T(0)+T(n-1)+\\Theta (n)} T ( n ) = Θ ( 1 ) + T ( n − 1 ) + Θ ( n ) {\\displaystyle T(n)=\\Theta (1)+T(n-1)+\\Theta (n)} T ( n ) = T ( n − 1 ) + Θ ( n ) {\\displaystyle T(n)=T(n-1)+\\Theta (n)} T ( n ) = Θ ( n 2 ) {\\displaystyle T(n)=\\Theta (n^{2})} However, through randomization, where the pivot is randomly picked and is exactly a middle value each time, the QuickSort can be done in Θ( n log n ). T ( n ) ≤ 2 ∗ T ( n / 2 ) + Θ ( n ) {\\displaystyle T(n)\\leq 2*T(n/2)+\\Theta (n)} T ( n ) = Θ ( n log ⁡ ( n ) ) {\\displaystyle T(n)=\\Theta (n\\log(n))} The runtime of quicksort depends heavily on how well the pivot is selected.",
    "source_url": "https://en.wikipedia.org/wiki/Las_Vegas_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:46.297847",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:46.297847",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:46.297847",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Atlantic_City_algorithm_1_1749014327073_9944",
    "text": "Jump to content From Wikipedia, the free encyclopedia You can help expand this article with text translated from the corresponding article in French . (June 2022) Click [show] for important translation instructions. View a machine-translated version of the French article. Machine translation, like DeepL or Google Translate , is a useful starting point for translations, but translators must revise errors as necessary and confirm that the translation is accurate, rather than simply copy-pasting ma",
    "source_url": "https://en.wikipedia.org/wiki/Atlantic_City_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:47.073566",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:47.073566",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:47.073566",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749014328893_6795",
    "text": "= a T ( n b ) + f ( n ) {\\displaystyle T(n)=a\\;T\\!\\left({\\frac {n}{b}}\\right)+f(n)} Here n {\\displaystyle n} is the size of an input problem, a {\\displaystyle a} is the number of subproblems in the recursion, and b {\\displaystyle b} is the factor by which the subproblem size is reduced in each recursive call ( b > 1 {\\displaystyle b>1} ). Crucially, a {\\displaystyle a} and b {\\displaystyle b} must not depend on n {\\displaystyle n} . The theorem below also assumes that, as a base case for the recurrence, T ( n ) = Θ ( 1 ) {\\displaystyle T(n)=\\Theta (1)} when n {\\displaystyle n} is less than some bound κ > 0 {\\displaystyle \\kappa >0} , the smallest input size that will lead to a recursive call. Recurrences of this form often satisfy one of the three following regimes, based on how the work to split/recombine the problem f ( n ) {\\displaystyle f(n)} relates to the critical exponent c crit = log b ⁡ a {\\displaystyle c_{\\operatorname {crit} }=\\log _{b}a} .",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:48.893840",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:48.893840",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:48.893840",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749014328922_7910",
    "text": "(The table below uses standard big O notation ). Throughout, ( log ⁡ n ) k {\\displaystyle (\\log n)^{k}} is used for clarity, though in textbooks this is usually rendered log k ⁡ n {\\displaystyle \\log ^{k}n} . c crit = log b ⁡ a = log ⁡ ( # subproblems ) / log ⁡ ( relative subproblem size ) {\\displaystyle c_{\\operatorname {crit} }=\\log _{b}a=\\log(\\#{\\text{subproblems}})/\\log({\\text{relative subproblem size}})} Case Description Condition on f ( n ) {\\displaystyle f(n)} in relation to c crit {\\displaystyle c_{\\operatorname {crit} }} , i.e. log b ⁡ a {\\displaystyle \\log _{b}a} Master Theorem bound Notational examples 1 Work to split/recombine a problem is dominated by subproblems. i.e. the recursion tree is leaf-heavy. When f ( n ) = O ( n c ) {\\displaystyle f(n)=O(n^{c})} where c < c crit {\\displaystyle c<c_{\\operatorname {crit} }} (upper-bounded by a lesser exponent polynomial) ...",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:48.922602",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:48.922602",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:48.922602",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749014328953_5644",
    "text": "then T ( n ) = Θ ( n c crit ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}\\right)} (The splitting term does not appear; the recursive tree structure dominates.) If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = O ( n 1 / 2 − ϵ ) {\\displaystyle f(n)=O(n^{1/2-\\epsilon })} , then T ( n ) = Θ ( n 1 / 2 ) {\\displaystyle T(n)=\\Theta (n^{1/2})} . 2 Work to split/recombine a problem is comparable to subproblems. When f ( n ) = Θ ( n c crit ( log ⁡ n ) k ) {\\displaystyle f(n)=\\Theta (n^{c_{\\operatorname {crit} }}(\\log n)^{k})} for a k ≥ 0 {\\displaystyle k\\geq 0} (rangebound by the critical-exponent polynomial, times zero or more optional log {\\displaystyle \\log } s) ... then T ( n ) = Θ ( n c crit ( log ⁡ n ) k + 1 ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}(\\log n)^{k+1}\\right)} (The bound is the splitting term, where the log is augmented by a single power.)",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:48.953604",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:48.954605",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:48.954605",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749014328982_7446",
    "text": "If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 ) {\\displaystyle f(n)=\\Theta (n^{1/2})} , then T ( n ) = Θ ( n 1 / 2 log ⁡ n ) {\\displaystyle T(n)=\\Theta (n^{1/2}\\log n)} . If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 log ⁡ n ) {\\displaystyle f(n)=\\Theta (n^{1/2}\\log n)} , then T ( n ) = Θ ( n 1 / 2 ( log ⁡ n ) 2 ) {\\displaystyle T(n)=\\Theta (n^{1/2}(\\log n)^{2})} . 3 Work to split/recombine a problem dominates subproblems. i.e. the recursion tree is root-heavy. When f ( n ) = Ω ( n c ) {\\displaystyle f(n)=\\Omega (n^{c})} where c > c crit {\\displaystyle c>c_{\\operatorname {crit} }} (lower-bounded by a greater-exponent polynomial) ... this doesn't necessarily yield anything.",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:48.982111",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:48.982111",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:48.982111",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749014329012_6174",
    "text": "this doesn't necessarily yield anything. Furthermore, if a f ( n b ) ≤ k f ( n ) {\\displaystyle af\\left({\\frac {n}{b}}\\right)\\leq kf(n)} for some constant k < 1 {\\displaystyle k<1} and all sufficiently large n {\\displaystyle n} (often called the regularity condition ) then the total is dominated by the splitting term f ( n ) {\\displaystyle f(n)} : T ( n ) = Θ ( f ( n ) ) {\\displaystyle T\\left(n\\right)=\\Theta \\left(f(n)\\right)} If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Ω ( n 1 / 2 + ϵ ) {\\displaystyle f(n)=\\Omega (n^{1/2+\\epsilon })} and the regularity condition holds, then T ( n ) = Θ ( f ( n ) ) {\\displaystyle T(n)=\\Theta (f(n))} . A useful extension of Case 2 handles all values of k {\\displaystyle k} : [ 3 ] Case Condition on f ( n ) {\\displaystyle f(n)} in relation to c crit {\\displaystyle c_{\\operatorname {crit} }} , i.e. log b ⁡ a {\\displaystyle \\log _{b}a} Master Theorem bound Notational examples 2a",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:49.012113",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:49.012113",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:49.012113",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749014329048_4892",
    "text": "When f ( n ) = Θ ( n c crit ( log ⁡ n ) k ) {\\displaystyle f(n)=\\Theta (n^{c_{\\operatorname {crit} }}(\\log n)^{k})} for any k > − 1 {\\displaystyle k>-1} ... then T ( n ) = Θ ( n c crit ( log ⁡ n ) k + 1 ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}(\\log n)^{k+1}\\right)} (The bound is the splitting term, where the log is augmented by a single power.) If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 / ( log ⁡ n ) 1 / 2 ) {\\displaystyle f(n)=\\Theta (n^{1/2}/(\\log n)^{1/2})} , then T ( n ) = Θ ( n 1 / 2 ( log ⁡ n ) 1 / 2 ) {\\displaystyle T(n)=\\Theta (n^{1/2}(\\log n)^{1/2})} . 2b When f ( n ) = Θ ( n c crit ( log ⁡ n ) k ) {\\displaystyle f(n)=\\Theta (n^{c_{\\operatorname {crit} }}(\\log n)^{k})} for k = − 1 {\\displaystyle k=-1} ... then T ( n ) = Θ ( n c crit log ⁡ log ⁡ n ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}\\log \\log n\\right)} (The bound is the splitting term, where the log reciprocal is replaced by an iterated log.)",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:49.048739",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:49.048739",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:49.048739",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Master_theorem_(analysis_of_algorithms)_1_1749014329083_8198",
    "text": "If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 / log ⁡ n ) {\\displaystyle f(n)=\\Theta (n^{1/2}/\\log n)} , then T ( n ) = Θ ( n 1 / 2 log ⁡ log ⁡ n ) {\\displaystyle T(n)=\\Theta (n^{1/2}\\log \\log n)} . 2c When f ( n ) = Θ ( n c crit ( log ⁡ n ) k ) {\\displaystyle f(n)=\\Theta (n^{c_{\\operatorname {crit} }}(\\log n)^{k})} for any k < − 1 {\\displaystyle k<-1} ... then T ( n ) = Θ ( n c crit ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}\\right)} (The bound is the splitting term, where the log disappears.) If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 / ( log ⁡ n ) 2 ) {\\displaystyle f(n)=\\Theta (n^{1/2}/(\\log n)^{2})} , then T ( n ) = Θ ( n 1 / 2 ) {\\displaystyle T(n)=\\Theta (n^{1/2})} . Examples [ edit ] Case 1 example [ edit ] T ( n ) = 8 T ( n 2 ) + 1000 n 2 {\\displaystyle T(n)=8T\\left({\\frac {n}{2}}\\right)+1000n^{2}} As one can see from the formula above:",
    "source_url": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:49.083266",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:49.083266",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:49.083266",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662_1_1749014329789_4183",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Zhermes ( talk | contribs ) at 18:28, 27 February 2025 ( → Introduction : clarify what variable 'b' is) . The present address (URL) is a permanent link to this version. Revision as of 18:28, 27 February 2025 by Zhermes ( talk | contribs ) ( → Introduction : clarify what variable 'b' is) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Tool for analyzing div",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:49.789427",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:49.790426",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:49.790426",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Merge_algorithm&oldid=1257337469_1_1749014334228_3643",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by CiaPan ( talk | contribs ) at 11:53, 14 November 2024 ( → Application : adjusting grammatical number of verbs to plural 'arrows') . The present address (URL) is a permanent link to this version. Revision as of 11:53, 14 November 2024 by CiaPan ( talk | contribs ) ( → Application : adjusting grammatical number of verbs to plural 'arrows') ( diff ) ← Previous revision | Latest revision (di",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Merge_algorithm&oldid=1257337469",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:54.228591",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:54.228591",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:54.229584",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Munkres%27_assignment_algorithm_1_1749014338476_6706",
    "text": "c ( i , j ) {\\displaystyle y(i)+y(j)\\leq c(i,j)} for each i ∈ S , j ∈ T {\\displaystyle i\\in S,j\\in T} . The value of potential y is the sum of the potential over all vertices: ∑ v ∈ S ∪ T y ( v ) {\\displaystyle \\sum _{v\\in S\\cup T}y(v)} . The cost of each perfect matching is at least the value of each potential: the total cost of the matching is the sum of costs of all edges it contains; the cost of each edge is at least the sum of potentials of its endpoints; since the matching is perfect, each vertex is an endpoint of exactly one edge; hence the total cost is at least the total potential. The Hungarian method finds a perfect matching and a potential such that the matching cost equals the potential value. This proves that both of them are optimal. In fact, the Hungarian method finds a perfect matching of tight edges : an edge i j {\\displaystyle ij} is called tight for a potential y if y ( i ) + y ( j ) = c ( i , j ) {\\displaystyle y(i)+y(j)=c(i,j)} .",
    "source_url": "https://en.wikipedia.org/wiki/Munkres%27_assignment_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:58.476300",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:58.476300",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:58.476300",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Munkres%27_assignment_algorithm_1_1749014338547_9865",
    "text": "We maintain the invariant that all the edges of M are tight. We are done if M is a perfect matching. In a general step, let R S ⊆ S {\\displaystyle R_{S}\\subseteq S} and R T ⊆ T {\\displaystyle R_{T}\\subseteq T} be the vertices not covered by M (so R S {\\displaystyle R_{S}} consists of the vertices in S with no incoming edge and R T {\\displaystyle R_{T}} consists of the vertices in T with no outgoing edge). Let Z be the set of vertices reachable in G y → {\\displaystyle {\\overrightarrow {G_{y}}}} from R S {\\displaystyle R_{S}} by a directed path. This can be computed by breadth-first search . If R T ∩ Z {\\displaystyle R_{T}\\cap Z} is nonempty, then reverse the orientation of all edges along a directed path in G y → {\\displaystyle {\\overrightarrow {G_{y}}}} from R S {\\displaystyle R_{S}} to R T {\\displaystyle R_{T}} . Thus the size of the corresponding matching increases by 1. If R T ∩ Z {\\displaystyle R_{T}\\cap Z} is empty, then let Δ := min { c ( i , j )",
    "source_url": "https://en.wikipedia.org/wiki/Munkres%27_assignment_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:58.547031",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:58.547031",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:58.547031",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Munkres%27_assignment_algorithm_1_1749014338580_3689",
    "text": "If R T ∩ Z {\\displaystyle R_{T}\\cap Z} is empty, then let Δ := min { c ( i , j ) − y ( i ) − y ( j ) : i ∈ Z ∩ S , j ∈ T ∖ Z } . {\\displaystyle \\Delta :=\\min\\{c(i,j)-y(i)-y(j):i\\in Z\\cap S,j\\in T\\setminus Z\\}.} Δ is well defined because at least one such edge i j {\\displaystyle ij} must exist whenever the matching is not yet of maximum possible size (see the following section); it is positive because there are no tight edges between Z ∩ S {\\displaystyle Z\\cap S} and T ∖ Z {\\displaystyle T\\setminus Z} . Increase y by Δ on the vertices of Z ∩ S {\\displaystyle Z\\cap S} and decrease y by Δ on the vertices of Z ∩ T {\\displaystyle Z\\cap T} . The resulting y is still a potential, and although the graph G y {\\displaystyle G_{y}} changes, it still contains M (see the next subsections). We orient the new edges from S to T . By the definition of Δ the set Z of vertices reachable from R S {\\displaystyle R_{S}} increases (note that the number of tight edges does not necessarily increase).",
    "source_url": "https://en.wikipedia.org/wiki/Munkres%27_assignment_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:58.580558",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:58.580558",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:58.580558",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Munkres%27_assignment_algorithm_1_1749014338656_6823",
    "text": "G y {\\displaystyle G_{y}} contains an augmenting path. G contains a loose-tailed path : a path from some vertex in R S {\\displaystyle R_{S}} to a vertex in T ∖ Z {\\displaystyle T\\setminus Z} that consists of any number (possibly zero) of tight edges followed by a single loose edge. The trailing loose edge of a loose-tailed path is thus from Z ∩ S {\\displaystyle Z\\cap S} , guaranteeing that Δ is well defined. If M is of maximum possible size, we are of course finished. Otherwise, by Berge's lemma , there must exist an augmenting path P with respect to M in the underlying graph G . However, this path may not exist in G y {\\displaystyle G_{y}} : Although every even-numbered edge in P is tight by the definition of M , odd-numbered edges may be loose and thus absent from G y {\\displaystyle G_{y}} . One endpoint of P is in R S {\\displaystyle R_{S}} , the other in R T {\\displaystyle R_{T}} ; w.l.o.g., suppose it begins in R S {\\displaystyle R_{S}} .",
    "source_url": "https://en.wikipedia.org/wiki/Munkres%27_assignment_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:58.656965",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:58.656965",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:58.656965",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Munkres%27_assignment_algorithm_1_1749014338684_1644",
    "text": "If every edge on P is tight, then it remains an augmenting path in G y {\\displaystyle G_{y}} and we are done. Otherwise, let u v {\\displaystyle uv} be the first loose edge on P . If v ∉ Z {\\displaystyle v\\notin Z} then we have found a loose-tailed path and we are done. Otherwise, v is reachable from some other path Q of tight edges from a vertex in R S {\\displaystyle R_{S}} . Let P v {\\displaystyle P_{v}} be the subpath of P beginning at v and continuing to the end, and let P ′ {\\displaystyle P'} be the path formed by traveling along Q until a vertex on P v {\\displaystyle P_{v}} is reached, and then continuing to the end of P v {\\displaystyle P_{v}} . Observe that P ′ {\\displaystyle P'} is an augmenting path in G with at least one fewer loose edge than P .",
    "source_url": "https://en.wikipedia.org/wiki/Munkres%27_assignment_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:18:58.684145",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:18:58.684145",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:18:58.684145",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Oracle_Turing_machine_1_1749014350575_5639",
    "text": "Alternative definitions [ edit ] There are many alternative definitions to the one presented above. Many of these are specialized for the case where the oracle solves a decision problem. In this case: Some definitions, instead of writing the answer to the oracle tape, have two special states YES and NO in addition to the ASK state. When the oracle is consulted, the next state is chosen to be YES if the contents of the oracle tape are in the oracle set, and chosen to the NO if the contents are not in the oracle set. [ 1 ] Some definitions eschew the separate oracle tape. When the oracle state is entered, a tape symbol is specified. The oracle is queried with the number of times that this tape symbol appears on the work tape. If that number is in the oracle set, the next state is the YES state; if it is not, the next state is the NO state. [ 2 ] Another alternative definition makes the oracle tape read-only, and eliminates the ASK and RESPONSE states entirely.",
    "source_url": "https://en.wikipedia.org/wiki/Oracle_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:10.575946",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:10.576945",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:10.576945",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Oracle_Turing_machine_1_1749014350756_3987",
    "text": "This creates a hierarchy of machines, each with a more powerful halting oracle and an even harder halting problem. This hierarchy of machines can be used to define the arithmetical hierarchy . [ 9 ] Applications to cryptography [ edit ] Main article: Random oracle In cryptography , oracles are used to make arguments for the security of cryptographic protocols where a hash function is used. A security reduction (proof of security) for the protocol is given in the case where, instead of a hash function, a random oracle answers each query randomly but consistently; the oracle is assumed to be available to all parties including the attacker, as the hash function is. Such a proof shows that unless the attacker solves the hard problem at the heart of the security reduction, they must make use of some interesting property of the hash function to break the protocol; they cannot treat the hash function as a black box (i.e., as a random oracle).",
    "source_url": "https://en.wikipedia.org/wiki/Oracle_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:10.756109",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:10.757101",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:10.757101",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Partially_persistent_data_structure_1_1749014353566_5007",
    "text": "(It is assumed that each modification touches one pointer or similar field.) If the node's modification box is empty, then it is filled with the modification. Otherwise, the modification box is full. A copy of the node is made, but using only the latest values. The modification is performed directly on the new node, without using the modification box. (One of the new node's fields is overwritten and its modification box stays empty.) Finally, this change is cascaded to the node's parent, just like path copying. (This may involve filling the parent's modification box, or making a copy of the parent recursively. If the node has no parent—it's the root—it is added the new root to a sorted array of roots.)",
    "source_url": "https://en.wikipedia.org/wiki/Partially_persistent_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:13.566495",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:13.566495",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:13.566495",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Passive_data_structure_1_1749014357076_3288",
    "text": "[ 8 ] Others would also include Plain old Java objects (POJOs), a class that has methods but only getters and setters, with no logic, and JavaBeans to fall under the PDS concept if they do not use event handling and do not implement added methods beyond getters and setters. [ citation needed ] However, POJOs and Java Beans have encapsulation , and so violate the fundamental definition of PDS. Records (introduced in Java 16, in 2021) are shallowly immutable carriers of data without encapsulation, and therefore they can also be considered PDS. In other languages [ edit ] In PHP , associative arrays and stdClass objects can be considered PDS. [ citation needed ] Other structured data representations such as XML or JSON can also be used as a PDS if no significant semantic restrictions are used. In Python , dataclass module provides dataclasses - often used as behaviourless containers for holding data, with options for data validation.",
    "source_url": "https://en.wikipedia.org/wiki/Passive_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:17.076194",
    "symbols_found_in_chunk": 2,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:17.076194",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:17.076194",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Persistent_data_structure_1_1749014359968_4261",
    "text": "(It is assumed that each modification touches one pointer or similar field.) If the node's modification box is empty, then it is filled with the modification. Otherwise, the modification box is full. A copy of the node is made, but using only the latest values. The modification is performed directly on the new node, without using the modification box. (One of the new node's fields is overwritten and its modification box stays empty.) Finally, this change is cascaded to the node's parent, just like path copying. (This may involve filling the parent's modification box, or making a copy of the parent recursively. If the node has no parent—it's the root—it is added the new root to a sorted array of roots.)",
    "source_url": "https://en.wikipedia.org/wiki/Persistent_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:19.968357",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:19.968357",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:19.968357",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Post%E2%80%93Turing_machine_1_1749014364935_6404",
    "text": "Jump to content From Wikipedia, the free encyclopedia Abstract calculator This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article contains instructions, advice, or how-to content . Please help rewrite the content so that it is more encyclopedic or move it to Wikiversity , Wikibooks , or Wikivoyage . ( August 2020 ) This article is written like a research paper or a scientific journal . Please help improve the article by rewriting it in an encyclopedic style and simplifying overly technical phrases . ( August 2020 ) ( Learn how and when to remove this message ) This article may need to be rewritten to comply with Wikipedia's quality standards . You can help . The talk page may contain suggestions. ( August 2020 ) This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources .",
    "source_url": "https://en.wikipedia.org/wiki/Post%E2%80%93Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:24.935765",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:24.935765",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:24.935765",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Post%E2%80%93Turing_machine_1_1749014365047_7811",
    "text": "[ 2 ] Post's model employs a \" symbol space\" consisting of a \"two-way infinite sequence of spaces or boxes\", each box capable of being in either of two possible conditions, namely \"marked\" (as by a single vertical stroke) and \"unmarked\" (empty). Initially, finitely -many of the boxes are marked, the rest being unmarked. A \"worker\" is then to move among the boxes, being in and operating in only one box at a time, according to a fixed finite \"set of directions\" ( instructions ), which are numbered in order (1,2,3,..., n ). Beginning at a box \"singled out as the starting point\", the worker is to follow the set of instructions one at a time, beginning with instruction 1. There are five different primitive operations that the worker can perform: (a) Marking the box it is in, if it is empty (b) Erasing the mark in the box it is in, if it is marked (c) Moving to the box on its right (d) Moving to the box on its left (e) Determining whether the box it is in, is or is not marked.",
    "source_url": "https://en.wikipedia.org/wiki/Post%E2%80%93Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:25.047524",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:25.047524",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:25.047524",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Post%E2%80%93Turing_machine_1_1749014365076_8839",
    "text": "Then, the i th \"direction\" (instruction) given to the worker is to be one of the following forms: Perform operation O i [ O i = (a), (b), (c) or (d)] and then follow direction j i Perform operation (e) and according as the answer is yes or no correspondingly follow direction j i ′ or j i ″ Stop . (The above indented text and italics are as in the original.) Post remarks that this formulation is \"in its initial stages\" of development, and mentions several possibilities for \"greater flexibility\" in its final \"definitive form\", including replacing the infinity of boxes by a finite extensible symbol space, \"extending the primitive operations to allow for the necessary extension of the given finite symbol space as the process proceeds\", using an alphabet of more than two symbols, \"having more than one way to mark a box\", introducing finitely-many \"physical objects to serve as pointers, which the worker can identify and move from box to box\". 1947:",
    "source_url": "https://en.wikipedia.org/wiki/Post%E2%80%93Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:25.076533",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:25.077525",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:25.077525",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Prim%27s_algorithm_1_1749014367053_4027",
    "text": "In more detail, it may be implemented following the pseudocode below. function Prim(vertices, edges) is for each vertex in vertices do cheapestCost[vertex] ← ∞\n        cheapestEdge[vertex] ← null\n\n    explored ← empty set\n    unexplored ← set containing all vertices\n\n    startVertex ← any element of vertices\n    cheapestCost[startVertex] ← 0 while unexplored is not empty do // Select vertex in unexplored with minimum cost\n        currentVertex ← vertex in unexplored with minimum cheapestCost[vertex]\n        unexplored.remove(currentVertex)\n        explored.add(currentVertex) for each edge (currentVertex, neighbor) in edges do if neighbor in unexplored and weight(currentVertex, neighbor) <",
    "source_url": "https://en.wikipedia.org/wiki/Prim%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:27.053204",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:27.053204",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:27.053204",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Prim%27s_algorithm_1_1749014367281_8721",
    "text": "Let Y 1 be a minimum spanning tree of graph P. If Y 1 = Y then Y is a minimum spanning tree. Otherwise, let e be the first edge added during the construction of tree Y that is not in tree Y 1 , and V be the set of vertices connected by the edges added before edge e . Then one endpoint of edge e is in set V and the other is not. Since tree Y 1 is a spanning tree of graph P , there is a path in tree Y 1 joining the two endpoints. As one travels along the path, one must encounter an edge f joining a vertex in set V to one that is not in set V . Now, at the iteration when edge e was added to tree Y , edge f could also have been added and it would be added instead of edge e if its weight was less than e , and since edge f was not added, we conclude that w ( f ) ≥ w ( e ) . {\\displaystyle w(f)\\geq w(e).} Let tree Y 2 be the graph obtained by removing edge f from and adding edge e to tree Y 1 .",
    "source_url": "https://en.wikipedia.org/wiki/Prim%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:27.281714",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:27.281714",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:27.281714",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Prim%27s_algorithm&oldid=1290601959_1_1749014368487_6184",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Ajmullen ( talk | contribs ) at 20:30, 15 May 2025 ( → Description : Formalised pseudocode) . The present address (URL) is a permanent link to this version. Revision as of 20:30, 15 May 2025 by Ajmullen ( talk | contribs ) ( → Description : Formalised pseudocode) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Method for finding minimum spanning trees A de",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Prim%27s_algorithm&oldid=1290601959",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:28.487519",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:28.487519",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:28.487519",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Randomized_algorithm&oldid=1276591468_1_1749014372807_6336",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by WikiCleanerBot ( talk | contribs ) at 18:46, 19 February 2025 (v2.05b - Bot T20 CW#61 - Fix errors for CW project (Reference before punctuation)) . The present address (URL) is a permanent link to this version. Revision as of 18:46, 19 February 2025 by WikiCleanerBot ( talk | contribs ) (v2.05b - Bot T20 CW#61 - Fix errors for CW project (Reference before punctuation)) ( diff ) ← Previou",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Randomized_algorithm&oldid=1276591468",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:32.807107",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:32.807107",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:32.807107",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Raita_algorithm&oldid=1157291016_1_1749014377126_6427",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Jarble ( talk | contribs ) at 17:11, 27 May 2023 (adding Template:Strings ) . The present address (URL) is a permanent link to this version. Revision as of 17:11, 27 May 2023 by Jarble ( talk | contribs ) (adding Template:Strings ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) This article has multiple issues. Please help improve it or discuss these issu",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Raita_algorithm&oldid=1157291016",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:37.126666",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:37.126666",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:37.126666",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Recursive_data_structure_1_1749014381930_1792",
    "text": "This definition is elegant and easy to work with abstractly (such as when proving theorems about properties of trees), as it expresses a tree in simple terms: a list of one type, and a pair of two types. This mutually recursive definition can be converted to a singly recursive definition by inlining the definition of a forest: t: v [t[1], ..., t[k]] A tree t consists of a pair of a value v and a list of trees (its children). This definition is more compact, but somewhat messier: a tree consists of a pair of one type and a list another, which require disentangling to prove results about. In Standard ML , the tree and forest data types can be mutually recursively defined as follows, allowing empty trees: [ 1 ] datatype 'a tree = Empty | Node of 'a * 'a forest and 'a forest = Nil | Cons of 'a tree * 'a forest In Haskell, the tree and forest data types can be defined similarly: data Tree a = Empty | Node ( a , Forest a ) data Forest a = Nil | Cons ( Tree a )",
    "source_url": "https://en.wikipedia.org/wiki/Recursive_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:41.930896",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:41.930896",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:41.930896",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Recursive_data_structure_1_1749014381960_2460",
    "text": "( Forest a ) Theory [ edit ] In type theory , a recursive type has the general form μα . T where the type variable α may appear in the type T and stands for the entire type itself. For example, the natural numbers (see Peano arithmetic ) may be defined by the Haskell datatype: data Nat = Zero | Succ Nat In type theory, we would say: nat = μ α .1 + α {\\displaystyle {\\text{nat}}=\\mu \\alpha .1+\\alpha } where the two arms of the sum type represent the Zero and Succ data constructors. Zero takes no arguments (thus represented by the unit type ) and Succ takes another Nat (thus another element of μ α .1 + α {\\displaystyle \\mu \\alpha .1+\\alpha } ). There are two forms of recursive types: the so-called isorecursive types, and equirecursive types. The two forms differ in how terms of a recursive type are introduced and eliminated. Isorecursive types [ edit ] With isorecursive types, the recursive type μ α . T {\\displaystyle \\mu \\alpha .T} and its expansion (or unrolling ) T [ μ α .",
    "source_url": "https://en.wikipedia.org/wiki/Recursive_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:41.960904",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:41.960904",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:41.960904",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Recursive_data_structure_1_1749014381991_5259",
    "text": "T {\\displaystyle \\mu \\alpha .T} and its expansion (or unrolling ) T [ μ α . T / α ] {\\displaystyle T[\\mu \\alpha .T/\\alpha ]} (where the notation X [ Y / Z ] {\\displaystyle X[Y/Z]} indicates that all instances of Z are replaced with Y in X) are distinct (and disjoint) types with special term constructs, usually called roll and unroll , that form an isomorphism between them. To be precise: r o l l : T [ μ α . T / α ] → μ α . T {\\displaystyle roll:T[\\mu \\alpha .T/\\alpha ] \\to \\mu \\alpha .T} and u n r o l l : μ α . T → T [ μ α . T / α ] {\\displaystyle unroll:\\mu \\alpha .T\\to T[\\mu \\alpha .T/\\alpha ]} , and these two are inverse functions . Equirecursive types [ edit ] Under equirecursive rules, a recursive type μ α . T {\\displaystyle \\mu \\alpha .T} and its unrolling T [ μ α . T / α ] {\\displaystyle T[\\mu \\alpha .T/\\alpha ]} are equal – that is, those two type expressions are understood to denote the same type.",
    "source_url": "https://en.wikipedia.org/wiki/Recursive_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:41.991909",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:41.991909",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:41.991909",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Recursive_data_structure_1_1749014382061_6775",
    "text": "[ 3 ] Recursive type synonyms [ edit ] This section possibly contains original research . Please improve it by verifying the claims made and adding inline citations . Statements consisting only of original research should be removed. ( January 2024 ) ( Learn how and when to remove this message ) In TypeScript , recursion is allowed in type aliases. [ 4 ] Thus, the following example is allowed. type Tree = number | Tree []; let tree : Tree = [ 1 , [ 2 , 3 ]]; However, recursion is not allowed in type synonyms in Miranda , OCaml (unless -rectypes flag is used or it is a record or variant), or Haskell; so, for example the following Haskell types are illegal: type Bad = ( Int , Bad ) type Evil = Bool -> Evil Instead, they must be wrapped inside an algebraic data type (even if they only has one constructor): data Good = Pair Int Good data Fine = Fun ( Bool -> Fine ) This is because type synonyms, like typedefs in C, are replaced with their definition at compile time.",
    "source_url": "https://en.wikipedia.org/wiki/Recursive_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:42.061424",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:42.061424",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:42.061424",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimax_1_1749014385173_4647",
    "text": "Jump to content From Wikipedia, the free encyclopedia Decision rule used for minimizing the possible loss for a worst case scenario This article is about the decision theory concept. For other uses, see Minimax (disambiguation) . For company, see MiniMax (company) . Minimax (sometimes Minmax , MM [ 1 ] or saddle point [ 2 ] ) is a decision rule used in artificial intelligence , decision theory , combinatorial game theory , statistics , and philosophy for minimizing the possible loss for a worst ",
    "source_url": "https://en.wikipedia.org/wiki/Minimax",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:45.173694",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:45.174687",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:45.174687",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Selection_algorithm_1_1749014387794_4848",
    "text": "[ 1 ] To simplify the problem, some works on this problem assume that the values are all distinct from each other, [ 2 ] or that some consistent tie-breaking method has been used to assign an ordering to pairs of items with the same value as each other. Another variation in the problem definition concerns the numbering of the ordered values: is the smallest value obtained by setting k = 0 {\\displaystyle k=0} , as in zero-based numbering of arrays, or is it obtained by setting k = 1 {\\displaystyle k=1} , following the usual English-language conventions for the smallest, second-smallest, etc.? This article follows the conventions used by Cormen et al., according to which all values are distinct and the minimum value is obtained from k = 1 {\\displaystyle k=1} . [ 2 ] With these conventions, the maximum value, among a collection of n {\\displaystyle n} values, is obtained by setting k = n {\\displaystyle k=n} .",
    "source_url": "https://en.wikipedia.org/wiki/Selection_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:47.794832",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:47.794832",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:47.794832",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Selection_algorithm&oldid=1272480370_1_1749014390846_5836",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by David Eppstein ( talk | contribs ) at 20:59, 28 January 2025 (Undid revision 1272462687 by 49.207.232.175 ( talk ) the values must have an ordering. They may not be presented in that ordering.) . The present address (URL) is a permanent link to this version. Revision as of 20:59, 28 January 2025 by David Eppstein ( talk | contribs ) (Undid revision 1272462687 by 49.207.232.175 ( talk ) t",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Selection_algorithm&oldid=1272480370",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:50.846295",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:50.846295",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:50.846295",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simple_continued_fraction_1_1749014395701_4291",
    "text": "Jump to content From Wikipedia, the free encyclopedia Number represented as a0+1/(a1+1/...) \"Recurring fraction\" redirects here and is not to be confused with Repeating decimal . A simple or regular continued fraction is a continued fraction with numerators all equal one, and denominators built from a sequence { a i } {\\displaystyle \\{a_{i}\\}} of integer numbers. The sequence can be finite or infinite, resulting in a finite (or terminated ) continued fraction like a 0 + 1 a 1 + 1 a 2 + 1 ⋱ + 1 a",
    "source_url": "https://en.wikipedia.org/wiki/Simple_continued_fraction",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:55.701359",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:55.702359",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:55.702359",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Shor%27s_algorithm&oldid=1289663168_1_1749014396442_9645",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by ClintonPortishead ( talk | contribs ) at 01:39, 10 May 2025 (Removed reference to Qiskit, which is a software product developed by one quantum computing vendor. Wikipedia should not be a place for product pitches or favoritism.) . The present address (URL) is a permanent link to this version. Revision as of 01:39, 10 May 2025 by ClintonPortishead ( talk | contribs ) (Removed reference to",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Shor%27s_algorithm&oldid=1289663168",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:56.442511",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:56.443528",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:56.443528",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simon%27s_algorithm_1_1749014398958_2643",
    "text": "Problem description [ edit ] Simon's problem considers access to a function f : { 0 , 1 } n → { 0 , 1 } m , m ≥ n {\\displaystyle f:\\{0,1\\}^{n}\\to \\{0,1\\}^{m},\\;m\\geq n} as implemented by a black box or an oracle. This function is promised to be either a one-to-one function, or a two-to-one function; if f {\\displaystyle f} is two-to-one, it is furthermore promised that two inputs x {\\displaystyle x} and x ′ {\\displaystyle x'} evaluate to the same value if and only if x {\\displaystyle x} and x ′ {\\displaystyle x'} differ in a fixed set of bits. I.e., If f {\\displaystyle f} is not one-to-one, it is promised that there exists a non-zero s {\\displaystyle s} such that, for all x ≠ x ′ {\\displaystyle x\\neq x'} , f ( x ) = f ( x ′ ) {\\displaystyle f(x)=f(x')} if and only if x ′ = x ⊕ s {\\displaystyle x'=x\\oplus s} where ⊕ {\\displaystyle \\oplus } denotes bitwise exclusive-or . Simon's problem asks, in its decision version, whether f {\\displaystyle f} is one-to-one or two-to-one.",
    "source_url": "https://en.wikipedia.org/wiki/Simon%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:58.958024",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:58.958024",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:58.958024",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simon%27s_algorithm_1_1749014398983_1884",
    "text": "In its non-decision version, Simon's problem asks whether f {\\displaystyle f} is one-to-one or what is the value of s {\\displaystyle s} (as defined above). The goal is to solve this task with the least number of queries (evaluations) of f {\\displaystyle f} . Note that if x ′ = x {\\displaystyle x'=x} , then f ( x ′ ) = f ( x ) {\\displaystyle f(x')=f(x)} and x ′ = x ⊕ s {\\displaystyle x'=x\\oplus s} with s = 0 {\\displaystyle s=0} . On the other hand (because a ⊕ b ⊕ b = a {\\displaystyle a\\oplus b\\oplus b=a} for all a {\\displaystyle a} and b {\\displaystyle b} ), x ′ = x ⊕ s ⟺ x ′ ⊕ x = s {\\displaystyle x'=x\\oplus s\\iff x'\\oplus x=s} .",
    "source_url": "https://en.wikipedia.org/wiki/Simon%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:58.983017",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:58.984017",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:58.984017",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simon%27s_algorithm_1_1749014399019_7813",
    "text": "′ = x ⊕ s ⟺ x ′ ⊕ x = s {\\displaystyle x'=x\\oplus s\\iff x'\\oplus x=s} . Thus, Simon's problem may be restated in the following form: Given black-box or oracle access to f {\\displaystyle f} , promised to satisfy, for some s {\\displaystyle s} and all x , x ′ {\\displaystyle x,x'} , f ( x ) = f ( x ′ ) {\\displaystyle f(x)=f(x')} if and only if x ′ ⊕ x ∈ { 0 , s } {\\displaystyle x'\\oplus x\\in \\{0,s\\}} , determine whether s ≠ 0 {\\displaystyle s\\neq 0} (decision version), or output s {\\displaystyle s} (non-decision version). Note also that the promise on f {\\displaystyle f} implies that if f {\\displaystyle f} is two-to-one then it is a periodic function: f ( x ) = f ( y ) = f ( x ⊕ s ) . {\\displaystyle f(x)=f(y)=f(x\\oplus s).} Example [ edit ] The following function is an example of a function that satisfies the required property for n = 3 {\\displaystyle n=3} : x {\\displaystyle x} f ( x ) {\\displaystyle f(x)} 000 101 001 010 010 000 011 110 100 000 101 110 110 101 111 010",
    "source_url": "https://en.wikipedia.org/wiki/Simon%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:59.019682",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:59.019682",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:59.019682",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simon%27s_algorithm_1_1749014399050_1593",
    "text": "In this case, s = 110 {\\displaystyle s=110} (i.e. the solution). Every output of f {\\displaystyle f} occurs twice, and the two input strings corresponding to any one given output have bitwise XOR equal to s = 110 {\\displaystyle s=110} . For example, the input strings 010 {\\displaystyle 010} and 100 {\\displaystyle 100} are both mapped (by f {\\displaystyle f} ) to the same output string 000 {\\displaystyle 000} . That is, f ( 010 ) = 000 {\\displaystyle {\\displaystyle f(010)=000}} and f ( 100 ) = 000 {\\displaystyle {\\displaystyle f(100)=000}} . Applying XOR to 010 and 100 obtains 110, that is 010 ⊕ 100 = 110 = s . {\\displaystyle {\\displaystyle 010\\oplus 100=110=s}.} s = 110 {\\displaystyle s=110} can also be verified using input strings 001 and 111 that are both mapped (by f) to the same output string 010. Applying XOR to 001 and 111 obtains 110, that is 001 ⊕ 111 = 110 = s {\\displaystyle 001\\oplus 111=110=s} . This gives the same solution s = 110 {\\displaystyle s=110} as before.",
    "source_url": "https://en.wikipedia.org/wiki/Simon%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:59.050684",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:59.050684",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:59.050684",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simon%27s_algorithm_1_1749014399076_4074",
    "text": "This gives the same solution s = 110 {\\displaystyle s=110} as before. In this example the function f is indeed a two-to-one function where s ≠ 0 n {\\displaystyle {\\displaystyle s\\neq 0^{n}}} . Problem hardness [ edit ] Intuitively, this is a hard problem to solve in a \"classical\" way, even if one uses randomness and accepts a small probability of error. The intuition behind the hardness is reasonably simple: if you want to solve the problem classically, you need to find two different inputs x {\\displaystyle x} and y {\\displaystyle y} for which f ( x ) = f ( y ) {\\displaystyle f(x)=f(y)} . There is not necessarily any structure in the function f {\\displaystyle f} that would help us to find two such inputs: more specifically, we can discover something about f {\\displaystyle f} (or what it does) only when, for two different inputs, we obtain the same output.",
    "source_url": "https://en.wikipedia.org/wiki/Simon%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:59.076699",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:59.076699",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:59.076699",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simon%27s_algorithm_1_1749014399235_5589",
    "text": "The probability of measuring a state | j ⟩ {\\displaystyle |j\\rangle } is | | 1 2 n ∑ k = 0 2 n − 1 ( − 1 ) j ⋅ k | f ( k ) ⟩ | | 2 {\\displaystyle \\left|\\left|{\\frac {1}{2^{n}}}\\sum _{k=0}^{2^{n}-1}(-1)^{j\\cdot k}|f(k)\\rangle \\right|\\right|^{2}} This is due to the fact that taking the magnitude of this vector and squaring it sums up all the probabilities of all the possible measurements of the second register that must have the first register as | j ⟩ {\\displaystyle |j\\rangle } . There are two cases for our measurement: s = 0 n {\\displaystyle s=0^{n}} and f {\\displaystyle f} is one-to-one. s ≠ 0 n {\\displaystyle s\\neq 0^{n}} and f {\\displaystyle f} is two-to-one.",
    "source_url": "https://en.wikipedia.org/wiki/Simon%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:19:59.235718",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:19:59.235718",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:19:59.235718",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Smith_algorithm_1_1749014402466_8776",
    "text": "Determine the substitution matrix and the gap penalty scheme. s ( a , b ) {\\displaystyle s(a,b)} - Similarity score of the elements that constituted the two sequences W k {\\displaystyle W_{k}} - The penalty of a gap that has length k {\\displaystyle k} Construct a scoring matrix H {\\displaystyle H} and initialize its first row and first column. The size of the scoring matrix is ( n + 1 ) ∗ ( m + 1 ) {\\displaystyle (n+1)*(m+1)} . The matrix uses 0-based indexing. H k 0 = H 0 l = 0 f o r 0 ≤ k ≤ n a n d 0 ≤ l ≤ m {\\displaystyle H_{k0}=H_{0l}=0\\quad for\\quad 0\\leq k\\leq n\\quad and\\quad 0\\leq l\\leq m} Fill the scoring matrix using the equation below. H i j = max { H i − 1 , j − 1 + s ( a i , b j ) , max k ≥ 1 { H i − k , j − W k } , max l ≥ 1 { H",
    "source_url": "https://en.wikipedia.org/wiki/Smith_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:02.466427",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:02.467427",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:02.467427",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Smith_algorithm_1_1749014402502_7229",
    "text": "H i j = max { H i − 1 , j − 1 + s ( a i , b j ) , max k ≥ 1 { H i − k , j − W k } , max l ≥ 1 { H i , j − l − W l } , 0 ( 1 ≤ i ≤ n , 1 ≤ j ≤ m ) {\\displaystyle H_{ij}=\\max {\\begin{cases}H_{i-1,j-1}+s(a_{i},b_{j}),\\\\\\max _{k\\geq 1}\\{H_{i-k,j}-W_{k}\\},\\\\\\max _{l\\geq 1}\\{H_{i,j-l}-W_{l}\\},\\\\0\\end{cases}}\\qquad (1\\leq i\\leq n,1\\leq j\\leq m)} where H i − 1 , j − 1 + s ( a i , b j ) {\\displaystyle H_{i-1,j-1}+s(a_{i},b_{j})} is the score of aligning a i {\\displaystyle a_{i}} and b j {\\displaystyle b_{j}} , H i − k , j − W k {\\displaystyle H_{i-k,j}-W_{k}} is the score if a i {\\displaystyle a_{i}} is at the end of a gap of length k {\\displaystyle k} , H i , j − l − W l {\\displaystyle H_{i,j-l}-W_{l}} is the score if b j {\\displaystyle b_{j}} is at the end of a gap of length l {\\displaystyle l} , 0 {\\displaystyle 0} means there is no similarity up to a i {\\displaystyle a_{i}} and b j {\\displaystyle b_{j}} . Traceback.",
    "source_url": "https://en.wikipedia.org/wiki/Smith_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:02.502430",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:02.502430",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:02.502430",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_COSBI_1_1749014404550_3250",
    "text": "Jump to content Coordinates : 46°03′57″N 11°09′17″E ﻿ / ﻿ 46.065872°N 11.154652°E ﻿ / 46.065872; 11.154652 From Wikipedia, the free encyclopedia Italian nonprofit research center This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) The topic of this article may not meet Wikipedia's notability guidelines for companies and organizations . Please help to demonstrate the notability of the topic by citing r",
    "source_url": "https://en.wikipedia.org/wiki/COSBI",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:04.550201",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:04.551556",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:04.551556",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Smith%E2%80%93Waterman_algorithm_1_1749014406666_2900",
    "text": "Determine the substitution matrix and the gap penalty scheme. s ( a , b ) {\\displaystyle s(a,b)} - Similarity score of the elements that constituted the two sequences W k {\\displaystyle W_{k}} - The penalty of a gap that has length k {\\displaystyle k} Construct a scoring matrix H {\\displaystyle H} and initialize its first row and first column. The size of the scoring matrix is ( n + 1 ) ∗ ( m + 1 ) {\\displaystyle (n+1)*(m+1)} . The matrix uses 0-based indexing. H k 0 = H 0 l = 0 f o r 0 ≤ k ≤ n a n d 0 ≤ l ≤ m {\\displaystyle H_{k0}=H_{0l}=0\\quad for\\quad 0\\leq k\\leq n\\quad and\\quad 0\\leq l\\leq m} Fill the scoring matrix using the equation below. H i j = max { H i − 1 , j − 1 + s ( a i , b j ) , max k ≥ 1 { H i − k , j − W k } , max l ≥ 1 { H",
    "source_url": "https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:06.666781",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:06.666781",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:06.666781",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Smith%E2%80%93Waterman_algorithm_1_1749014406702_4853",
    "text": "H i j = max { H i − 1 , j − 1 + s ( a i , b j ) , max k ≥ 1 { H i − k , j − W k } , max l ≥ 1 { H i , j − l − W l } , 0 ( 1 ≤ i ≤ n , 1 ≤ j ≤ m ) {\\displaystyle H_{ij}=\\max {\\begin{cases}H_{i-1,j-1}+s(a_{i},b_{j}),\\\\\\max _{k\\geq 1}\\{H_{i-k,j}-W_{k}\\},\\\\\\max _{l\\geq 1}\\{H_{i,j-l}-W_{l}\\},\\\\0\\end{cases}}\\qquad (1\\leq i\\leq n,1\\leq j\\leq m)} where H i − 1 , j − 1 + s ( a i , b j ) {\\displaystyle H_{i-1,j-1}+s(a_{i},b_{j})} is the score of aligning a i {\\displaystyle a_{i}} and b j {\\displaystyle b_{j}} , H i − k , j − W k {\\displaystyle H_{i-k,j}-W_{k}} is the score if a i {\\displaystyle a_{i}} is at the end of a gap of length k {\\displaystyle k} , H i , j − l − W l {\\displaystyle H_{i,j-l}-W_{l}} is the score if b j {\\displaystyle b_{j}} is at the end of a gap of length l {\\displaystyle l} , 0 {\\displaystyle 0} means there is no similarity up to a i {\\displaystyle a_{i}} and b j {\\displaystyle b_{j}} . Traceback.",
    "source_url": "https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:06.702220",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:06.703221",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:06.703221",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Stack_(data_structure)_1_1749014416078_3545",
    "text": "When the top plate is removed from the stack, the one below it is elevated to become the new top plate. Non-essential operations [ edit ] In many implementations, a stack has more operations than the essential \"push\" and \"pop\" operations. An example of a non-essential operation is \"top of stack\", or \"peek\", which observes the top element without removing it from the stack. [ 18 ] Since this can be broken down into a \"pop\" followed by a \"push\" to return the same data to the stack, it is not considered an essential operation. If the stack is empty, an underflow condition will occur upon execution of either the \"stack top\" or \"pop\" operations. Additionally, many implementations include convenience operations that handle common tasks, such as checking if the stack is empty or returning its size. Software stacks [ edit ] Implementation [ edit ] A stack can be easily implemented either through an array or a linked list , as it is merely a special case of a list.",
    "source_url": "https://en.wikipedia.org/wiki/Stack_(data_structure)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:16.078720",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:16.079720",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:16.079720",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Stack_(data_structure)_1_1749014416143_4199",
    "text": "Thus, the stack itself can be effectively implemented as a three-element structure: structure stack:\n    maxsize : integer\n    top : integer\n    items : array of item procedure initialize(stk : stack, size : integer):\n    stk.items ← new array of size items, initially empty\n    stk.maxsize ← size\n    stk.top ← 0 The push operation adds an element and increments the top index, after checking for overflow: procedure push(stk : stack, x : item): if stk.top = stk.maxsize:\n        report overflow error else : stk.items[stk.top] ← x\n        stk.top ← stk.top + 1 Similarly, pop decrements the top index after checking for underflow, and returns the item that was previously the top one: procedure pop(stk : stack): if stk.top = 0:\n        report underflow error else :\n        stk.top ← stk.top − 1\n        r ← stk.items[stk.top] return r Using a dynamic array , it is possible to implement a stack that can grow or shrink as much as needed.",
    "source_url": "https://en.wikipedia.org/wiki/Stack_(data_structure)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:16.143053",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:16.144047",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:16.144047",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Stack_(data_structure)_1_1749014416165_6560",
    "text": "The size of the stack is simply the size of the dynamic array, which is a very efficient implementation of a stack since adding items to or removing items from the end of a dynamic array requires amortized O(1) time. Linked list [ edit ] Another option for implementing stacks is to use a singly linked list . A stack is then a pointer to the \"head\" of the list, with perhaps a counter to keep track of the size of the list: structure frame:\n    data : item\n    next : frame or nil structure stack:\n    head : frame or nil\n    size : integer procedure initialize(stk : stack):\n    stk.head ← nil\n    stk.size ← 0",
    "source_url": "https://en.wikipedia.org/wiki/Stack_(data_structure)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:16.165046",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:16.165046",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:16.165046",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Stack_(data_structure)_1_1749014416221_9144",
    "text": "The following is an example of manipulating a stack in Common Lisp (\" > \" is the Lisp interpreter's prompt; lines not starting with \" > \" are the interpreter's responses to expressions): > ( setf stack ( list 'a 'b 'c )) ;; set the variable \"stack\" ( A B C ) > ( pop stack ) ;; get top (leftmost) element, should modify the stack A > stack ;; check the value of stack ( B C ) > ( push 'new stack ) ;; push a new top onto the stack ( NEW B C ) Several of the C++ Standard Library container types have push_back and pop_back operations with LIFO semantics; additionally, the stack template class adapts existing containers to provide a restricted API with only push/pop operations. PHP has an SplStack class. Java's library contains a Stack class that is a specialization of Vector . Following is an example program in Java language, using that class. import java.util. Stack ; class StackDemo { public static void main ( String [] args ) { Stack < String > stack = new Stack < String > (); stack .",
    "source_url": "https://en.wikipedia.org/wiki/Stack_(data_structure)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:16.221155",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:16.221155",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:16.221155",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Succinct_data_structure_1_1749014426031_9639",
    "text": "[ 3 ] The basic problem is to store a subset S {\\displaystyle S} of a universe U = [ 0 … n ) = { 0 , 1 , … , n − 1 } {\\displaystyle U=[0\\dots n)=\\{0,1,\\dots ,n-1\\}} , usually represented as a bit array B [ 0 … n ) {\\displaystyle B[0\\dots n)} where B [ i ] = 1 {\\displaystyle B[i]=1} iff i ∈ S . {\\displaystyle i\\in S.} An indexable dictionary supports the usual methods on dictionaries (queries, and insertions/deletions in the dynamic case) as well as the following operations: r a n k q ( x ) = | { k ∈ [ 0 … x ] : B [ k ] = q } | {\\displaystyle \\mathbf {rank} _{q}(x)=|\\{k\\in [0\\dots x]:B[k]=q\\}|} s e l e c t q ( x ) = min { k ∈ [ 0 … n ) : r a n k q ( k ) = x } {\\displaystyle \\mathbf {select} _{q}(x)=\\min\\{k\\in [0\\dots n):\\mathbf {rank} _{q}(k)=x\\}} for q ∈ { 0 , 1 } {\\displaystyle q\\in \\{0,1\\}} .",
    "source_url": "https://en.wikipedia.org/wiki/Succinct_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:26.031859",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:26.031859",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:26.031859",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Succinct_data_structure_1_1749014426062_3474",
    "text": "In other words, r a n k q ( x ) {\\displaystyle \\mathbf {rank} _{q}(x)} returns the number of elements equal to q {\\displaystyle q} up to position x {\\displaystyle x} while s e l e c t q ( x ) {\\displaystyle \\mathbf {select} _{q}(x)} returns the position of the x {\\displaystyle x} -th occurrence of q {\\displaystyle q} . There is a simple representation [ 4 ] which uses n + o ( n ) {\\displaystyle n+o(n)} bits of storage space (the original bit array and an o ( n ) {\\displaystyle o(n)} auxiliary structure) and supports rank and select in constant time. It uses an idea similar to that for range-minimum queries ; there are a constant number of recursions before stopping at a subproblem of a limited size. The bit array B {\\displaystyle B} is partitioned into large blocks of size l = lg 2 ⁡ n {\\displaystyle l=\\lg ^{2}n} bits and small blocks of size s = lg ⁡ n / 2 {\\displaystyle s=\\lg n/2} bits.",
    "source_url": "https://en.wikipedia.org/wiki/Succinct_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:26.062355",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:26.062355",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:26.062355",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Succinct_data_structure_1_1749014426094_6301",
    "text": "For each large block, the rank of its first bit is stored in a separate table R l [ 0 … n / l ) {\\displaystyle R_{l}[0\\dots n/l)} ; each such entry takes lg ⁡ n {\\displaystyle \\lg n} bits for a total of ( n / l ) lg ⁡ n = n / lg ⁡ n {\\displaystyle (n/l)\\lg n=n/\\lg n} bits of storage. Within a large block, another directory R s [ 0 … l / s ) {\\displaystyle R_{s}[0\\dots l/s)} stores the rank of each of the l / s = 2 lg ⁡ n {\\displaystyle l/s=2\\lg n} small blocks it contains. The difference here is that it only needs lg ⁡ l = lg ⁡ lg 2 ⁡ n = 2 lg ⁡ lg ⁡ n {\\displaystyle \\lg l=\\lg \\lg ^{2}n=2\\lg \\lg n} bits for each entry, since only the differences from the rank of the first bit in the containing large block need to be stored. Thus, this table takes a total of ( n / s ) lg ⁡ l = 4 n lg ⁡ lg ⁡ n / lg ⁡ n {\\displaystyle (n/s)\\lg l=4n\\lg \\lg n/\\lg n} bits.",
    "source_url": "https://en.wikipedia.org/wiki/Succinct_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:26.095887",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:26.095887",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:26.095887",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Succinct_data_structure_1_1749014426245_6171",
    "text": "{\\displaystyle {\\mathcal {B}}(m,n)+o({\\mathcal {B}}(m,n))} space. [ 8 ] This structure can be extended to support rank and select queries and takes B ( m , n ) + O ( m + n lg ⁡ lg ⁡ n / lg ⁡ n ) {\\displaystyle {\\mathcal {B}}(m,n)+O(m+n\\lg \\lg n/\\lg n)} space. [ 2 ] Correct rank queries in this structure are however limited to elements contained in the set, analogous to how minimal perfect hashing functions work. This bound can be reduced to a space/time tradeoff by reducing the storage space of the dictionary to B ( m , n ) + O ( n t t / lg t ⁡ n + n 3 / 4 ) {\\displaystyle {\\mathcal {B}}(m,n)+O(nt^{t}/\\lg ^{t}n+n^{3/4})} with queries taking O ( t ) {\\displaystyle O(t)} time. [ 9 ] It is also possible to construct a indexible dictionary supporting rank (but not select) that uses fewer than B ( m , n ) {\\displaystyle \\textstyle {\\mathcal {B}}(m,n)} bits.",
    "source_url": "https://en.wikipedia.org/wiki/Succinct_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:26.245849",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:26.245849",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:26.245849",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Succinct_data_structure_1_1749014426326_9874",
    "text": "O ( m log ⁡ log ⁡ m ) {\\displaystyle {\\mathcal {B}}(m,n)+O(m\\log \\log m)} bits. Subsequently, it was shown that this space bound could be improved to B ( m , n ) + O ( m log ⁡ log ⁡ log ⁡ ⋯ log ⁡ m ) {\\displaystyle {\\mathcal {B}}(m,n)+O(m\\log \\log \\log \\cdots \\log m)} bits for any constant number of logarithms [ 13 ] and a little after that this bound was also optimal. [ 14 ] [ 15 ] The latter solution supports all operations in worst-case constant time with high probability. The first static succinct hash table was due to Pagh in 1999. [ 16 ] [ 17 ] In the case where n = poly ( m ) {\\displaystyle n={\\text{poly}}(m)} , their solution uses space B ( m , n ) + O ( m ( log ⁡ log ⁡ m ) 2 / log ⁡ m ) {\\displaystyle {\\mathcal {B}}(m,n)+O(m(\\log \\log m)^{2}/\\log m)} bits, and supports worst-case constant-time queries. This bound was subsequently improved to B ( m , n ) + m / poly log ⁡ m {\\displaystyle {\\mathcal {B}}(m,n)+m/{\\text{poly}}\\log m} bits, [ 18 ] and then to B ( m , n )",
    "source_url": "https://en.wikipedia.org/wiki/Succinct_data_structure",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:26.326686",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:26.326686",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:26.326686",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Viterbi_algorithm_1_1749014437595_3903",
    "text": "Then the values of P {\\displaystyle P} are given by the recurrence relation [ 8 ] P t , s = { π s ⋅ b s , o t if t = 0 , max r ∈ S ( P t − 1 , r ⋅ a r , s ⋅ b s , o t ) if t > 0. {\\displaystyle P_{t,s}={\\begin{cases}\\pi _{s}\\cdot b_{s,o_{t}}&{\\text{if }}t=0,\\\\\\max _{r\\in S}\\left(P_{t-1,r}\\cdot a_{r,s}\\cdot b_{s,o_{t}}\\right)&{\\text{if }}t>0.\\end{cases}}} The formula for Q t , s {\\displaystyle Q_{t,s}} is identical for t > 0 {\\displaystyle t>0} , except that max {\\displaystyle \\max } is replaced with arg ⁡ max {\\displaystyle \\arg \\max } , and Q 0 , s = 0 {\\displaystyle Q_{0,s}=0} . The Viterbi path can be found by selecting the maximum of P {\\displaystyle P} at the final timestep, and following Q {\\displaystyle Q} in reverse.",
    "source_url": "https://en.wikipedia.org/wiki/Viterbi_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:37.595893",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:37.596696",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:37.596696",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Viterbi_algorithm_1_1749014437967_3802",
    "text": "( T × | S | 2 ) {\\displaystyle O(T\\times \\left|{S}\\right|^{2})} . If it is known which state transitions have non-zero probability, an improved bound can be found by iterating over only those r {\\displaystyle r} which link to s {\\displaystyle s} in the inner loop. Then using amortized analysis one can show that the complexity is O ( T × ( | S | + | E | ) ) {\\displaystyle O(T\\times (\\left|{S}\\right|+\\left|{E}\\right|))} , where E {\\displaystyle E} is the number of edges in the graph, i.e. the number of non-zero entries in the transition matrix. Example [ edit ] A doctor wishes to determine whether patients are healthy or have a fever. The only information the doctor can obtain is by asking patients how they feel. The patients may report that they either feel normal, dizzy, or cold. It is believed that the health condition of the patients operates as a discrete Markov chain .",
    "source_url": "https://en.wikipedia.org/wiki/Viterbi_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:37.967023",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:37.967023",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:37.967023",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Viterbi_algorithm&oldid=1284982097_1_1749014440057_4241",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by 2603:3024:219:c200:e011:c6b4:98e9:385f ( talk ) at 22:57, 10 April 2025 ( → Pseudocode ) . The present address (URL) is a permanent link to this version. Revision as of 22:57, 10 April 2025 by 2603:3024:219:c200:e011:c6b4:98e9:385f ( talk ) ( → Pseudocode ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Finds likely sequence of hidden states This article ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Viterbi_algorithm&oldid=1284982097",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:40.057510",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:40.058510",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:40.058510",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Xiaolin_Wu%27s_line_algorithm_1_1749014441237_5287",
    "text": "integer part of x function ipart ( x ) is return floor ( x ) function round ( x ) is return ipart ( x + 0.5 ) // fractional part of x function fpart ( x ) is return x - ipart ( x ) function rfpart ( x ) is return 1 - fpart ( x ) function drawLine ( x0 , y0 , x1 , y1 ) is boolean steep : = abs ( y1 - y0 ) > abs ( x1 - x0 ) if steep then swap ( x0 , y0 ) swap ( x1 , y1 ) end if if x0 > x1 then swap ( x0 , x1 ) swap ( y0 , y1 ) end if dx := x1 - x0 dy := y1 - y0 if dx == 0.0 then gradient := 1.0 else gradient := dy / dx end if // handle first endpoint xend : = round ( x0 ) yend := y0 + gradient * ( xend - x0 ) xgap := rfpart ( x0 + 0.5 ) xpxl1 : = xend // this will be used in the main loop ypxl1 :",
    "source_url": "https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:41.237854",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:41.237854",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:41.237854",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Xiaolin_Wu%27s_line_algorithm_1_1749014441273_6783",
    "text": "= xend // this will be used in the main loop ypxl1 : = ipart ( yend ) if steep then plot ( ypxl1 , xpxl1 , rfpart ( yend ) * xgap ) plot ( ypxl1 + 1 , xpxl1 , fpart ( yend ) * xgap ) else plot ( xpxl1 , ypxl1 , rfpart ( yend ) * xgap ) plot ( xpxl1 , ypxl1 + 1 , fpart ( yend ) * xgap ) end if intery := yend + gradient // first y-intersection for the main loop // handle second endpoint xend := round ( x1 ) yend := y1 + gradient * ( xend - x1 ) xgap := fpart ( x1 + 0.5 ) xpxl2 : = xend //this will be used in the main loop ypxl2 := ipart ( yend ) if steep then plot ( ypxl2 , xpxl2 , rfpart ( yend ) * xgap ) plot ( ypxl2 + 1 , xpxl2 , fpart ( yend ) * xgap ) else plot ( xpxl2 , ypxl2 , rfpart ( yend ) * xgap ) plot ( xpxl2 , ypxl2 + 1 , fpart ( yend ) * xgap ) end if // main loop if steep then for x from xpxl1 + 1 to xpxl2 - 1 do begin plot ( ipart ( intery ) , x , rfpart ( intery )) plot ( ipart ( intery ) + 1 , x , fpart ( intery ))",
    "source_url": "https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:41.273362",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:41.273362",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:41.273362",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Xiaolin_Wu%27s_line_algorithm&oldid=1292191022_1_1749014441887_9142",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 17:37, 25 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 17:37, 25 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Line",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Xiaolin_Wu%27s_line_algorithm&oldid=1292191022",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:41.887573",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:41.887573",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:41.887573",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Zipper_(data_structure)_1_1749014445136_9214",
    "text": "A list such as [1, 2, 3] is therefore the declaration Cons(1, Cons(2, Cons(3, Empty))) . It is possible to describe the location in such a list as the number of steps from the front of the list to the target location. More formally, a location in the list is the number of Cons operations required to reconstruct the whole list from that particular location. For example, in Cons(1, Cons(2, Cons( X, Cons(4, Empty)))) a Cons(2, L) and a Cons(1, L) operation would be required to reconstruct the list relative to position X otherwise known as Cons( X, Cons(4, Empty)) . This recording together with the location is called a zipped representation of the list or a list-zipper. To be clear, a location in the list is not just the number of Cons operations, but also all of the other information about those Cons ; in this case, the values that must be reconnected. Here, these values may be conveniently represented in a separate list in the order of application from the target location.",
    "source_url": "https://en.wikipedia.org/wiki/Zipper_(data_structure)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:45.136467",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:45.137467",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:45.137467",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Zipper_(data_structure)_1_1749014445382_1824",
    "text": "The derivative in terms of X {\\displaystyle X} is T ′ ( X ) = T 2 ( X ) + 2 × X × T ( X ) × T ′ ( X ) {\\displaystyle T'(X)=T^{2}(X)+2\\times X\\times T(X)\\times T'(X)} . We can read this algebraic notation as a zipper with a hole: A zipper for a tree either has the \"missing value\" at the very root of the tree, leaving the two branches as ordinary trees (the T 2 ( X ) {\\displaystyle T^{2}(X)} case), or it has the missing value on one of the two branches ( 2 × X × T ( X ) × T ′ ( X ) {\\displaystyle 2\\times X\\times T(X)\\times T'(X)} ). In the latter case, the Boolean type 2 {\\displaystyle 2} indicates which branch (left or right) contains the hole, and the zipper contains a value for the root, a T ( X ) {\\displaystyle T(X)} for the complete branch, and a T ′ ( X ) {\\displaystyle T'(X)} for the branch that's missing a value of type X {\\displaystyle X} .",
    "source_url": "https://en.wikipedia.org/wiki/Zipper_(data_structure)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:45.382780",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:45.382780",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:45.382780",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Analysis_of_algorithms&oldid=1286246799_1_1749014452579_2305",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Widefox ( talk | contribs ) at 17:34, 18 April 2025 ( → See also : already in body per WP:SEEALSO / WP:OVERLINK ) . The present address (URL) is a permanent link to this version. Revision as of 17:34, 18 April 2025 by Widefox ( talk | contribs ) ( → See also : already in body per WP:SEEALSO / WP:OVERLINK ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) St",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Analysis_of_algorithms&oldid=1286246799",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:20:52.579582",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:20:52.579582",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:20:52.579582",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quantum_Turing_machine_1_1749014460283_1280",
    "text": "amplification Bernstein–Vazirani BHT Boson sampling Deutsch–Jozsa Grover's HHL Hidden subgroup Magic state distillation Quantum annealing Quantum counting Quantum Fourier transform Quantum optimization Quantum phase estimation Shor's Simon's VQE Quantum complexity theory BQP DQC1 EQP QIP QMA",
    "source_url": "https://en.wikipedia.org/wiki/Quantum_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:00.283214",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:00.283214",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:00.283214",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Symmetric_Turing_machine_1_1749014462510_7510",
    "text": "If D is left , then the head of a machine in state p above a tape symbol b preceded by a symbol a can be transitioned by moving the head left, changing the state to q and replacing the symbols a,b by c,d . The opposite transition ⁠ ( q , c d , − D , a b , p ) {\\displaystyle (q,cd,-D,ab,p)} ⁠ can always be applied. If D is right the transition is analogous. The ability to peek at two symbols and change both at a time is non-essential, but makes the definition easier. Such machines were first defined in 1982 by Harry R. Lewis and Christos Papadimitriou , [ 1 ] [ 2 ] who were looking for a class in which to place USTCON , the problem asking whether there is a path between two given vertices s,t in an undirected graph. Until this time, it could be placed only in NL , despite seeming not to require nondeterminism (the asymmetric variant STCON was known to be complete for NL).",
    "source_url": "https://en.wikipedia.org/wiki/Symmetric_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:02.510089",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:02.511089",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:02.511089",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Multitape_Turing_machine_1_1749014488120_6573",
    "text": "[ 2 ] Thus, multi-tape machines cannot calculate any more functions than single-tape machines, [ 3 ] and none of the robust complexity classes (such as polynomial time ) are affected by a change between single-tape and multi-tape machines.",
    "source_url": "https://en.wikipedia.org/wiki/Multitape_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:28.120841",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:28.121847",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:28.121847",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Karatsuba_algorithm_1_1749014489965_1905",
    "text": "For any positive integer m {\\displaystyle m} less than n {\\displaystyle n} , one can write the two given numbers as x = x 1 B m + x 0 , {\\displaystyle x=x_{1}B^{m}+x_{0},} y = y 1 B m + y 0 , {\\displaystyle y=y_{1}B^{m}+y_{0},} where x 0 {\\displaystyle x_{0}} and y 0 {\\displaystyle y_{0}} are less than B m {\\displaystyle B^{m}} . The product is then x y = ( x 1 B m + x 0 ) ( y 1 B m + y 0 ) = x 1 y 1 B 2 m + ( x 1 y 0 + x 0 y 1 ) B m + x 0 y 0 = z 2 B 2 m + z 1 B m + z 0 , {\\displaystyle {\\begin{aligned}xy&=(x_{1}B^{m}+x_{0})(y_{1}B^{m}+y_{0})\\\\&=x_{1}y_{1}B^{2m}+(x_{1}y_{0}+x_{0}y_{1})B^{m}+x_{0}y_{0}\\\\&=z_{2}B^{2m}+z_{1}B^{m}+z_{0},\\\\\\end{aligned}}} where z 2 = x 1 y 1 , {\\displaystyle z_{2}=x_{1}y_{1},} z 1 = x 1 y 0 + x 0 y 1 , {\\displaystyle z_{1}=x_{1}y_{0}+x_{0}y_{1},} z 0 = x 0 y 0 . {\\displaystyle z_{0}=x_{0}y_{0}. } These formulae require four multiplications and were known to Charles Babbage .",
    "source_url": "https://en.wikipedia.org/wiki/Karatsuba_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:29.965995",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:29.965995",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:29.965995",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Karatsuba_algorithm_1_1749014489995_6732",
    "text": "} These formulae require four multiplications and were known to Charles Babbage . [ 4 ] Karatsuba observed that x y {\\displaystyle xy} can be computed in only three multiplications, at the cost of a few extra additions. With z 0 {\\displaystyle z_{0}} and z 2 {\\displaystyle z_{2}} as before and z 3 = ( x 1 + x 0 ) ( y 1 + y 0 ) , {\\displaystyle z_{3}=(x_{1}+x_{0})(y_{1}+y_{0}),} one can observe that z 1 = x 1 y 0 + x 0 y 1 = ( x 1 + x 0 ) ( y 0 + y 1 ) − x 1 y 1 − x 0 y 0 = z 3 − z 2 − z 0 . {\\displaystyle {\\begin{aligned}z_{1}&=x_{1}y_{0}+x_{0}y_{1}\\\\&=(x_{1}+x_{0})(y_{0}+y_{1})-x_{1}y_{1}-x_{0}y_{0}\\\\&=z_{3}-z_{2}-z_{0}.\\\\\\end{aligned}}} Thus only three multiplications are required for computing z 0 , z 1 {\\displaystyle z_{0},z_{1}} and z 2 . { \\displaystyle z_{2}. } Example [ edit ] To compute the product of 12345 and 6789, where B = 10, choose m = 3.",
    "source_url": "https://en.wikipedia.org/wiki/Karatsuba_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:29.995519",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:29.995519",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:29.995519",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Karatsuba_algorithm_1_1749014490026_8000",
    "text": "} Example [ edit ] To compute the product of 12345 and 6789, where B = 10, choose m = 3. We use m right shifts for decomposing the input operands using the resulting base ( B m = 1000 ), as: 12345 = 12 · 1000 + 345 6789 = 6 · 1000 + 789 Only three multiplications, which operate on smaller integers, are used to compute three partial results: z 2 = 12 × 6 = 72 z 0 = 345 × 789 = 272205 z 1 = ( 12 + 345 ) × ( 6 + 789 ) − z 2 − z 0 = 357 × 795 − 72 − 272205 = 283815 − 72 − 272205 = 11538 We get the result by just adding these three partial results, shifted accordingly (and then taking carries into account by decomposing these three inputs in base 1000 as for the input operands): result = z 2 · ( B m ) 2 + z 1 · ( B m ) 1 + z 0 · ( B m ) 0 , i.e. result = 72 · 1000 2 + 11538 · 1000 + 272205 = 83810205 .",
    "source_url": "https://en.wikipedia.org/wiki/Karatsuba_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:30.026321",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:30.026321",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:30.026321",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sch%C3%B6nhage%E2%80%93Strassen_algorithm_1_1749014493695_5689",
    "text": "Divide the signals a {\\displaystyle a} and b {\\displaystyle b} into D {\\displaystyle D} blocks of M {\\displaystyle M} bits each, storing the resulting blocks as arrays A , B {\\displaystyle A,B} (whose entries we shall consider for simplicity as arbitrary precision integers). We now select a modulus for the Fourier transform, as follows. Let M ′ {\\displaystyle M'} be such that D M ′ ≥ 2 M + k {\\displaystyle DM'\\geq 2M+k} . Also put n ′ = D M ′ {\\displaystyle n'=DM'} , and regard the elements of the arrays A , B {\\displaystyle A,B} as (arbitrary precision) integers modulo 2 n ′ + 1 {\\displaystyle 2^{n'}+1} . Observe that since 2 n ′ + 1 ≥ 2 2 M + k + 1 = D 2 2 M + 1 {\\displaystyle 2^{n'}+1\\geq 2^{2M+k}+1=D2^{2M}+1} , the modulus is large enough to accommodate any carries that can result from multiplying a {\\displaystyle a} and b {\\displaystyle b} .",
    "source_url": "https://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:33.695327",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:33.695327",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:33.695327",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sch%C3%B6nhage%E2%80%93Strassen_algorithm_1_1749014493727_8698",
    "text": "Thus, the product a b {\\displaystyle ab} (modulo 2 n + 1 {\\displaystyle 2^{n}+1} ) can be calculated by evaluating the convolution of A , B {\\displaystyle A,B} . Also, with g = 2 2 M ′ {\\displaystyle g=2^{2M'}} , we have g D / 2 ≡ − 1 ( mod 2 n ′ + 1 ) {\\displaystyle g^{D/2}\\equiv -1{\\pmod {2^{n'}+1}}} , and so g {\\displaystyle g} is a primitive D {\\displaystyle D} th root of unity modulo 2 n ′ + 1 {\\displaystyle 2^{n'}+1} . We now take the discrete Fourier transform of the arrays A , B {\\displaystyle A,B} in the ring Z / ( 2 n ′ + 1 ) Z {\\displaystyle \\mathbb {Z} /(2^{n'}+1)\\mathbb {Z} } , using the root of unity g {\\displaystyle g} for the Fourier basis, giving the transformed arrays A ^ , B ^ {\\displaystyle {\\widehat {A}},{\\widehat {B}}} . Because D = 2 k {\\displaystyle D=2^{k}} is a power of two, this can be achieved in logarithmic time using a fast Fourier transform . Let C ^ i = A ^ i B ^",
    "source_url": "https://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:33.727171",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:33.727171",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:33.727171",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sch%C3%B6nhage%E2%80%93Strassen_algorithm_1_1749014493849_1155",
    "text": "Details [ edit ] Every number in base B, can be written as a polynomial: X = ∑ i = 0 N x i B i {\\displaystyle X=\\sum _{i=0}^{N}{x_{i}B^{i}}} Furthermore, multiplication of two numbers could be thought of as a product of two polynomials: X Y = ( ∑ i = 0 N x i B i ) ( ∑ j = 0 N y i B j ) {\\displaystyle XY=\\left(\\sum _{i=0}^{N}{x_{i}B^{i}}\\right)\\left(\\sum _{j=0}^{N}{y_{i}B^{j}}\\right)} Because, for B k {\\displaystyle B^{k}} : c k = ∑ ( i , j ) : i + j = k a i b j = ∑ i = 0 k a i b k − i {\\displaystyle c_{k}=\\sum _{(i,j):i+j=k}{a_{i}b_{j}}=\\sum _{i=0}^{k}{a_{i}b_{k-i}}} ,\nwe have a convolution. By using FFT ( fast Fourier transform ), used in the original version rather than NTT ( Number-theoretic transform ), [ 7 ] with convolution rule; we get f ^ ( a ∗ b ) = f ^ ( ∑ i = 0 k a i b k − i ) = f ^ ( a ) ∙ f ^ ( b ) . {\\displaystyle {\\hat {f}}(a*b)={\\hat {f}}\\left(\\sum _{i=0}^{k}a_{i}b_{k-i}\\right)={\\hat {f}}(a)\\bullet {\\hat {f}}(b).}",
    "source_url": "https://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:33.849431",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:33.850424",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:33.850424",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Sch%C3%B6nhage%E2%80%93Strassen_algorithm_1_1749014493882_1991",
    "text": "That is; C k = a k ∙ b k {\\displaystyle C_{k}=a_{k}\\bullet b_{k}} , where C k {\\displaystyle C_{k}} is the corresponding coefficient in Fourier space. This can also be written as: fft ( a ∗ b ) = fft ( a ) ∙ fft ( b ) {\\displaystyle {\\text{fft}}(a*b)={\\text{fft}}(a)\\bullet {\\text{fft}}(b)} . We have the same coefficients due to linearity under the Fourier transform, and because these polynomials \nonly consist of one unique term per coefficient: f ^ ( x n ) = ( i 2 π ) n δ ( n ) {\\displaystyle {\\hat {f}}(x^{n})=\\left({\\frac {i}{2\\pi }}\\right)^{n}\\delta ^{(n)}} and f ^ ( a X ( ξ ) + b Y ( ξ ) ) = a X ^ ( ξ ) + b Y ^ ( ξ ) {\\displaystyle {\\hat {f}}(a\\,X(\\xi )+b\\,Y(\\xi )) =a\\,{\\hat {X}}(\\xi )+b\\,{\\hat {Y}}(\\xi )} Convolution rule: f ^ ( X ∗ Y ) = f ^ ( X ) ∙ f ^ ( Y ) {\\displaystyle {\\hat {f}}(X*Y)=\\ {\\hat {f}}(X)\\bullet {\\hat {f}}(Y)} We have reduced our convolution problem\nto product problem, through FFT.",
    "source_url": "https://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:33.882424",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:33.882424",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:33.882424",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Harvey-Hoeven_algorithm_1_1749014497690_3376",
    "text": "Grid method [ edit ] Main article: Grid method multiplication The grid method (or box method) is an introductory method for multiple-digit multiplication that is often taught to pupils at primary school or elementary school . It has been a standard part of the national primary school mathematics curriculum in England and Wales since the late 1990s. [ 3 ] Both factors are broken up (\"partitioned\") into their hundreds, tens and units parts, and the products of the parts are then calculated explicitly in a relatively simple multiplication-only stage, before these contributions are then totalled to give the final answer in a separate addition stage. The calculation 34 × 13, for example, could be computed using the grid: 300\n   40\n   90\n + 12\n ————\n  442 × 30 4 10 300 40 3 90 12 followed by addition to obtain 442, either in a single sum (see right), or through forming the row-by-row totals (300 + 40) + (90 + 12) = 340 + 102 = 442.",
    "source_url": "https://en.wikipedia.org/wiki/Harvey-Hoeven_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:37.690839",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:37.690839",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:37.690839",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Gauss%E2%80%93Legendre_algorithm_1_1749014503684_3771",
    "text": "{\\displaystyle a_{0}=1\\qquad b_{0}={\\frac {1}{\\sqrt {2}}}\\qquad p_{0}=1\\qquad t_{0}={\\frac {1}{4}}.} Repeat the following instructions until the difference between a n + 1 {\\displaystyle a_{n+1}} and b n + 1 {\\displaystyle b_{n+1}} is within the desired accuracy: a n + 1 = a n + b n 2 , b n + 1 = a n b n , p n + 1 = 2 p n , t n + 1 = t n − p n ( a n + 1 − a n ) 2 . {\\displaystyle {\\begin{aligned}a_{n+1}&={\\frac {a_{n}+b_{n}}{2}},\\\\\\\\b_{n+1}&={\\sqrt {a_{n}b_{n}}},\\\\\\\\p_{n+1}&=2p_{n},\\\\\\\\t_{n+1}&=t_{n}-p_{n}(a_{n+1}-a_{n})^{2}.\\\\\\end{aligned}}} π is then approximated as: π ≈ ( a n + 1 + b n + 1 ) 2 4 t n + 1 . { \\displaystyle \\pi \\approx {\\frac {(a_{n+1}+b_{n+1})^{2}}{4t_{n+1}}}.}",
    "source_url": "https://en.wikipedia.org/wiki/Gauss%E2%80%93Legendre_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:43.684657",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:43.684657",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:43.684657",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Gauss%E2%80%93Legendre_algorithm_1_1749014503739_9534",
    "text": "Mathematical background [ edit ] Limits of the arithmetic–geometric mean [ edit ] The arithmetic–geometric mean of two numbers, a 0 and b 0 , is found by calculating the limit of the sequences a n + 1 = a n + b n 2 , b n + 1 = a n b n , {\\displaystyle {\\begin{aligned}a_{n+1}&={\\frac {a_{n}+b_{n}}{2}},\\\\[6pt]b_{n+1}&={\\sqrt {a_{n}b_{n}}},\\end{aligned}}} which both converge to the same limit. If a 0 = 1 {\\displaystyle a_{0}=1} and b 0 = cos ⁡ φ {\\displaystyle b_{0}=\\cos \\varphi } then the limit is π 2 K ( sin ⁡ φ ) {\\textstyle {\\pi  \\over 2K(\\sin \\varphi )}} where K ( k ) {\\displaystyle K(k)} is the complete elliptic integral of the first kind K ( k ) = ∫ 0 π / 2 d θ 1 − k 2 sin 2 ⁡ θ . {\\displaystyle K(k)=\\int _{0}^{\\pi /2}{\\frac {d\\theta }{\\sqrt {1-k^{2}\\sin ^{2}\\theta }}}.} If c 0 = sin ⁡ φ {\\displaystyle c_{0}=\\sin \\varphi } , c i + 1 = a i − a i + 1 {\\displaystyle c_{i+1}=a_{i}-a_{i+1}} , then ∑ i = 0 ∞ 2",
    "source_url": "https://en.wikipedia.org/wiki/Gauss%E2%80%93Legendre_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:43.739935",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:43.739935",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:43.739935",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Strassen_algorithm_1_1749014509806_8638",
    "text": "× ( B 11 + B 12 ) ; M 7 = ( A 12 − A 22 ) × ( B 21 + B 22 ) , {\\displaystyle {\\begin{aligned}M_{1}&=(A_{11}+A_{22}){\\color {red}\\times }(B_{11}+B_{22});\\\\M_{2}&=(A_{21}+A_{22}){\\color {red}\\times }B_{11};\\\\M_{3}&=A_{11}{\\color {red}\\times }(B_{12}-B_{22});\\\\M_{4}&=A_{22}{\\color {red}\\times }(B_{21}-B_{11});\\\\M_{5}&=(A_{11}+A_{12}){\\color {red}\\times }B_{22};\\\\M_{6}&=(A_{21}-A_{11}){\\color {red}\\times }(B_{11}+B_{12});\\\\M_{7}&=(A_{12}-A_{22}){\\color {red}\\times }(B_{21}+B_{22}),\\\\\\end{aligned}}} using only 7 multiplications (one for each M k {\\displaystyle M_{k}} ) instead of 8. We may now express the C i j {\\displaystyle C_{ij}} in terms of M k {\\displaystyle M_{k}} : [ C 11 C 12 C 21 C 22 ] = [ M 1 + M 4 − M 5 + M 7 M 3 + M 5 M 2 + M 4 M 1 − M 2 + M 3 + M 6 ] . {\\displaystyle {\\begin{bmatrix}C_{11}&C_{12}\\\\C_{21}&C_{22}\\end{bmatrix}}={\\begin{bmatrix}M_{1}+M_{4}-M_{5}+M_{7}\\quad &M_{3}+M_{5}\\\\M_{2}+M_{4}\\quad &M_{1}-M_{2}+M_{3}+M_{6}\\end{bmatrix}}.}",
    "source_url": "https://en.wikipedia.org/wiki/Strassen_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:49.806914",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:49.806914",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:49.806914",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Strassen_algorithm_1_1749014509952_1245",
    "text": "[ 8 ] A 22 = A 12 − A 21 + A 22 ; B 22 = B 12 − B 21 + B 22 , {\\displaystyle {\\begin{aligned}A_{22}&=A_{12}-A_{21}+A_{22};\\\\B_{22}&=B_{12}-B_{21}+B_{22},\\end{aligned}}} t 1 = A 21 + A 22 ; t 2 = A 22 − A 12 ; t 3 = A 22 − A 11 ; t 4 = B 22 − B 11 ; t 5 = B 21 + B 22 ; t 6 = B 22 − B 12 , {\\displaystyle {\\begin{aligned}t_{1}&=A_{21}+A_{22};\\\\t_{2}&=A_{22}-A_{12};\\\\t_{3}&=A_{22}-A_{11};\\\\t_{4}&=B_{22}-B_{11};\\\\t_{5}&=B_{21}+B_{22};\\\\t_{6}&=B_{22}-B_{12},\\end{aligned}}} M 1",
    "source_url": "https://en.wikipedia.org/wiki/Strassen_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:49.952793",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:49.952793",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:49.952793",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Strassen_algorithm_1_1749014509979_8759",
    "text": "= A 11 × B 11 ; M 2 = A 12 × B 21 ; M 3 = A 21 × t 4 ; M 4 = A 22 × B 22 ; M 5 = t 1 × t 5 ; M 6 = t 2 × t 6 ; M 7 = t 3 × B 12 , {\\displaystyle {\\begin{aligned}M_{1}&=A_{11}{\\color {red}\\times }B_{11};\\\\M_{2}&=A_{12}{\\color {red}\\times }B_{21};\\\\M_{3}&=A_{21}{\\color {red}\\times }t_{4};\\\\M_{4}&=A_{22}{\\color {red}\\times }B_{22};\\\\M_{5}&=t_{1}{\\color {red}\\times }t_{5};\\\\M_{6}&=t_{2}{\\color {red}\\times }t_{6};\\\\M_{7}&=t_{3}{\\color {red}\\times }B_{12},\\end{aligned}}} C 11 = M 1 + M 2 ; C 12 = M 5 − M 7 ; C 21 = M 3 + M 6 ; C 22 = M 5 + M 6 − M 2 − M 4 . {\\displaystyle {\\begin{aligned}C_{11}&=M_{1}+M_{2};\\\\C_{12}&=M_{5}-M_{7};\\\\C_{21}&=M_{3}+M_{6};\\\\C_{22}&=M_{5}+M_{6}-M_{2}-M_{4}.\\\\\\end{aligned}}} C 12 = C 12 − C 22 ; C 21 = C 22 − C 21 , {\\displaystyle {\\begin{aligned}C_{12}&=C_{12}-C_{22};\\\\C_{21}&=C_{22}-C_{21},\\end{aligned}}} Asymptotic complexity [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Strassen_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:49.979800",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:49.979800",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:49.979800",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Coppersmith%E2%80%93Winograd_algorithm_1_1749014513894_8545",
    "text": "Recursive cases: If max( n , m , p ) = n , split A horizontally: C = ( A 1 A 2 ) B = ( A 1 B A 2 B ) {\\displaystyle C={\\begin{pmatrix}A_{1}\\\\A_{2}\\end{pmatrix}}{B}={\\begin{pmatrix}A_{1}B\\\\A_{2}B\\end{pmatrix}}} Else, if max( n , m , p ) = p , split B vertically: C = A ( B 1 B 2 ) = ( A B 1 A B 2 ) {\\displaystyle C=A{\\begin{pmatrix}B_{1}&B_{2}\\end{pmatrix}}={\\begin{pmatrix}AB_{1}&AB_{2}\\end{pmatrix}}} Otherwise, max( n , m , p ) = m .",
    "source_url": "https://en.wikipedia.org/wiki/Coppersmith%E2%80%93Winograd_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:53.894592",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:53.894592",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:53.894592",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Matrix_multiplication_algorithm&oldid=1293471221_1_1749014516329_4026",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Citation bot ( talk | contribs ) at 22:23, 1 June 2025 (Alter: journal, pages. Formatted dashes . | Use this bot . Report bugs . | Suggested by Abductive | Category:Wikipedia articles needing clarification from May 2025 | #UCB_Category 346/932) . The present address (URL) is a permanent link to this version. Revision as of 22:23, 1 June 2025 by Citation bot ( talk | contribs ) (Alter: jo",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Matrix_multiplication_algorithm&oldid=1293471221",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:56.329012",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:56.329012",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:56.329012",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Galactic_algorithm&oldid=1292589600_1_1749014519343_8994",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Singnear ( talk | contribs ) at 20:12, 27 May 2025 ( → Connectivity in undirected graphs : USTCONN is straightfowardly in NL since STCONN is. This must say RL instead, since that's the randomized analog of L. Indeed STCONN is in RL. The proof simply analyzes the probability of random walks reaching a vertex using spectral graph theory.) . The present address (URL) is a permanent link to ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Galactic_algorithm&oldid=1292589600",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:21:59.343899",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:21:59.343899",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:21:59.343899",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Faddeev-LeVerrier_algorithm_1_1749014523051_1629",
    "text": "c n = 1 ( k = 0 ) M k ≡ A M k − 1 + c n − k + 1 I c n − k = − 1 k t r ( A M k ) k = 1 , … , n . {\\displaystyle {\\begin{aligned}M_{0}&\\equiv 0&c_{n}&=1\\qquad &(k=0)\\\\M_{k}&\\equiv AM_{k-1}+c_{n-k+1}I\\qquad \\qquad &c_{n-k}&=-{\\frac {1}{k}}\\mathrm {tr} (AM_{k})\\qquad &k=1,\\ldots ,n~.\\end{aligned}}} Thus, M 1 = I , c n − 1 = − t r A = − c n t r A ; {\\displaystyle M_{1}=I~,\\quad c_{n-1}=-\\mathrm {tr} A=-c_{n}\\mathrm {tr} A;} M 2 = A − I t r A , c n − 2 = − 1 2 ( t r A 2 − ( t r A ) 2 ) = − 1 2 ( c n t r A 2 + c n − 1 t r A ) ; {\\displaystyle M_{2}=A-I\\mathrm {tr} A,\\quad c_{n-2}=-{\\frac {1}{2}}{\\Bigl (}\\mathrm {tr} A^{2}-(\\mathrm {tr} A)^{2}{\\Bigr )} =-{\\frac {1}{2}}(c_{n}\\mathrm {tr} A^{2}+c_{n-1}\\mathrm {tr} A);} M 3 = A 2 − A t r A − 1 2 ( t r A 2 − ( t r A ) 2 ) I , {\\displaystyle M_{3}=A^{2}-A\\mathrm {tr} A-{\\frac {1}{2}}{\\Bigl (}\\mathrm {tr} A^{2}-(\\mathrm {tr} A)^{2}{\\Bigr )}I,} c n − 3 = − 1 6 ( ( tr ⁡ A ) 3 − 3 tr ⁡ ( A 2 ) ( tr ⁡ A ) + 2 tr ⁡ ( A 3 ) ) = − 1 3 ( c n t r A 3 + c n",
    "source_url": "https://en.wikipedia.org/wiki/Faddeev-LeVerrier_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:03.051288",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:03.052290",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:03.052290",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Faddeev-LeVerrier_algorithm_1_1749014523088_5977",
    "text": "= − 1 3 ( c n t r A 3 + c n − 1 t r A 2 + c n − 2 t r A ) ; {\\displaystyle c_{n-3}=-{\\tfrac {1}{6}}{\\Bigl (}(\\operatorname {tr} A)^{3}-3\\operatorname {tr} (A^{2})(\\operatorname {tr} A)+2\\operatorname {tr} (A^{3}){\\Bigr )} =-{\\frac {1}{3}}(c_{n}\\mathrm {tr} A^{3}+c_{n-1}\\mathrm {tr} A^{2}+c_{n-2}\\mathrm {tr} A);} etc., [ 9 ] [ 10 ] ...; M m = ∑ k = 1 m c n − m + k A k − 1 , {\\displaystyle M_{m}=\\sum _{k=1}^{m}c_{n-m+k}A^{k-1}~,} c n − m = − 1 m ( c n t r A m + c n − 1 t r A m − 1 + . . . + c n − m + 1 t r A ) = − 1 m ∑ k = 1 m c n − m + k t r A k ; . . . {\\displaystyle c_{n-m}=-{\\frac {1}{m}}(c_{n}\\mathrm {tr} A^{m}+c_{n-1}\\mathrm {tr} A^{m-1}+...+c_{n-m+1}\\mathrm {tr} A)=-{\\frac {1}{m}}\\sum _{k=1}^{m}c_{n-m+k}\\mathrm {tr} A^{k}~;...} Observe A −1 = − M n /c 0 = (−1) n −1 M n /det A terminates the recursion at λ . This could be used to obtain the inverse or the determinant of A .",
    "source_url": "https://en.wikipedia.org/wiki/Faddeev-LeVerrier_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:03.088293",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:03.088293",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:03.088293",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Faddeev-LeVerrier_algorithm_1_1749014523119_6761",
    "text": "A terminates the recursion at λ . This could be used to obtain the inverse or the determinant of A . Derivation [ edit ] The proof  relies on the modes of the adjugate matrix , B k ≡ M n−k , the auxiliary matrices encountered. This matrix is defined by ( λ I − A ) B = I p A ( λ ) {\\displaystyle (\\lambda I-A)B=I~p_{A}(\\lambda )} and is thus proportional to the resolvent B = ( λ I − A ) − 1 I p A ( λ ) . {\\displaystyle B=(\\lambda I-A)^{-1}I~p_{A}(\\lambda )~.} It is evidently a matrix polynomial in λ of degree n−1 . Thus, B ≡ ∑ k = 0 n − 1 λ k B k = ∑ k = 0 n λ k M n − k , {\\displaystyle B\\equiv \\sum _{k=0}^{n-1}\\lambda ^{k}~B_{k}=\\sum _{k=0}^{n}\\lambda ^{k}~M_{n-k},} where one may define the harmless M 0 ≡0. Inserting the explicit polynomial forms into the defining equation for the adjugate, above, ∑ k = 0 n λ k + 1 M n − k − λ k ( A M n − k + c k I ) = 0 .",
    "source_url": "https://en.wikipedia.org/wiki/Faddeev-LeVerrier_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:03.119897",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:03.120907",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:03.120907",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Faddeev-LeVerrier_algorithm_1_1749014523154_8518",
    "text": "c k I ) = 0 . {\\displaystyle \\sum _{k=0}^{n}\\lambda ^{k+1}M_{n-k}-\\lambda ^{k}(AM_{n-k}+c_{k}I)=0~.} Now, at the highest order, the first term vanishes by M 0 =0; whereas  at the bottom order (constant in λ , from the defining equation of the adjugate, above), M n A = B 0 A = c 0 , {\\displaystyle M_{n}A=B_{0}A=c_{0}~,} so that shifting the dummy indices of the first term yields ∑ k = 1 n λ k ( M 1 + n − k − A M n − k + c k I ) = 0 , {\\displaystyle \\sum _{k=1}^{n}\\lambda ^{k}{\\Big (}M_{1+n-k}-AM_{n-k}+c_{k}I{\\Big )}=0~,} which thus dictates the recursion ∴ M m = A M m − 1 + c n − m + 1 I , {\\displaystyle \\therefore \\qquad M_{m}=AM_{m-1}+c_{n-m+1}I~,} for m =1,..., n . Note that ascending index amounts to descending in powers of λ , but the polynomial coefficients c are yet to be determined in terms of the M s and A . This can be easiest achieved through the following auxiliary equation (Hou, 1998), λ ∂ p A ( λ ) ∂ λ − n p = tr ⁡ A B .",
    "source_url": "https://en.wikipedia.org/wiki/Faddeev-LeVerrier_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:03.154405",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:03.154405",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:03.154405",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Faddeev-LeVerrier_algorithm_1_1749014523192_8307",
    "text": "= tr ⁡ A B . {\\displaystyle \\lambda {\\frac {\\partial p_{A}(\\lambda )}{\\partial \\lambda }}-np=\\operatorname {tr} AB~.} This is but the trace of the defining equation for B by dint of Jacobi's formula , ∂ p A ( λ ) ∂ λ = p A ( λ ) ∑ m = 0 ∞ λ − ( m + 1 ) tr ⁡ A m = p A ( λ ) tr ⁡ I λ I − A ≡ tr ⁡ B . {\\displaystyle {\\frac {\\partial p_{A}(\\lambda )}{\\partial \\lambda }}=p_{A}(\\lambda )\\sum _{m=0}^{\\infty }\\lambda ^{-(m+1)}\\operatorname {tr} A^{m}=p_{A}(\\lambda )~\\operatorname {tr} {\\frac {I}{\\lambda I-A}}\\equiv \\operatorname {tr} B~.} Inserting the polynomial mode forms in this auxiliary equation yields ∑ k = 1 n λ k ( k c k − n c k − tr ⁡ A M n − k ) = 0 , {\\displaystyle \\sum _{k=1}^{n}\\lambda ^{k}{\\Big (}kc_{k}-nc_{k}-\\operatorname {tr} AM_{n-k}{\\Big )}=0~,} so that ∑ m = 1 n − 1 λ n − m ( m c n − m + tr ⁡ A M m ) = 0 , {\\displaystyle \\sum _{m=1}^{n-1}\\lambda ^{n-m}{\\Big (}mc_{n-m}+\\operatorname {tr} AM_{m}{\\Big )} =0~,} and finally ∴ c n − m = − 1 m tr ⁡ A M m .",
    "source_url": "https://en.wikipedia.org/wiki/Faddeev-LeVerrier_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:03.192705",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:03.192705",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:03.192705",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Faddeev-LeVerrier_algorithm_1_1749014523283_6045",
    "text": "B k ( tr ⁡ A , − 1 ! tr ⁡ A 2 , 2 ! tr ⁡ A 3 , … , ( − 1 ) k − 1 ( k − 1 ) ! tr ⁡ A k ) . {\\displaystyle c_{n-k}={\\frac {(-1)^{n-k}}{k!}}{\\mathcal {B}}_{k}{\\Bigl (}\\operatorname {tr} A,-1!~\\operatorname {tr} A^{2},2!~\\operatorname {tr} A^{3},\\ldots ,(-1)^{k-1}(k-1)!~\\operatorname {tr} A^{k}{\\Bigr )}.} Example [ edit ] A = [ 3 1 5 3 3 1 4 6 4 ] {\\displaystyle {\\displaystyle A=\\left[{\\begin{array}{rrr}3&1&5\\\\3&3&1\\\\4&6&4\\end{array}}\\right]}} M 0 = [ 0 0 0 0 0 0 0 0 0 ] c 3 = 1 M 1 = [ 1 0 0 0 1 0 0 0 1 ] A M 1 = [ 3 1 5 3 3 1 4 6 4 ] c 2 = − 1 1 10 = − 10 M 2 = [ − 7 1 5 3 − 7 1 4 6 − 6 ] A M 2 = [ 2 26 − 14 − 8 − 12 12 6 − 14 2 ] c 1 = − 1 2 ( − 8 ) = 4 M 3 = [ 6 26 − 14 − 8 − 8 12 6 − 14 6 ]",
    "source_url": "https://en.wikipedia.org/wiki/Faddeev-LeVerrier_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:03.283233",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:03.283233",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:03.283233",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Faddeev-LeVerrier_algorithm_1_1749014523308_6681",
    "text": "A M 3 = [ 40 0 0 0 40 0 0 0 40 ] c 0 = − 1 3 120 = − 40 {\\displaystyle {\\displaystyle {\\begin{aligned}M_{0}&=\\left[{\\begin{array}{rrr}0&0&0\\\\0&0&0\\\\0&0&0\\end{array}}\\right]\\quad &&&c_{3}&&&&&=&1\\\\M_{\\mathbf {\\color {blue}1} }&=\\left[{\\begin{array}{rrr}1&0&0\\\\0&1&0\\\\0&0&1\\end{array}}\\right]&A~M_{1}&=\\left[{\\begin{array}{rrr}\\mathbf {\\color {red}3} &1&5\\\\3&\\mathbf {\\color {red}3} &1\\\\4&6&\\mathbf {\\color {red}4} \\end{array}}\\right]&c_{2}&&&=-{\\frac {1}{\\mathbf {\\color {blue}1} }}\\mathbf {\\color {red}10} &&=&-10\\\\M_{\\mathbf {\\color {blue}2} }&=\\left[{\\begin{array}{rrr}-7&1&5\\\\3&-7&1\\\\4&6&-6\\end{array}}\\right]\\qquad &A~M_{2}&=\\left[{\\begin{array}{rrr}\\mathbf {\\color {red}2} &26&-14\\\\-8&\\mathbf {\\color {red}-12} &12\\\\6&-14&\\mathbf {\\color {red}2} \\end{array}}\\right]\\qquad &c_{1}&&&=-{\\frac {1}{\\mathbf {\\color {blue}2} }}\\mathbf {\\color {red}(-8)} &&=&4\\\\M_{\\mathbf {\\color {blue}3} }&=\\left[{\\begin{array}{rrr}6&26&-14\\\\-8&-8&12\\\\6&-14&6\\end{array}}\\right]\\qquad",
    "source_url": "https://en.wikipedia.org/wiki/Faddeev-LeVerrier_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:03.308255",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:03.308255",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:03.308255",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Faddeev-LeVerrier_algorithm_1_1749014523321_3418",
    "text": "&A~M_{3}&=\\left[{\\begin{array}{rrr}\\mathbf {\\color {red}40} &0&0\\\\0&\\mathbf {\\color {red}40} &0\\\\0&0&\\mathbf {\\color {red}40} \\end{array}}\\right]\\qquad &c_{0}&&&=-{\\frac {1}{\\mathbf {\\color {blue}3} }}\\mathbf {\\color {red}120} &&=&-40\\end{aligned}}}} Furthermore, M 4 = A M 3 + c",
    "source_url": "https://en.wikipedia.org/wiki/Faddeev-LeVerrier_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:03.321116",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:03.321116",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:03.321116",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Faddeev–LeVerrier_algorithm&oldid=1230468285_1_1749014524387_1474",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by David Eppstein ( talk | contribs ) at 21:43, 22 June 2024 ( → See also : rm dead link) . The present address (URL) is a permanent link to this version. Revision as of 21:43, 22 June 2024 by David Eppstein ( talk | contribs ) ( → See also : rm dead link) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Urbain Le Verrier (1811–1877) The discoverer of Neptune ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Faddeev–LeVerrier_algorithm&oldid=1230468285",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:04.387698",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:04.387698",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:04.387698",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Samuelson-Berkowitz_algorithm_1_1749014525388_8260",
    "text": "Associate with A 0 {\\displaystyle A_{0}} the ( n + 1 ) × n {\\displaystyle (n+1)\\times n} Toeplitz matrix T 0 {\\displaystyle T_{0}} defined by T 0 = [ 1 − a 1 , 1 ] {\\displaystyle T_{0}=\\left[{\\begin{array}{c}1\\\\-a_{1,1}\\end{array}}\\right]} if A 0 {\\displaystyle A_{0}} is 1 × 1 {\\displaystyle 1\\times 1} , T 0 = [ 1 0 − a 1 , 1 1 − R C − a 1 , 1 ] {\\displaystyle T_{0}=\\left[{\\begin{array}{c c}1&0\\\\-a_{1,1}&1\\\\-RC&-a_{1,1}\\end{array}}\\right]} if A 0 {\\displaystyle A_{0}} is 2 × 2 {\\displaystyle 2\\times 2} ,\nand in general T 0 = [ 1 0 0 0",
    "source_url": "https://en.wikipedia.org/wiki/Samuelson-Berkowitz_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:05.388109",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:05.389109",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:05.389109",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_The_Art_of_Computer_Programming_1_1749014530504_5340",
    "text": "[ 1 ] When Knuth began the project in 1962, he originally conceived of it as a single book with twelve chapters. The first three volumes of what was then expected to be a seven-volume set were published in 1968, 1969, and 1973. Work began in earnest on Volume 4 in 1973, but was suspended in 1977 for work on typesetting prompted by the second edition of Volume 2. Writing of the final copy of Volume 4A began in longhand in 2001, and the first online pre-fascicle, 2A, appeared later in 2001. [ 2 ] The first published installment of Volume 4 appeared in paperback as Fascicle 2 in 2005. The hardback Volume 4A, combining Volume 4, Fascicles 0–4, was published in 2011. Volume 4, Fascicle 6 (\"Satisfiability\") was released in December 2015; Volume 4, Fascicle 5 (\"Mathematical Preliminaries Redux; Backtracking; Dancing Links\") was released in November 2019. Volume 4B consists of material evolved from Fascicles 5 and 6.",
    "source_url": "https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:10.504015",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:10.504015",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:10.504015",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=The_Art_of_Computer_Programming&oldid=1287314706_1_1749014533518_9192",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by 93.42.64.102 ( talk ) at 12:17, 25 April 2025 ( → Completed : Volume 1 in third Edition have MIX as abstract machine: MMIX only developed in fascicle 1 to become part of a Future edition of Volume 1) . The present address (URL) is a permanent link to this version. Revision as of 12:17, 25 April 2025 by 93.42.64.102 ( talk ) ( → Completed : Volume 1 in third Edition have MIX as abstract m",
    "source_url": "https://en.wikipedia.org/w/index.php?title=The_Art_of_Computer_Programming&oldid=1287314706",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:13.518020",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:13.519022",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:13.519022",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Number_theoretic_algorithms&oldid=975645017_1_1749014536053_6572",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Mike Peel ( talk | contribs ) at 17:30, 29 August 2020 (Change {{Commons}} to {{Commons category}}) . The present address (URL) is a permanent link to this version. Revision as of 17:30, 29 August 2020 by Mike Peel ( talk | contribs ) (Change {{Commons}} to {{Commons category}}) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Wikimedia Commons has med",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Number_theoretic_algorithms&oldid=975645017",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:16.053747",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:16.053747",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:16.053747",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Analysis_of_algorithms&oldid=936082453_1_1749014537953_6468",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Allforrous ( talk | contribs ) at 16:16, 16 January 2020 (Commonscat and Cat main templates.) . The present address (URL) is a permanent link to this version. Revision as of 16:16, 16 January 2020 by Allforrous ( talk | contribs ) (Commonscat and Cat main templates.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Wikimedia Commons has media related t",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Analysis_of_algorithms&oldid=936082453",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:17.953695",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:17.953695",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:17.953695",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bernstein%E2%80%93Vazirani_algorithm_1_1749014539290_5052",
    "text": "⟩ ⊗ n {\\displaystyle |0\\rangle ^{\\otimes n}} to get 1 2 n ∑ x = 0 2 n − 1 | x ⟩ . {\\displaystyle {\\frac {1}{\\sqrt {2^{n}}}}\\sum _{x=0}^{2^{n}-1}|x\\rangle .} Next, apply the oracle U f {\\displaystyle U_{f}} which transforms | x ⟩ → ( − 1 ) f ( x ) | x ⟩ {\\displaystyle |x\\rangle \\to (-1)^{f(x)}|x\\rangle } . This can be simulated through the standard oracle that transforms | b ⟩ | x ⟩ → | b ⊕ f ( x ) ⟩ | x ⟩ {\\displaystyle |b\\rangle |x\\rangle \\to |b\\oplus f(x)\\rangle |x\\rangle } by applying this oracle to | 0 ⟩ − | 1 ⟩ 2 | x ⟩ {\\displaystyle {\\frac {|0\\rangle -|1\\rangle }{\\sqrt {2}}}|x\\rangle } . ( ⊕ {\\displaystyle \\oplus } denotes addition mod two.) This transforms the superposition into 1 2 n ∑ x = 0 2 n − 1 ( − 1 ) f ( x ) | x ⟩ . {\\displaystyle {\\frac {1}{\\sqrt {2^{n}}}}\\sum _{x=0}^{2^{n}-1}(-1)^{f(x)}|x\\rangle .}",
    "source_url": "https://en.wikipedia.org/wiki/Bernstein%E2%80%93Vazirani_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:19.290065",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:19.290065",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:19.290065",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bernstein%E2%80%93Vazirani_algorithm_1_1749014539372_6135",
    "text": "x ⋅ y | y ⟩ = | s ⟩ {\\displaystyle |0\\rangle ^{n}\\xrightarrow {H^{\\otimes n}} {\\frac {1}{\\sqrt {2^{n}}}}\\sum _{x\\in \\{0,1\\}^{n}}|x\\rangle \\xrightarrow {U_{f}} {\\frac {1}{\\sqrt {2^{n}}}}\\sum _{x\\in \\{0,1\\}^{n}}(-1)^{f(x)}|x\\rangle \\xrightarrow {H^{\\otimes n}} {\\frac {1}{2^{n}}}\\sum _{x,y\\in \\{0,1\\}^{n}}(-1)^{f(x)+x\\cdot y}|y\\rangle =|s\\rangle } The reason that the last state is | s ⟩ {\\displaystyle |s\\rangle } is because, for a particular y {\\displaystyle y} , 1 2 n ∑ x ∈ { 0 , 1 } n ( − 1 ) f ( x ) + x ⋅ y = 1 2 n ∑ x ∈ { 0 , 1 } n ( − 1 ) x ⋅ s + x ⋅ y = 1 2 n ∑ x ∈ { 0 , 1 } n ( − 1 ) x ⋅ ( s ⊕ y ) = 1 if s ⊕ y = 0 → , 0 otherwise . {\\displaystyle {\\frac {1}{2^{n}}}\\sum _{x\\in \\{0,1\\}^{n}}(-1)^{f(x)+x\\cdot y}={\\frac {1}{2^{n}}}\\sum _{x\\in \\{0,1\\}^{n}}(-1)^{x\\cdot s+x\\cdot y}={\\frac {1}{2^{n}}}\\sum _{x\\in \\{0,1\\}^{n}}(-1)^{x\\cdot (s\\oplus y)}=1{\\text{ if }}s\\oplus y={\\vec {0}},\\,0{\\text{ otherwise}}.}",
    "source_url": "https://en.wikipedia.org/wiki/Bernstein%E2%80%93Vazirani_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:19.372142",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:19.373142",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:19.373142",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bernstein%E2%80%93Vazirani_algorithm_1_1749014539559_6286",
    "text": "transform Quantum optimization Quantum phase estimation Shor's Simon's VQE Quantum complexity theory BQP DQC1 EQP QIP QMA",
    "source_url": "https://en.wikipedia.org/wiki/Bernstein%E2%80%93Vazirani_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:19.559573",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:19.559573",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:19.559573",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Exact_algorithm&oldid=962596137_1_1749014544619_7216",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by InternetArchiveBot ( talk | contribs ) at 00:10, 15 June 2020 (Bluelink 1 book for verifiability (prndis)) #IABot (v2.0.1) ( GreenC bot ) . The present address (URL) is a permanent link to this version. Revision as of 00:10, 15 June 2020 by InternetArchiveBot ( talk | contribs ) (Bluelink 1 book for verifiability (prndis)) #IABot (v2.0.1) ( GreenC bot ) ( diff ) ← Previous revision | Lat",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Exact_algorithm&oldid=962596137",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:24.619030",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:24.619030",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:24.619030",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Non-constructive_algorithm_existence_proofs_1_1749014545725_7160",
    "text": "A sum query can relate to any number of indices from 1 to n . How many queries do you need? Obviously, n queries are always sufficient, because you can use n queries asking for the \"sum\" of a single element. But when d is sufficiently small, it is possible to do better. The general idea is as follows. Every query can be represented as a 1-by- n vector whose elements are all in the set {0,1}. The response to the query is just the dot product of the query vector by v . Every set of k queries can be represented by a k -by- n matrix over {0,1}; the set of responses is the product of the matrix by v . A matrix M is \"good\" if it enables us to uniquely identify v . This means that, for every vector v , the product M v is unique. A matrix M is \"bad\" if there are two different vectors, v and u , such that M v = M u . Using some algebra, it is possible to bound the number of \"bad\" matrices. The bound is a function of d and k .",
    "source_url": "https://en.wikipedia.org/wiki/Non-constructive_algorithm_existence_proofs",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:25.725169",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:25.725169",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:25.725169",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Non-constructive_algorithm_existence_proofs&oldid=1288851203_1_1749014546469_8509",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by CitationNeededLOL ( talk | contribs ) at 02:23, 5 May 2025 (Link suggestions feature: 2 links added.) . The present address (URL) is a permanent link to this version. Revision as of 02:23, 5 May 2025 by CitationNeededLOL ( talk | contribs ) (Link suggestions feature: 2 links added.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) The vast majority of posit",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Non-constructive_algorithm_existence_proofs&oldid=1288851203",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:26.469792",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:26.470793",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:26.470793",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Journal_of_Computer_and_System_Sciences&oldid=1285544380_1_1749014556165_5236",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Headbomb ( talk | contribs ) at 09:05, 14 April 2025 (Standardizing infobox journal with ( infoboxJournal.js )) . The present address (URL) is a permanent link to this version. Revision as of 09:05, 14 April 2025 by Headbomb ( talk | contribs ) (Standardizing infobox journal with ( infoboxJournal.js )) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Not to",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Journal_of_Computer_and_System_Sciences&oldid=1285544380",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:36.165424",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:36.166426",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:36.166426",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithmica&oldid=1151915051_1_1749014558397_3746",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Smasongarrison ( talk | contribs ) at 01:18, 27 April 2023 (Newspaper/Magazine/journal cleanup; General + punct fixes) . The present address (URL) is a permanent link to this version. Revision as of 01:18, 27 April 2023 by Smasongarrison ( talk | contribs ) (Newspaper/Magazine/journal cleanup; General + punct fixes) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision →",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithmica&oldid=1151915051",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:38.397685",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:38.398677",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:38.398677",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithmic_paradigm&oldid=1210574096_1_1749014561537_4273",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by David Eppstein ( talk | contribs ) at 08:18, 27 February 2024 (Reverted edit by 197.28.224.21 ( talk ) to last version by David Eppstein) . The present address (URL) is a permanent link to this version. Revision as of 08:18, 27 February 2024 by David Eppstein ( talk | contribs ) (Reverted edit by 197.28.224.21 ( talk ) to last version by David Eppstein) ( diff ) ← Previous revision | Lat",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithmic_paradigm&oldid=1210574096",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:41.537048",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:41.538048",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:41.538048",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Search_algorithms&oldid=1197080480_1_1749014565363_4302",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Fayenatic london ( talk | contribs ) at 07:25, 19 January 2024 (added Category:Problem solving using HotCat ) . The present address (URL) is a permanent link to this version. Revision as of 07:25, 19 January 2024 by Fayenatic london ( talk | contribs ) (added Category:Problem solving using HotCat ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Wikim",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Search_algorithms&oldid=1197080480",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:45.363306",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:45.364291",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:45.364291",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Portal:Computer_programming&oldid=1285333001_1_1749014570084_4862",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by HMSLavender ( talk | contribs ) at 02:46, 13 April 2025 ( Reverted edits by 2001:FB1:119:4398:1144:9891:D62:9654 ( talk ) to last version by Ormewood: unexplained content removal) . The present address (URL) is a permanent link to this version. Revision as of 02:46, 13 April 2025 by HMSLavender ( talk | contribs ) ( Reverted edits by 2001:FB1:119:4398:1144:9891:D62:9654 ( talk ) to last ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Portal:Computer_programming&oldid=1285333001",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:22:50.084151",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:22:50.084151",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:22:50.084151",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Parallel_algorithms_for_minimum_spanning_trees_1_1749014586333_4141",
    "text": "Jump to content From Wikipedia, the free encyclopedia In graph theory a minimum spanning tree (MST) T {\\displaystyle T} of a graph G = ( V , E ) {\\displaystyle G=(V,E)} with | V | = n {\\displaystyle |V|=n} and | E | = m {\\displaystyle |E|=m} is a tree subgraph of G {\\displaystyle G} that contains all of its vertices and is of minimum weight. MSTs are useful and versatile tools utilised in a wide variety of practical and theoretical fields. For example, a company looking to supply multiple stores",
    "source_url": "https://en.wikipedia.org/wiki/Parallel_algorithms_for_minimum_spanning_trees",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:23:06.333752",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:23:06.334752",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:23:06.334752",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Just_enough_operating_system_1_1749014603083_1980",
    "text": "This makes the appliance smaller, faster (to boot and to execute the particular application) and potentially more secure than an application running under a full general-purpose OS. Common implementations [ edit ] Typically, a JeOS will consist of the following: JeOS media (OS core [kernel, virtual drives, login]) OS minimum maintenance tools Minimum user space tools Packages repository (DVD or network-based) It is important to differentiate between true fully minimalized OS install profiles forced, for example, with security hardening tools or representing Recovery Console images and JeOS richer install profiles which are designed and built for wider audience usage, so VM / VA creators and their users can easily perform needed installation or configuration tasks.",
    "source_url": "https://en.wikipedia.org/wiki/Just_enough_operating_system",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:23:23.083432",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:23:23.083432",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:23:23.083432",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mobile_operating_system_1_1749014606983_9537",
    "text": "2012 [ edit ] May – Nokia releases the Nokia 808 PureView , [ 88 ] later confirmed (in January 2013) to be the last Symbian smartphone. [ 89 ] This phone was followed by a single last Symbian software update, \"Nokia Belle, Feature Pack 2\", later in 2012. [ 90 ] July Finnish start-up Jolla , formed by former Nokia employees, announces that MeeGo's community-driven successor Mer [ 91 ] would be the basis of their new Sailfish smartphone OS. [ 92 ] Mozilla announces that the project formerly named Boot to Gecko (which is built atop an Android Linux kernel using Android drivers and services; however it uses no Java-like code of Android) is now Firefox OS (since discontinued) and has several handset OEMs on board. August – Samsung announces they will not ship further phones using their Bada OS, instead focusing on Windows Phone 8 and Android. [ 93 ] September – Apple releases iOS 6 with the iPhone 5 . 2013",
    "source_url": "https://en.wikipedia.org/wiki/Mobile_operating_system",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:23:26.983060",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:23:26.983060",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:23:26.983060",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mobile_operating_system_1_1749014607014_7987",
    "text": "[ 99 ] Similar to Amazon.com 's Fire OS, it replaces Google's apps and services with ones from Nokia (such as HERE Maps , Nokia Xpress and MixRadio , and Nokia's own app store ) and Microsoft (such as Skype and Outlook ), with a user interface that mimics the Windows Phone UI. After the acquisition of Nokia's devices unit, Microsoft announced in July 2014 that no more Nokia X smartphones would be introduced, marking the end of the platform just a few months later. [ 100 ] August – The Samsung SM-Z9005 Z is the first phone released running Tizen, with v2.2.1 of the OS. [ 101 ] September Apple releases iOS 8 with the iPhone 6 and 6 Plus . BlackBerry releases BlackBerry 10 version 10.3 with integration with the Amazon Appstore November – Google releases Android 5.0 \"Lollipop\" 2015 [ edit ] February – Google releases Android 5.1 \"Lollipop\". April LG releases the LG Watch Urbane LTE smartwatch running \"LG Wearable Platform OS\" based on webOS.",
    "source_url": "https://en.wikipedia.org/wiki/Mobile_operating_system",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:23:27.014568",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:23:27.014568",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:23:27.014568",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mobile_operating_system_1_1749014607072_9920",
    "text": "Go, Micromax Bharat Go and Lava Z50. Google releases Android \"9\" as a developer preview. April Microsoft release Windows 10 Version 1803 \"April 2018 Update\" . May Huawei release LiteOS version 2.1. August Google releases Android 9.0 \"Pie\" . UBPorts released Ubuntu Touch OTA-14, upgrading the OS based on the Canonical's long-term support version of Ubuntu 16.04 LTS \"Xenial Xerus\" . Xiaomi officially introduces MIUI for POCO for their Poco series smartphone. Samsung officially introduces Tizen 4.0 with the release of Samsung Galaxy Watch series. September Apple releases iOS 12 with the iPhone XS and XS Max , and watchOS 5 with Apple Watch Series 4 . Huawei releases EMUI 9.0 . October Microsoft releases Windows 10 Version 1809 \"October 2018 Update\" . November Samsung announces the One UI as the latest version of the Samsung Experience UI . Amazon released Fire OS 6 to supported Fire HD devices. 2019",
    "source_url": "https://en.wikipedia.org/wiki/Mobile_operating_system",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:23:27.072887",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:23:27.072887",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:23:27.072887",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Category:Wikipedia_categories_named_after_operating_systems_1_1749014635683_7564",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is a maintenance category , used for maintenance of the Wikipedia project . It is not part of the encyclopedia and contains non-article pages , or groups articles by status rather than subject. Do not include this category in content categories. This is a container category . Due to its scope, it should only contain subcategories . This is a hidden category . It is not shown on its member pages, unless the corresponding user prefere",
    "source_url": "https://en.wikipedia.org/wiki/Category:Wikipedia_categories_named_after_operating_systems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:23:55.683559",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:23:55.683559",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:23:55.683559",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_John_von_Neumann_1_1749014641027_4135",
    "text": "Jump to content From Wikipedia, the free encyclopedia Hungarian and American mathematician and physicist (1903–1957) The native form of this personal name is Neumann János Lajos . This article uses Western name order when mentioning individuals.",
    "source_url": "https://en.wikipedia.org/wiki/John_von_Neumann",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:01.027735",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:01.027735",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:01.027735",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann_double_commutant_theorem_1_1749014649217_5286",
    "text": "Consider a self-adjoint unital subalgebra M of L ( H ) (this means that M contains the adjoints of its members, and the identity operator on H ). The theorem is equivalent to the combination of the following three statements: (i) cl W ( M ) ⊆ M ′′ (ii) cl S ( M ) ⊆ cl W ( M ) (iii) M ′′ ⊆ cl S ( M ) where the W and S subscripts stand for closures in the weak and strong operator topologies, respectively. Proof of (i) [ edit ] For any x and y in H , the map T → < Tx , y > is continuous in the weak operator topology, by its definition. Therefore, for any fixed operator O , so is the map T → ⟨ ( O T − T O ) x , y ⟩ = ⟨ T x , O ∗ y ⟩ − ⟨ T O x , y ⟩ {\\displaystyle T\\to \\langle (OT-TO)x,y\\rangle =\\langle Tx,O^{*}y\\rangle -\\langle TOx,y\\rangle } Let S be any subset of L ( H ) , and S ′ its commutant . For any operator T in S ′, this function is zero for all O in S . For any T not in S ′, it must be nonzero for some O in S and some x and y in H .",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann_double_commutant_theorem",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:09.217272",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:09.217272",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:09.217272",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann_double_commutant_theorem_1_1749014649252_3078",
    "text": "For any T not in S ′, it must be nonzero for some O in S and some x and y in H . By its continuity there is an open neighborhood of T for the weak operator topology on which it is nonzero, and which therefore is also not in S ′. Hence any commutant S ′ is closed in the weak operator topology. In particular, so is M ′′ ; since it contains M , it also contains its weak operator closure. Proof of (ii) [ edit ] This follows directly from the weak operator topology being coarser than the strong operator topology: for every point x in cl S ( M ) , every open neighborhood of x in the weak operator topology is also open in the strong operator topology and therefore contains a member of M ; therefore x is also a member of cl W ( M ) . Proof of (iii) [ edit ] Fix X ∈ M ′′ . We must show that X ∈ cl S ( M ) , i.e. for each h ∈ H and any ε > 0 , there exists T in M with || Xh − Th || < ε . Fix h in H . The cyclic subspace M h = { Mh : M ∈ M } is invariant under the action of any T in M .",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann_double_commutant_theorem",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:09.252782",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:09.252782",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:09.252782",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann_double_commutant_theorem_1_1749014649277_1093",
    "text": "Fix h in H . The cyclic subspace M h = { Mh : M ∈ M } is invariant under the action of any T in M . Its closure cl( M h ) in the norm of H is a closed linear subspace, with corresponding orthogonal projection P : H → cl( M h ) in L ( H ). In fact, this P is in M ′ , as we now show. Lemma. P ∈ M ′ . Proof. Fix x ∈ H . As Px ∈ cl( M h ) , it is the limit of a sequence O n h with O n in M . For any T ∈ M , TO n h is also in M h , and by the continuity of T , this sequence converges to TPx . So TPx ∈ cl( M h ) , and hence PTPx = TPx . Since x was arbitrary, we have PTP = TP for all T in M .",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann_double_commutant_theorem",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:09.277781",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:09.277781",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:09.277781",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Abelian_von_Neumann_algebra_1_1749014656043_2319",
    "text": "Theorem . [ 3 ] Suppose μ, ν are standard measures on X , Y and H = ∫ X ⊕ H x d μ ( x ) , K = ∫ Y ⊕ K y d ν ( y ) {\\displaystyle H=\\int _{X}^{\\oplus }H_{x}d\\mu (x),\\quad K=\\int _{Y}^{\\oplus }K_{y}d\\nu (y)} for measurable families of Hilbert spaces { H x } x ∈ X , { K y } y ∈ Y . If U : H → K is a unitary such that U L ∞ ( X , μ ) U ∗ = L ∞ ( Y , ν ) {\\displaystyle U\\,L^{\\infty }(X,\\mu )\\,U^{*}=L^{\\infty }(Y,\\nu )} then there is an almost everywhere defined Borel point transformation η : X → Y as in the previous theorem and a measurable family { U x } x ∈ X of unitary operators U x : H x → K η ( x ) {\\displaystyle U_{x}:H_{x}\\rightarrow K_{\\eta (x)}} such that U ( ∫ X ⊕ ψ x d μ ( x ) ) = ∫ Y ⊕ d ( μ ∘ η − 1 ) d ν ( y ) U η − 1 ( y ) ( ψ η − 1 ( y ) )",
    "source_url": "https://en.wikipedia.org/wiki/Abelian_von_Neumann_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:16.043332",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:16.043332",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:16.043332",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Morgenstern_utility_theorem_1_1749014660409_8130",
    "text": "Jump to content From Wikipedia, the free encyclopedia Any individual whose preferences satisfy four axioms has a utility function Part of the behavioral sciences Economics Outline Index Glossary Economists Principles of Economics Tools and methodology Economic theory Mathematical modeling Game theory Rational choice Cognitive science ( Behavioral ) Economic equilibrium Empirical methods Experimental National accounts Econometrics Time series Spatial Prescriptive and policy Welfare analysis Socia",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Morgenstern_utility_theorem",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:20.409282",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:20.409282",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:20.409282",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Geometric_Folding_Algorithms&oldid=1267520922_1_1749014661288_2428",
    "text": "The book is organized into three sections, on linkages, origami, and polyhedra. [ 1 ] [ 2 ] Topics in the section on linkages include\nthe Peaucellier–Lipkin linkage for converting rotary motion into linear motion, [ 4 ] Kempe's universality theorem that any algebraic curve can be traced out by a linkage, [ 1 ] [ 4 ] the existence of linkages for angle trisection , [ 1 ] and the carpenter's rule problem on straightening two-dimensional polygonal chains . [ 4 ] This part of the book also includes applications to motion planning for robotic arms , and to protein folding . [ 1 ] [ 2 ] The second section of the book concerns the mathematics of paper folding , and mathematical origami .",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Geometric_Folding_Algorithms&oldid=1267520922",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:21.288111",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:21.288111",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:21.288111",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Geometric_Folding_Algorithms&oldid=1267520922_1_1749014661309_8439",
    "text": "It includes the NP-completeness of testing flat foldability, [ 2 ] the problem of map folding (determining whether a pattern of mountain and valley folds forming a square grid can be folded flat), [ 2 ] [ 4 ] the work of Robert J. Lang using tree structures and circle packing to automate the design of origami folding patterns, [ 2 ] [ 4 ] the fold-and-cut theorem according to which any polygon can be constructed by folding a piece of paper and then making a single straight cut, [ 2 ] [ 4 ] origami-based angle trisection, [ 4 ] rigid origami , [ 2 ] and the work of David A. Huffman on curved folds.",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Geometric_Folding_Algorithms&oldid=1267520922",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:21.309111",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:21.309111",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:21.309111",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schoof%27s_algorithm_1_1749014668691_2708",
    "text": "In order to count points on an elliptic curve, we compute the cardinality of E ( F q ) {\\displaystyle E(\\mathbb {F} _{q})} . Schoof's approach to computing the cardinality # E ( F q ) {\\displaystyle \\#E(\\mathbb {F} _{q})} makes use of Hasse's theorem on elliptic curves along with the Chinese remainder theorem and division polynomials . Hasse's theorem [ edit ] Main article: Hasse's theorem on elliptic curves Hasse's theorem states that if E / F q {\\displaystyle E/\\mathbb {F} _{q}} is an elliptic curve over the finite field F q {\\displaystyle \\mathbb {F} _{q}} , then # E ( F q ) {\\displaystyle \\#E(\\mathbb {F} _{q})} satisfies ∣ q + 1 − # E ( F q ) ∣ ≤ 2 q . {\\displaystyle \\mid q+1-\\#E(\\mathbb {F} _{q})\\mid \\leq 2{\\sqrt {q}}.} This powerful result, given by Hasse in 1934, simplifies our problem by narrowing down # E ( F q ) {\\displaystyle \\#E(\\mathbb {F} _{q})} to a finite (albeit large) set of possibilities.",
    "source_url": "https://en.wikipedia.org/wiki/Schoof%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:28.691595",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:28.691595",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:28.691595",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schoof%27s_algorithm_1_1749014668727_5891",
    "text": "Defining t {\\displaystyle t} to be q + 1 − # E ( F q ) {\\displaystyle q+1-\\#E(\\mathbb {F} _{q})} , and making use of this result, we now have that computing the value of t {\\displaystyle t} modulo N {\\displaystyle N} where N > 4 q {\\displaystyle N>4{\\sqrt {q}}} , is sufficient for determining t {\\displaystyle t} , and thus # E ( F q ) {\\displaystyle \\#E(\\mathbb {F} _{q})} . While there is no efficient way to compute t ( mod N ) {\\displaystyle t{\\pmod {N}}} directly for general N {\\displaystyle N} , it is possible to compute t ( mod l ) {\\displaystyle t{\\pmod {l}}} for l {\\displaystyle l} a small prime, rather efficiently. We choose S = { l 1 , l 2 , . . . , l r } {\\displaystyle S=\\{l_{1},l_{2},...,l_{r}\\}} to be a set of distinct primes such that ∏ l i = N > 4 q {\\displaystyle \\prod l_{i}=N>4{\\sqrt {q}}} . Given t ( mod l i ) {\\displaystyle t{\\pmod {l_{i}}}} for all l i ∈ S {\\displaystyle l_{i}\\in S} , the Chinese remainder theorem allows us to compute t ( mod N )",
    "source_url": "https://en.wikipedia.org/wiki/Schoof%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:28.727035",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:28.727035",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:28.727035",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schoof%27s_algorithm_1_1749014668791_8963",
    "text": "The Frobenius endomorphism [ edit ] Given the elliptic curve E {\\displaystyle E} defined over F q {\\displaystyle \\mathbb {F} _{q}} we consider points on E {\\displaystyle E} over F ¯ q {\\displaystyle {\\bar {\\mathbb {F} }}_{q}} , the algebraic closure of F q {\\displaystyle \\mathbb {F} _{q}} ; i.e. we allow points with coordinates in F ¯ q {\\displaystyle {\\bar {\\mathbb {F} }}_{q}} . The Frobenius endomorphism of F ¯ q {\\displaystyle {\\bar {\\mathbb {F} }}_{q}} over F q {\\displaystyle \\mathbb {F} _{q}} extends to the elliptic curve by ϕ : ( x , y ) ↦ ( x q , y q ) {\\displaystyle \\phi :(x,y)\\mapsto (x^{q},y^{q})} . This map is the identity on E ( F q ) {\\displaystyle E(\\mathbb {F} _{q})} and one can extend it to the point at infinity O {\\displaystyle O} , making it a group morphism from E ( F ¯ q ) {\\displaystyle E({\\bar {\\mathbb {F} }}_{q})} to itself.",
    "source_url": "https://en.wikipedia.org/wiki/Schoof%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:28.791252",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:28.792253",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:28.792253",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schoof%27s_algorithm_1_1749014668895_1433",
    "text": "If a point ( x , y ) {\\displaystyle (x,y)} is in the l {\\displaystyle l} - torsion subgroup E [ l ] = { P ∈ E ( F q ¯ ) ∣ l P = O } {\\displaystyle E[l]=\\{P\\in E({\\bar {\\mathbb {F} _{q}}})\\mid lP=O\\}} , then q P = q ¯ P {\\displaystyle qP={\\bar {q}}P} where q ¯ {\\displaystyle {\\bar {q}}} is the unique integer such that q ≡ q ¯ ( mod l ) {\\displaystyle q\\equiv {\\bar {q}}{\\pmod {l}}} and ∣ q ¯ ∣ < l / 2 {\\displaystyle \\mid {\\bar {q}}\\mid <l/2} . Note that ϕ ( O ) = O {\\displaystyle \\phi (O)=O} and that for any integer r {\\displaystyle r} we have r ϕ ( P ) = ϕ ( r P ) {\\displaystyle r\\phi (P)=\\phi (rP)} . Thus ϕ ( P ) {\\displaystyle \\phi (P)} will have the same order as P {\\displaystyle P} . Thus for ( x , y ) {\\displaystyle (x,y)} belonging to E [ l ] {\\displaystyle E[l]} , we also have t ( x q , y q ) = t ¯ ( x q , y q ) {\\displaystyle t(x^{q},y^{q})={\\bar {t}}(x^{q},y^{q})} if t ≡ t ¯ ( mod l ) {\\displaystyle t\\equiv {\\bar {t}}{\\pmod {l}}} .",
    "source_url": "https://en.wikipedia.org/wiki/Schoof%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:28.895918",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:28.895918",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:28.895918",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schoof%27s_algorithm_1_1749014668971_8699",
    "text": "This means in particular that the degree of X and Y defined via ( X ( x , y ) , Y ( x , y ) ) : = ( x q 2 , y q 2 ) + q ¯ ( x , y ) {\\displaystyle (X(x,y),Y(x,y)):=(x^{q^{2}},y^{q^{2}})+{\\bar {q}}(x,y)} is at most 1 in y and at most ( l 2 − 3 ) / 2 {\\displaystyle (l^{2}-3)/2} in x . The scalar multiplication q ¯ ( x , y ) {\\displaystyle {\\bar {q}}(x,y)} can be done either by double-and-add methods or by using the q ¯ {\\displaystyle {\\bar {q}}} th division polynomial. The latter approach gives: q ¯ ( x , y ) = ( x q ¯ , y q ¯ ) = ( x − ψ q ¯ − 1 ψ q ¯ + 1 ψ q ¯ 2 , ψ 2 q ¯ 2 ψ q ¯ 4 ) {\\displaystyle {\\bar {q}}(x,y)=(x_{\\bar {q}},y_{\\bar {q}})=\\left(x-{\\frac {\\psi _{{\\bar {q}}-1}\\psi _{{\\bar {q}}+1}}{\\psi _{\\bar {q}}^{2}}},{\\frac {\\psi _{2{\\bar {q}}}}{2\\psi _{\\bar {q}}^{4}}}\\right)} where ψ n {\\displaystyle \\psi _{n}} is the n th division polynomial. Note that y q ¯ / y {\\displaystyle y_{\\bar {q}}/y} is a function in x only and denote it by θ ( x ) {\\displaystyle \\theta (x)} .",
    "source_url": "https://en.wikipedia.org/wiki/Schoof%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:28.971401",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:28.971401",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:28.971401",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Schoof%27s_algorithm&oldid=1292506210_1_1749014670770_5710",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by GreenC bot ( talk | contribs ) at 09:12, 27 May 2025 (Reformat 3 archive links. Wayback Medic 2.5 per WP:URLREQ#citeftp ) . The present address (URL) is a permanent link to this version. Revision as of 09:12, 27 May 2025 by GreenC bot ( talk | contribs ) (Reformat 3 archive links. Wayback Medic 2.5 per WP:URLREQ#citeftp ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revi",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Schoof%27s_algorithm&oldid=1292506210",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:30.770202",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:30.770202",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:30.770202",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schoof%E2%80%93Elkies%E2%80%93Atkin_algorithm_1_1749014672601_1976",
    "text": "Cayley–Bacharach theorem Conic section Cramer's paradox Cubic plane curve Fermat curve Genus–degree formula Hilbert's sixteenth problem Nagata's conjecture on curves Plücker formula Quartic plane curve Real plane curve Riemann surfaces Belyi's theorem Bring's curve Bolza surface Compact Riemann surface Dessin d'enfant Differential of the first",
    "source_url": "https://en.wikipedia.org/wiki/Schoof%E2%80%93Elkies%E2%80%93Atkin_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:32.601861",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:32.601861",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:32.601861",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schoof%E2%80%93Elkies%E2%80%93Atkin_algorithm_1_1749014672618_1024",
    "text": "Klein quartic Riemann's existence theorem Riemann–Roch theorem Teichmüller space Torelli theorem Constructions Dual curve Polar curve Smooth completion Structure of curves Divisors on curves Abel–Jacobi map Brill–Noether theory Clifford's theorem on special divisors Gonality of an algebraic curve Jacobian variety Riemann–Roch theorem Weierstrass point Weil reciprocity law Moduli ELSV formula Gromov–Witten invariant Hodge bundle Moduli of algebraic curves Stable curve Morphisms Hasse–Witt matrix Riemann–Hurwitz formula Prym variety Weber's theorem (Algebraic curves)",
    "source_url": "https://en.wikipedia.org/wiki/Schoof%E2%80%93Elkies%E2%80%93Atkin_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:32.618569",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:32.619611",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:32.619611",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithm_characterizations_1_1749014678839_6948",
    "text": "By means of what Couturat (1914) called a \"sort of logical piano [,] ... the equalities which represent the premises ... are \"played\" on a keyboard like that of a typewriter. ... When all the premises have been \"played\", the panel shows only those constituents whose sum is equal to 1, that is, ... its logical whole. This mechanical method has the advantage over VENN's geometrical method...\" (Couturat 1914:75). For his part John Venn , a logician contemporary to Jevons, was less than thrilled, opining that \"it does not seem to me that any contrivances at present known or likely to be discovered really deserve the name of logical machines\" (italics added, Venn 1881:120).",
    "source_url": "https://en.wikipedia.org/wiki/Algorithm_characterizations",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:38.839304",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:38.839304",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:38.839304",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Division_algorithm_1_1749014683125_6044",
    "text": "Step 2 :  Take i=3 (one less than the number of bits in N) Step 3 :  R=00 (left shifted by 1) Step 4 :  R=01 (setting R(0) to N(i)) Step 5 :  R < D, so skip statement Step 2 :  Set i=2 Step 3 :  R=010 Step 4 :  R=011 Step 5 :  R < D, statement skipped Step 2 : Set i=1 Step 3 :  R=0110 Step 4 : R=0110 Step 5 :  R>=D, statement entered Step 5b :  R=10 (R−D) Step 5c :  Q=10 (setting Q(i) to 1) Step 2 : Set i=0 Step 3 :  R=100 Step 4 :  R=100 Step 5 :  R>=D, statement entered Step 5b :  R=0 (R−D) Step 5c :  Q=11 (setting Q(i) to 1) end Q=11 2 (3 10 ) and R=0.",
    "source_url": "https://en.wikipedia.org/wiki/Division_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:43.125565",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:43.126558",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:43.126558",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Empirical_algorithmics&oldid=1194883679_1_1749014692346_8412",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Sir Ibee ( talk | contribs ) at 06:41, 11 January 2024 (Open access status updates in citations with OAbot #oabot) . The present address (URL) is a permanent link to this version. Revision as of 06:41, 11 January 2024 by Sir Ibee ( talk | contribs ) (Open access status updates in citations with OAbot #oabot) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Empirical_algorithmics&oldid=1194883679",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:52.346259",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:52.346259",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:52.346259",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Profiling_(computer_programming)_1_1749014693794_8140",
    "text": "/* ------------ source------------------------- count */             \n0001 IF X = \"A\"                      0055\n0002                THEN DO                       \n0003                    ADD 1 to XCOUNT         0032\n0004                ELSE\n0005 IF X = \"B\"                      0055 A stream of recorded events (a trace ) For sequential programs, a summary profile is usually sufficient, but performance problems in parallel programs (waiting for messages or synchronization issues) often depend on the time relationship of events, thus requiring a full trace to get an understanding of what is happening. The size of a (full) trace is linear to the program's instruction path length , making it somewhat impractical. A trace may therefore be initiated at one point in a program and terminated at another point to limit the output. An ongoing interaction with the hypervisor (continuous or periodic monitoring via on-screen display for instance)",
    "source_url": "https://en.wikipedia.org/wiki/Profiling_(computer_programming)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:53.794720",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:53.794720",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:53.794720",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Profiling_(computer_programming)_1_1749014694215_4645",
    "text": "In 1982 gprof extended the concept to a complete call graph analysis. [ 8 ] In 1994, Amitabh Srivastava and Alan Eustace of Digital Equipment Corporation published a paper describing ATOM [ 9 ] (Analysis Tools with OM). The ATOM platform converts a program into its own profiler: at compile time , it inserts code into the program to be analyzed. That inserted code outputs analysis data. This technique - modifying a program to analyze itself - is known as \" instrumentation \". In 2004 both the gprof and ATOM papers appeared on the list of the 50 most influential PLDI papers for the 20-year period ending in 1999. [ 10 ] Profiler types based on output [ edit ] Flat profiler [ edit ] Flat profilers compute the average call times, from the calls, and do not break down the call times based on the callee or the context. Call-graph profiler [ edit ] Call graph profilers [ 8 ] show the call times, and frequencies of the functions, and also the call-chains involved based on the callee.",
    "source_url": "https://en.wikipedia.org/wiki/Profiling_(computer_programming)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:54.215825",
    "symbols_found_in_chunk": 2,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:54.215825",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:54.216421",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Profiling_(computer_programming)&oldid=1286436094_1_1749014695067_4871",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Widefox ( talk | contribs ) at 22:10, 19 April 2025 ( → top : bold alt article name per MOS) . The present address (URL) is a permanent link to this version. Revision as of 22:10, 19 April 2025 by Widefox ( talk | contribs ) ( → top : bold alt article name per MOS) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Measuring the time or resources used by a se",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Profiling_(computer_programming)&oldid=1286436094",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:55.067921",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:55.067921",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:55.067921",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Recursive_algorithm_1_1749014697364_7428",
    "text": "Indirect recursion [ edit ] Main article: Mutual recursion Most basic examples of recursion, and most of the examples presented here, demonstrate direct recursion , in which a function calls itself. Indirect recursion occurs when a function is called not by itself but by another function that it called (either directly or indirectly). For example, if f calls f, that is direct recursion, but if f calls g which calls f, then that is indirect recursion of f. Chains of three or more functions are possible; for example, function 1 calls function 2, function 2 calls function 3, and function 3 calls function 1 again. Indirect recursion is also called mutual recursion , which is a more symmetric term, though this is simply a difference of emphasis, not a different notion.",
    "source_url": "https://en.wikipedia.org/wiki/Recursive_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:24:57.364580",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:24:57.364580",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:24:57.364580",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Graph_exploration_algorithm_1_1749014700697_1808",
    "text": "This section needs expansion . You can help by adding to it . ( December 2016 ) A universal traversal sequence is a sequence of instructions comprising a graph traversal for any regular graph with a set number of vertices and for any starting vertex. A probabilistic proof was used by Aleliunas et al. to show that there exists a universal traversal sequence with number of instructions proportional to O ( n 5 ) for any regular graph with n vertices. [ 6 ] The steps specified in the sequence are relative to the current node, not absolute. For example, if the current node is v j , and v j has d neighbors, then the traversal sequence will specify the next node to visit, v j +1 , as the i th neighbor of v j , where 1 ≤ i ≤ d . See also [ edit ] External memory graph traversal References [ edit ] ^ Rosenkrantz, Daniel J.; Stearns, Richard E.; Lewis, II, Philip M. (1977). \"An Analysis of Several Heuristics for the Traveling Salesman Problem\". SIAM Journal on Computing . 6 (3): 563– 581.",
    "source_url": "https://en.wikipedia.org/wiki/Graph_exploration_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:00.697872",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:00.697872",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:00.697872",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simplex_algorithm_1_1749014703670_5299",
    "text": "The possible results from Phase II are either an optimum basic feasible solution or an infinite edge on which the objective function is unbounded above. [ 13 ] [ 14 ] [ 15 ] Standard form [ edit ] The transformation of a linear program to one in standard form may be accomplished as follows. [ 16 ] First, for each variable with a lower bound other than 0, a new variable is introduced representing the difference between the variable and bound. The original variable can then be eliminated by substitution. For example, given the constraint x 1 ≥ 5 {\\displaystyle x_{1}\\geq 5} a new variable, y 1 {\\displaystyle y_{1}} , is introduced with y 1 = x 1 − 5 x 1 = y 1 + 5 {\\displaystyle {\\begin{aligned}y_{1}=x_{1}-5\\\\x_{1}=y_{1}+5\\end{aligned}}} The second equation may be used to eliminate x 1 {\\displaystyle x_{1}} from the linear program. In this way, all lower bound constraints may be changed to non-negativity restrictions.",
    "source_url": "https://en.wikipedia.org/wiki/Simplex_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:03.670356",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:03.670356",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:03.670356",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simplex_algorithm_1_1749014703727_9964",
    "text": "Third, each unrestricted variable is eliminated from the linear program. This can be done in two ways, one is by solving for the variable in one of the equations in which it appears and then eliminating the variable by substitution. The other is to replace the variable with the difference of two restricted variables. For example, if z 1 {\\displaystyle z_{1}} is unrestricted then write z 1 = z 1 + − z 1 − z 1 + , z 1 − ≥ 0 {\\displaystyle {\\begin{aligned}&z_{1}=z_{1}^{+}-z_{1}^{-}\\\\&z_{1}^{+},\\,z_{1}^{-}\\geq 0\\end{aligned}}} The equation may be used to eliminate z 1 {\\displaystyle z_{1}} from the linear program. When this process is complete the feasible region will be in the form A x = b , ∀ x i ≥ 0 {\\displaystyle \\mathbf {A} \\mathbf {x} =\\mathbf {b} ,\\,\\forall \\ x_{i}\\geq 0} It is also useful to assume that the rank of A {\\displaystyle \\mathbf {A} } is the number of rows.",
    "source_url": "https://en.wikipedia.org/wiki/Simplex_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:03.727448",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:03.727448",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:03.727448",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Heuristic_algorithm_1_1749014707981_8244",
    "text": "A heuristic method can accomplish its task by using search trees. However, instead of generating all possible solution branches, a heuristic selects branches more likely to produce outcomes than other branches. It is selective at each decision point, picking branches that are more likely to produce solutions. [ 5 ] Antivirus software [ edit ] Antivirus software often uses heuristic rules for detecting viruses and other forms of malware . Heuristic scanning looks for code and/or behavioral patterns common to a class or family of viruses, with different sets of rules for different viruses. If a file or executing process is found to contain matching code patterns and/or to be performing that set of activities, then the scanner infers that the file is infected. The most advanced part of behavior-based heuristic scanning is that it can work against highly randomized self-modifying/mutating ( polymorphic ) viruses that cannot be easily detected by simpler string scanning methods.",
    "source_url": "https://en.wikipedia.org/wiki/Heuristic_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:07.981602",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:07.981602",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:07.981602",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Heuristic_algorithm_1_1749014708008_1337",
    "text": "Heuristic scanning has the potential to detect future viruses without requiring the virus to be first detected somewhere else, submitted to the virus scanner developer, analyzed, and a detection update for the scanner provided to the scanner's users. Pitfalls [ edit ] Some heuristics have a strong underlying theory; they are either derived in a top-down manner from the theory or are arrived at based on either experimental or real world data. Others are just rules of thumb based on real-world observation or experience without even a glimpse of theory. The latter are exposed to a larger number of pitfalls. When a heuristic is reused in various contexts because it has been seen to \"work\" in one context, without having been mathematically proven to meet a given set of requirements, it is possible that the current data set does not necessarily represent future data sets (see: overfitting ) and that purported \"solutions\" turn out to be akin to noise.",
    "source_url": "https://en.wikipedia.org/wiki/Heuristic_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:08.008110",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:08.008110",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:08.008110",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Heuristic_algorithm_1_1749014708039_9302",
    "text": "Statistical analysis can be conducted when employing heuristics to estimate the probability of incorrect outcomes. To use a heuristic for solving a search problem or a knapsack problem , it is necessary to check that the heuristic is admissible . Given a heuristic function h ( v i , v g ) {\\displaystyle h(v_{i},v_{g})} meant to approximate the true optimal distance d ⋆ ( v i , v g ) {\\displaystyle d^{\\star }(v_{i},v_{g})} to the goal node v g {\\displaystyle v_{g}} in a directed graph G {\\displaystyle G} containing n {\\displaystyle n} total nodes or vertices labeled v 0 , v 1 , ⋯ , v n {\\displaystyle v_{0},v_{1},\\cdots ,v_{n}} , \"admissible\" means roughly that the heuristic underestimates the cost to the goal or formally that h ( v i , v g ) ≤ d ⋆ ( v i , v g ) {\\displaystyle h(v_{i},v_{g})\\leq d^{\\star }(v_{i},v_{g})} for all ( v i , v g ) {\\displaystyle (v_{i},v_{g})} where i , g ∈ [ 0 , 1 , . . . , n ] {\\displaystyle {i,g}\\in [0,1,...,n]} .",
    "source_url": "https://en.wikipedia.org/wiki/Heuristic_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:08.039677",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:08.039677",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:08.039677",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithm_aversion&oldid=1291719852_1_1749014712215_3360",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 23:45, 22 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 23:45, 22 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Bias",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithm_aversion&oldid=1291719852",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:12.215143",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:12.215143",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:12.215143",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithmic_bias_1_1749014718823_3193",
    "text": "Segregation age racial Jim Crow laws Nuremberg Laws Segregation academy religious sexual in Islam Social exclusion Sodomy law State atheism State religion Ugly law Voter suppression White Australia policy Countermeasures Affirmative action Anti-discrimination law Anti-racism Audit study Autism rights movement Blind audition Constitutional colorblindness Cross-sex friendship Cultural assimilation Cultural pluralism Diversity, equity, and inclusion Diversity training Empowerment Fat acceptance movement Feminism Fighting Discrimination Golden Rule Hate speech laws by country Human rights Intersex human rights Korenizatsiia LGBTQ rights Music in the movement against apartheid Nonviolence Racial integration Reappropriation Rock Against Sexism Self-determination Social integration Toleration Transgender rights movement Universal suffrage Women's rights Related topics Allophilia Alterity Amatonormativity Bias Cisnormativity Civil liberties Criminalization of homosexuality Dehumanization",
    "source_url": "https://en.wikipedia.org/wiki/Algorithmic_bias",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:18.823220",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:18.823220",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:18.823220",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Open-source_software_1_1749014721686_5763",
    "text": "Jump to content Checked From Wikipedia, the free encyclopedia This is the latest accepted revision , reviewed on 22 May 2025 . Software licensed to ensure source code usage rights Open-source software shares similarities with free software and is part of the broader term free and open-source software . For broader coverage of this topic, see open-source-software movement . A screenshot of Manjaro Linux running the Cinnamon desktop environment , Firefox accessing Wikipedia which uses MediaWiki , ",
    "source_url": "https://en.wikipedia.org/wiki/Open-source_software",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:21.686682",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:21.686682",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:21.686682",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithmic_bias&oldid=1293240757_1_1749014722118_7089",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by HudecEmil ( talk | contribs ) at 15:41, 31 May 2025 (crosslink) . The present address (URL) is a permanent link to this version. Revision as of 15:41, 31 May 2025 by HudecEmil ( talk | contribs ) (crosslink) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Technological phenomenon with social implications A flow chart showing the decisions made by a recomme",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithmic_bias&oldid=1293240757",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:22.118127",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:22.118127",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:22.118127",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithmic_entities_1_1749014726101_8915",
    "text": "[ 4 ] In some countries there have been made some exceptions to this in the form of the granting of an environmental personhood to rivers, waterfalls, forests and mountains. In the past, some form of personhood also existed for certain religious constructions such as churches and temples. [ 5 ] Certain countries – albeit for publicity purposes – have shown willingness to grant (some form of) legal personhood to robots . On the 27th of October 2017, Saudi Arabia became to first country in the world to grant citizenship to a robot when it gave “Sophia” a passport. In the same year, official residency status was granted to a chatbot named “Shibuya Mirai” in Tokyo, Japan. [ 6 ] The general consensus is that AI in any case cannot be regarded as a natural or real person and that granting AI (legal) personhood at this stage is unwanted from a societal point of view.",
    "source_url": "https://en.wikipedia.org/wiki/Algorithmic_entities",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:26.101365",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:26.102359",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:26.102359",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithmic_entities&oldid=1274932913_1_1749014726899_6699",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by GreenC bot ( talk | contribs ) at 02:42, 10 February 2025 (Move 1 url. Wayback Medic 2.5 per WP:URLREQ#carnegieendowment.org ) . The present address (URL) is a permanent link to this version. Revision as of 02:42, 10 February 2025 by GreenC bot ( talk | contribs ) (Move 1 url. Wayback Medic 2.5 per WP:URLREQ#carnegieendowment.org ) ( diff ) ← Previous revision | Latest revision (diff) | ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithmic_entities&oldid=1274932913",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:26.899634",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:26.899634",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:26.899634",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithmic_technique_1_1749014730880_1825",
    "text": "This approach is broad, and includes depth-first search , breadth-first search , tree traversal , and many specific variations that may include local optimizations and excluding search spaces that can be determined to be non-optimum or not possible. These techniques may be used to solve a variety of problems including shortest path and constraint satisfaction problems. [ 8 ] Greedy [ edit ] A greedy approach begins by evaluating one possible outcome from the set of possible outcomes, and then searches locally for an improvement on that outcome. When a local improvement is found, it will repeat the process and again search locally for additional improvements near this local optimum. A greedy technique is generally simple to implement, and these series of decisions can be used to find local optimums depending on where the search began. However, greedy techniques may not identify the global optimum across the entire set of possible outcomes., [ 9 ] Heuristic [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Algorithmic_technique",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:30.880663",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:30.881671",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:30.881671",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithmic_technique&oldid=1290996077_1_1749014731551_6050",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by 103.138.125.195 ( talk ) at 12:12, 18 May 2025 (Renamed \"Window Sliding to Sliding Window\", Added \"Two Pointers\" and \"Backtracking\".) . The present address (URL) is a permanent link to this version. Revision as of 12:12, 18 May 2025 by 103.138.125.195 ( talk ) (Renamed \"Window Sliding to Sliding Window\", Added \"Two Pointers\" and \"Backtracking\".) ( diff ) ← Previous revision | Latest revi",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithmic_technique&oldid=1290996077",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:31.551576",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:31.551576",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:31.551576",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Government_by_algorithm&oldid=1292105079_1_1749014738856_9829",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by SchlurcherBot ( talk | contribs ) at 06:43, 25 May 2025 (Bot: http → https) . The present address (URL) is a permanent link to this version. Revision as of 06:43, 25 May 2025 by SchlurcherBot ( talk | contribs ) (Bot: http → https) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Alternative form of government or social ordering Not to be confused with Regu",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Government_by_algorithm&oldid=1292105079",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:38.856798",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:38.857799",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:38.857799",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=List_of_algorithm_general_topics&oldid=1245681809_1_1749014741202_7243",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Shashvat Verma ( talk | contribs ) at 13:50, 14 September 2024 ( → top : the name is self sufficient no need of descriptions) . The present address (URL) is a permanent link to this version. Revision as of 13:50, 14 September 2024 by Shashvat Verma ( talk | contribs ) ( → top : the name is self sufficient no need of descriptions) ( diff ) ← Previous revision | Latest revision (diff) | Ne",
    "source_url": "https://en.wikipedia.org/w/index.php?title=List_of_algorithm_general_topics&oldid=1245681809",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:41.202525",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:41.202525",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:41.202525",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Regulation_of_algorithms&oldid=1292061849_1_1749014745343_9609",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 00:28, 25 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 00:28, 25 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Gove",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Regulation_of_algorithms&oldid=1292061849",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:45.343664",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:45.343664",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:45.343664",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Domain_reduction_algorithm_1_1749014755468_9526",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article is an orphan , as no other articles link to it . Please introduce links to this page from related articles ; try the Find link tool for suggestions. ( August 2024 ) This article relies largely or entirely on a single source . Relevant discussion may be found on the talk page . Please ",
    "source_url": "https://en.wikipedia.org/wiki/Domain_reduction_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:55.468514",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:55.469417",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:55.469417",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lion_algorithm_1_1749014757134_9704",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article may be too technical for most readers to understand . Please help improve it to make it understandable to non-experts , without removing the technical details. ( February 2021 ) ( Learn how and when to remove this message ) This article may be confusing or unclear to readers . Please ",
    "source_url": "https://en.wikipedia.org/wiki/Lion_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:57.134686",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:57.134686",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:57.134686",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Medical_algorithm_1_1749014758135_6228",
    "text": "Jump to content From Wikipedia, the free encyclopedia You can help expand this article with text translated from the corresponding article in Russian . (September 2015) Click [show] for important translation instructions. Machine translation, like DeepL or Google Translate , is a useful starting point for translations, but translators must revise errors as necessary and confirm that the translation is accurate, rather than simply copy-pasting machine-translated text into the English Wikipedia. D",
    "source_url": "https://en.wikipedia.org/wiki/Medical_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:58.135346",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:58.135346",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:58.135346",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shapiro%E2%80%93Senapathy_algorithm_1_1749014758898_9580",
    "text": "Jump to content From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article contains promotional content . Please help improve it by removing promotional language and inappropriate external links , and by adding encyclopedic text written from a neutral point of view . ( April 2020 ) ( Learn how and when to remove this message ) This article is written like a ",
    "source_url": "https://en.wikipedia.org/wiki/Shapiro%E2%80%93Senapathy_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:58.898777",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:58.899777",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:58.899777",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Algorithms&oldid=1213126206_1_1749014759842_2448",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by John of Reading ( talk | contribs ) at 07:11, 11 March 2024 (Reverted 1 edit by 180.251.144.227 ( talk ) to last revision by Conan) . The present address (URL) is a permanent link to this version. Revision as of 07:11, 11 March 2024 by John of Reading ( talk | contribs ) (Reverted 1 edit by 180.251.144.227 ( talk ) to last revision by Conan) ( diff ) ← Previous revision | Latest rev",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Algorithms&oldid=1213126206",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:25:59.842610",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:25:59.842610",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:25:59.842610",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Computer_system_1_1749014767670_9753",
    "text": "The earliest counting device was most likely a form of tally stick . Later record keeping aids throughout the Fertile Crescent included calculi (clay spheres, cones, etc.) which represented counts of items, likely livestock or grains, sealed in hollow unbaked clay containers. [ a ] [ 4 ] The use of counting rods is one example. The Chinese suanpan ( 算盘 ). The number represented on this abacus is 6,302,715,408. The abacus was initially used for arithmetic tasks. The Roman abacus was developed from devices used in Babylonia as early as 2400 BCE. Since then, many other forms of reckoning boards or tables have been invented. In a medieval European counting house , a checkered cloth would be placed on a table, and markers moved around on it according to certain rules, as an aid to calculating sums of money. [ 5 ] The Antikythera mechanism , dating back to ancient Greece circa 200–80 BCE, is an early analog computing device.",
    "source_url": "https://en.wikipedia.org/wiki/Computer_system",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:07.670312",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:07.670312",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:07.670312",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Computer_system_1_1749014767863_1651",
    "text": "[ 51 ] This design was also all-electronic and used about 300 vacuum tubes, with capacitors fixed in a mechanically rotating drum for memory. [ 52 ] Colossus , the first electronic digital programmable computing device, was used to break German ciphers during World War II. It is seen here in use at Bletchley Park in 1943. During World War II, the British code-breakers at Bletchley Park achieved a number of successes at breaking encrypted German military communications. The German encryption machine, Enigma , was first attacked with the help of the electro-mechanical bombes which were often run by women. [ 53 ] [ 54 ] To crack the more sophisticated German Lorenz SZ 40/42 machine, used for high-level Army communications, Max Newman and his colleagues commissioned Flowers to build the Colossus . [ 52 ] He spent eleven months from early February 1943 designing and building the first Colossus.",
    "source_url": "https://en.wikipedia.org/wiki/Computer_system",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:07.864022",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:07.864022",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:07.864022",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Glossary_of_computer_hardware_terms&oldid=1273333346_1_1749014775548_8407",
    "text": "cache eviction Freeing up data from within a cache to make room for new cache entries to be allocated ; controlled by a cache replacement policy . Caused by a cache miss whilst a cache is already full. cache hit Finding data in a local cache , preventing the need to search for that resource in a more distant location (or to repeat a calculation). cache line A small block of memory within a cache ; the granularity of allocation, refills, eviction; typically 32–128 bytes in size. cache miss Not finding data in a local cache , requiring use of the cache policy to allocate and fill this data, and possibly performing evicting other data to make room. cache thrashing A pathological situation where access in a cache cause cyclical cache misses by evicting data that is needed in the near future. cache ways The number of potential cache lines in an associative cache that specific physical addresses can be mapped to; higher values reduce potential collisions in allocation.",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Glossary_of_computer_hardware_terms&oldid=1273333346",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:15.548145",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:15.548145",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:15.548145",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Knuth%E2%80%93Bendix_completion_algorithm_1_1749014778073_5125",
    "text": "Nr Lhs Rhs Source 1: * f(X,0) = X initial(\"GROUP.lop\", at_line_9_column_1) 2: * f(X,i(X)) = 0 initial(\"GROUP.lop\", at_line_12_column_1) 3: * f(f(X,Y),Z) = f(X,f(Y,Z)) initial(\"GROUP.lop\", at_line_15_column_1) 5: f(X,Y) = f(X,f(0,Y)) pm(3,1) 6: f(X,f(Y,i(f(X,Y)))) = 0 pm(2,3) 7: f(0,Y) = f(X,f(i(X),Y)) pm(3,2) 27: f(X,0) = f(0,i(i(X))) pm(7,2) 36: X = f(0,i(i(X))) rw(27,1) 46: f(X,Y) = f(X,i(i(Y))) pm(5,36) 52: * f(0,X) = X rw(36,46) 60: * i(0) = 0 pm(2,52) 63: i(i(X)) = f(0,X) pm(46,52) 64: * f(X,f(i(X),Y)) = Y rw(7,52) 67: * i(i(X)) = X rw(63,52) 74: * f(i(X),X) = 0 pm(2,67) 79: f(0,Y) = f(i(X),f(X,Y)) pm(3,74) 83: * Y = f(i(X),f(X,Y)) rw(79,52) 134: f(i(X),0) = f(Y,i(f(X,Y))) pm(83,6) 151: i(X) = f(Y,i(f(X,Y))) rw(134,1) 165: * f(i(X),i(Y)) = i(f(Y,X)) pm(83,151) See also Word problem (mathematics) for another presentation of this example.",
    "source_url": "https://en.wikipedia.org/wiki/Knuth%E2%80%93Bendix_completion_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:18.073253",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:18.073253",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:18.073253",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Knuth%E2%80%93Bendix_completion_algorithm_1_1749014778569_7009",
    "text": "For each relation P i = Q i {\\displaystyle P_{i}=Q_{i}} in R {\\displaystyle R} , suppose Q i < P i {\\displaystyle Q_{i}<P_{i}} . Thus we begin with the set of reductions P i → Q i {\\displaystyle P_{i}\\rightarrow Q_{i}} . First, if any relation P i = Q i {\\displaystyle P_{i}=Q_{i}} can be reduced, replace P i {\\displaystyle P_{i}} and Q i {\\displaystyle Q_{i}} with the reductions. Next, we add more reductions (that is, rewriting rules) to eliminate possible exceptions of confluence. Suppose that P i {\\displaystyle P_{i}} and P j {\\displaystyle P_{j}} overlap. Case 1: either the prefix of P i {\\displaystyle P_{i}} equals the suffix of P j {\\displaystyle P_{j}} , or vice versa. In the former case, we can write P i = B C {\\displaystyle P_{i}=BC} and P j = A B {\\displaystyle P_{j}=AB} ; in the latter case, P i = A B {\\displaystyle P_{i}=AB} and P j = B C {\\displaystyle P_{j}=BC} . Case 2: either P i {\\displaystyle P_{i}} is completely contained in (surrounded by)",
    "source_url": "https://en.wikipedia.org/wiki/Knuth%E2%80%93Bendix_completion_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:18.569332",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:18.569332",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:18.569332",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Root-finding_algorithm_1_1749014781542_6307",
    "text": "Therefore, the number of function evaluations required for finding an ε -approximate root is log 2 ⁡ b − a ε {\\displaystyle \\log _{2}{\\frac {b-a}{\\varepsilon }}} . Other methods, under appropriate conditions, can gain accuracy faster. False position ( regula falsi ) [ edit ] The false position method , also called the regula falsi method, is similar to the bisection method, but instead of using bisection search's middle of the interval it uses the x -intercept of the line that connects the plotted function values at the endpoints of the interval, that is c = a f ( b ) − b f ( a ) f ( b ) − f ( a ) . {\\displaystyle c={\\frac {af(b)-bf(a)}{f(b)-f(a)}}.} False position is similar to the secant method , except that, instead of retaining the last two points, it makes sure to keep one point on either side of the root. The false position method can be faster than the bisection method and will never diverge like the secant method.",
    "source_url": "https://en.wikipedia.org/wiki/Root-finding_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:21.542494",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:21.542990",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:21.542990",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Root-finding_algorithm_1_1749014781569_4376",
    "text": "However, it may fail to converge in some naive implementations due to roundoff errors that may lead to a wrong sign for f ( c ) . Typically, this may occur if the derivative of f is large in the neighborhood of the root. Interpolation [ edit ] Many root-finding processes work by interpolation . This consists in using the last computed approximate values of the root for approximating the function by a polynomial of low degree, which takes the same values at these approximate roots. Then the root of the polynomial is computed and used as a new approximate value of the root of the function, and the process is iterated. Interpolating two values yields a line: a polynomial of degree one. This is the basis of the secant method . Regula falsi is also an interpolation method that interpolates two points at a time but it differs from the secant method by using two points that are not necessarily the last two computed points. Three values define a parabolic curve: a quadratic function .",
    "source_url": "https://en.wikipedia.org/wiki/Root-finding_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:21.569013",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:21.570007",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:21.570007",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Root-finding_algorithm_1_1749014781656_2624",
    "text": "A generalization of the secant method in higher dimensions is Broyden's method . Steffensen's method [ edit ] If we use a polynomial fit to remove the quadratic part of the finite difference used in the secant method, so that it better approximates the derivative, we obtain Steffensen's method , which has quadratic convergence, and whose behavior (both good and bad) is essentially the same as Newton's method but does not require a derivative. Fixed point iteration method [ edit ] We can use the fixed-point iteration to find the root of a function. Given a function f ( x ) {\\displaystyle f(x)} which we have set to zero to find the root ( f ( x ) = 0 {\\displaystyle f(x)=0} ), we rewrite the equation in terms of x {\\displaystyle x} so that f ( x ) = 0 {\\displaystyle f(x)=0} becomes x = g ( x ) {\\displaystyle x=g(x)} (note, there are often many g ( x ) {\\displaystyle g(x)} functions for each f ( x ) = 0 {\\displaystyle f(x)=0} function).",
    "source_url": "https://en.wikipedia.org/wiki/Root-finding_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:21.656979",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:21.657972",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:21.657972",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Root-finding_algorithm_1_1749014781693_7664",
    "text": "Next, we relabel each side of the equation as x n + 1 = g ( x n ) {\\displaystyle x_{n+1}=g(x_{n})} so that we can perform the iteration. Next, we pick a value for x 1 {\\displaystyle x_{1}} and perform the iteration until it converges towards a root of the function. If the iteration converges, it will converge to a root. The iteration will only converge if | g ′ ( r o o t ) | < 1 {\\displaystyle |g'(root)|<1} . As an example of converting f ( x ) = 0 {\\displaystyle f(x)=0} to x = g ( x ) {\\displaystyle x=g(x)} , if given the function f ( x ) = x 2 + x − 1 {\\displaystyle f(x)=x^{2}+x-1} , we will rewrite it as one of the following equations. x n + 1 = ( 1 / x n ) − 1 {\\displaystyle x_{n+1}=(1/x_{n})-1} , x n + 1 = 1 / ( x n + 1 ) {\\displaystyle x_{n+1}=1/(x_{n}+1)} , x n + 1 = 1 − x n 2 {\\displaystyle x_{n+1}=1-x_{n}^{2}} , x n + 1 = x n 2 + 2 x n − 1 {\\displaystyle x_{n+1}=x_{n}^{2}+2x_{n}-1} , or x n + 1 = ± 1 − x n {\\displaystyle x_{n+1}=\\pm {\\sqrt {1-x_{n}}}} .",
    "source_url": "https://en.wikipedia.org/wiki/Root-finding_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:21.693625",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:21.693625",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:21.693625",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Root-finding_algorithm&oldid=1288739474_1_1749014783837_1774",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by 2001:818:eb41:fc00:9ea2:28f2:c537:1780 ( talk ) at 15:10, 4 May 2025 ( → Bracketing methods : not notable; this method has some well-known issues and there has been little research on it;) . The present address (URL) is a permanent link to this version. Revision as of 15:10, 4 May 2025 by 2001:818:eb41:fc00:9ea2:28f2:c537:1780 ( talk ) ( → Bracketing methods : not notable; this method ha",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Root-finding_algorithm&oldid=1288739474",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:23.837013",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:23.837013",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:23.837013",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Risch_algorithm_1_1749014785464_8246",
    "text": "Jump to content From Wikipedia, the free encyclopedia Method for evaluating indefinite integrals Part of a series of articles about Calculus ∫ a b f ′ ( t )",
    "source_url": "https://en.wikipedia.org/wiki/Risch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:25.464219",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:25.464219",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:25.464219",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Risch_algorithm_1_1749014785485_4306",
    "text": "d t = f ( b ) − f ( a ) {\\displaystyle \\int _{a}^{b}f'(t)\\,dt=f(b)-f(a)} Fundamental theorem Limits Continuity Rolle's theorem Mean value theorem Inverse function theorem Differential Definitions Derivative ( generalizations ) Differential infinitesimal of a function total Concepts Differentiation notation Second derivative Implicit differentiation Logarithmic differentiation Related rates Taylor's theorem Rules and identities Sum Product Chain Power Quotient L'Hôpital's rule Inverse General Leibniz Faà di Bruno's formula Reynolds Integral Lists of integrals Integral transform Leibniz integral rule Definitions Antiderivative Integral ( improper ) Riemann integral Lebesgue integration Contour integration Integral of inverse functions Integration by Parts Discs Cylindrical shells Substitution ( trigonometric , tangent half-angle , Euler ) Euler's formula Partial fractions ( Heaviside's method )",
    "source_url": "https://en.wikipedia.org/wiki/Risch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:25.485216",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:25.485216",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:25.485216",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Risch_algorithm&oldid=1292293391_1_1749014786995_3979",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 06:22, 26 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 06:22, 26 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Meth",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Risch_algorithm&oldid=1292293391",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:26.995866",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:26.995866",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:26.995866",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Risch%E2%80%93Norman_algorithm_1_1749014788608_8972",
    "text": "d t = f ( b ) − f ( a ) {\\displaystyle \\int _{a}^{b}f'(t)\\,dt=f(b)-f(a)} Fundamental theorem Limits Continuity Rolle's theorem Mean value theorem Inverse function theorem Differential Definitions Derivative ( generalizations ) Differential infinitesimal of a function total Concepts Differentiation notation Second derivative Implicit differentiation Logarithmic differentiation Related rates Taylor's theorem Rules and identities Sum Product Chain Power Quotient L'Hôpital's rule Inverse General Leibniz Faà di Bruno's formula Reynolds Integral Lists of integrals Integral transform Leibniz integral rule Definitions Antiderivative Integral ( improper ) Riemann integral Lebesgue integration Contour integration Integral of inverse functions Integration by Parts Discs Cylindrical shells Substitution ( trigonometric , tangent half-angle , Euler ) Euler's formula Partial fractions ( Heaviside's method )",
    "source_url": "https://en.wikipedia.org/wiki/Risch%E2%80%93Norman_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:28.608290",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:28.609282",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:28.609282",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Gosper%27s_algorithm_1_1749014791319_4493",
    "text": "Notes [ edit ] ^ Petkovšek, Marko ; Wilf, Herbert ; Zeilberger, Doron (1996). A = B . A K Peters Ltd. ISBN 1-56881-063-6 . Archived from the original on 2019-07-11 . Retrieved 2020-01-10 . [1] [2] [3] References [ edit ] Gosper, Jr., Ralph William \"Bill\" (January 1978) [1977-09-26]. \"Decision procedure for indefinite hypergeometric summation\" (PDF) . Proceedings of the National Academy of Sciences of the United States of America . Mathematics. 75 (1). Xerox, Palo Alto Research Center, Palo Alto, California, USA: 40– 42. Bibcode : 1978PNAS...75...40G . doi : 10.1073/pnas.75.1.40 . PMC 411178 . PMID 16592483 . Archived (PDF) from the original on 2019-04-12 . Retrieved 2020-01-10 .",
    "source_url": "https://en.wikipedia.org/wiki/Gosper%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:31.319789",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:31.319789",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:31.319789",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Gosper%27s_algorithm&oldid=1204023960_1_1749014792654_5516",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by David Eppstein ( talk | contribs ) at 07:22, 6 February 2024 (fix broken citation) . The present address (URL) is a permanent link to this version. Revision as of 07:22, 6 February 2024 by David Eppstein ( talk | contribs ) (fix broken citation) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Summation method for hypergeometric terms In mathematics , Gospe",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Gosper%27s_algorithm&oldid=1204023960",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:32.654748",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:32.654748",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:32.654748",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Berlekamp%27s_algorithm_1_1749014794377_9903",
    "text": "= g n − 1 x n − 1 + g n − 2 x n − 2 + … + g 0 , {\\displaystyle g(x)=g_{n-1}x^{n-1}+g_{n-2}x^{n-2}+\\ldots +g_{0},\\,} we may associate the row vector: g = ( g 0 , g 1 , … , g n − 1 ) . {\\displaystyle g=(g_{0},g_{1},\\ldots ,g_{n-1}).\\,} It is relatively straightforward to see that the row vector g Q {\\displaystyle g{\\mathcal {Q}}} corresponds, in the same way, to the reduction of g ( x ) q {\\displaystyle g(x)^{q}} modulo f ( x ) {\\displaystyle f(x)} . Consequently, a polynomial g ( x ) ∈ R {\\displaystyle g(x)\\in R} is in the Berlekamp subalgebra if and only if g ( Q − I ) = 0 {\\displaystyle g({\\mathcal {Q}}-I)=0} (where I {\\displaystyle I} is the n × n {\\displaystyle n\\times n} identity matrix ), i.e. if and only if it is in the null space of Q − I {\\displaystyle {\\mathcal {Q}}-I} .",
    "source_url": "https://en.wikipedia.org/wiki/Berlekamp%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:34.377710",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:34.377710",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:34.377710",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Berlekamp%27s_algorithm_1_1749014794452_1987",
    "text": "{\\textstyle \\mathbb {F} _{p}[y]/(g(y))} . We can assume that f ( x ) ∈ F q [ x ] {\\textstyle f(x)\\in \\mathbb {F} _{q}[x]} is square free, by taking all possible pth roots and then computing the gcd with its derivative. Now, suppose that f ( x ) = f 1 ( x ) … f n ( x ) {\\textstyle f(x)=f_{1}(x)\\ldots f_{n}(x)} is the factorization into irreducibles. Then we have a ring isomorphism, σ : F q [ x ] / ( f ( x ) ) → ∏ i F q [ x ] / ( f i ( x ) ) {\\textstyle \\sigma :\\mathbb {F} _{q}[x]/(f(x))\\to \\prod _{i}\\mathbb {F} _{q}[x]/(f_{i}(x))} , given by the Chinese remainder theorem. The crucial observation is that the Frobenius automorphism x → x p {\\textstyle x\\to x^{p}} commutes with σ {\\textstyle \\sigma } , so that if we denote Fix p ( R ) = { f ∈ R : f p = f } {\\textstyle {\\text{Fix}}_{p}(R)=\\{f\\in R:f^{p}=f\\}} , then σ {\\textstyle \\sigma } restricts to an isomorphism Fix p ( F q [ x ] / ( f ( x ) ) )",
    "source_url": "https://en.wikipedia.org/wiki/Berlekamp%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:34.452360",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:34.452360",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:34.452360",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Berlekamp%27s_algorithm_1_1749014794481_8027",
    "text": "→ ∏ i = 1 n Fix p ( F q [ x ] / ( f i ( x ) ) ) {\\textstyle {\\text{Fix}}_{p}(\\mathbb {F} _{q}[x]/(f(x)))\\to \\prod _{i=1}^{n}{\\text{Fix}}_{p}(\\mathbb {F} _{q}[x]/(f_{i}(x)))} . By finite field theory, Fix p ( F q [ x ] / ( f i ( x ) ) ) {\\textstyle {\\text{Fix}}_{p}(\\mathbb {F} _{q}[x]/(f_{i}(x)))} is always the prime subfield of that field extension. Thus, Fix p ( F q [ x ] / ( f ( x ) ) ) {\\textstyle {\\text{Fix}}_{p}(\\mathbb {F} _{q}[x]/(f(x)))} has p {\\textstyle p} elements if and only if f ( x ) {\\textstyle f(x)} is irreducible. Moreover, we can use the fact that the Frobenius automorphism is F p {\\textstyle \\mathbb {F} _{p}} -linear to calculate the fixed set. That is, we note that Fix p ( F q [ x ] / ( f ( x ) ) )",
    "source_url": "https://en.wikipedia.org/wiki/Berlekamp%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:34.481720",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:34.481720",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:34.481720",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Berlekamp%27s_algorithm_1_1749014794563_2950",
    "text": "Fix p ( F q [ x ] / ( f ( x ) ) ) ∖ F p {\\textstyle g\\in {\\text{Fix}}_{p}(\\mathbb {F} _{q}[x]/(f(x)))\\setminus \\mathbb {F} _{p}} , and then observe that for some a ∈ F p {\\textstyle a\\in \\mathbb {F} _{p}} there are i , j {\\textstyle i,j} so that g − a = 0 mod f i {\\textstyle g-a=0\\mod f_{i}} and g − a ≠ 0 mod f j {\\textstyle g-a\\not =0\\mod f_{j}} . Such a g − a {\\textstyle g-a} has a nontrivial factor in common with f ( x ) {\\textstyle f(x)} , which can be computed via the gcd. As p {\\textstyle p} is small, we can cycle through all possible a {\\textstyle a} . For the case of large primes, which are necessarily odd, one can exploit the fact that a random nonzero element of F p ∗ {\\textstyle \\mathbb {F} _{p}^{*}} is a square with probability 1 / 2 {\\textstyle 1/2} , and that the map x → x p − 1 2 {\\textstyle x\\to x^{\\frac {p-1}{2}}} maps the set of non-zero squares to 1 {\\textstyle 1} , and the set of non-squares to − 1 {\\textstyle -1} .",
    "source_url": "https://en.wikipedia.org/wiki/Berlekamp%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:34.563303",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:34.563303",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:34.563303",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Cantor%E2%80%93Zassenhaus_algorithm_1_1749014797239_3563",
    "text": "Since ϕ {\\displaystyle \\phi } is an isomorphism, we have (using our now-established notation): ϕ ( b ( x ) m ) = ( b 1 m ( x ) + ⟨ p 1 ( x ) ⟩ , … , b s m ( x ) + ⟨ p s ( x ) ⟩ ) . {\\displaystyle \\phi (b(x)^{m})=(b_{1}^{m}(x)+\\langle p_{1}(x)\\rangle ,\\ldots ,b_{s}^{m}(x)+\\langle p_{s}(x)\\rangle ).} Now, each b i ( x ) + ⟨ p i ( x ) ⟩ {\\displaystyle b_{i}(x)+\\langle p_{i}(x)\\rangle } is an element of a field of order q d {\\displaystyle q^{d}} , as noted earlier. The multiplicative subgroup of this field has order q d − 1 {\\displaystyle q^{d}-1} and so, unless b i ( x ) = 0 {\\displaystyle b_{i}(x)=0} , we have b i ( x ) q d − 1 = 1 {\\displaystyle b_{i}(x)^{q^{d}-1}=1} for each i and hence b i ( x ) m = ± 1 {\\displaystyle b_{i}(x)^{m}=\\pm 1} for each i . If b i ( x ) = 0 {\\displaystyle b_{i}(x)=0} , then of course b i ( x ) m = 0 {\\displaystyle b_{i}(x)^{m}=0} . Hence b ( x ) m {\\displaystyle b(x)^{m}} is a polynomial of the same type as a ( x ) {\\displaystyle a(x)} above.",
    "source_url": "https://en.wikipedia.org/wiki/Cantor%E2%80%93Zassenhaus_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:37.239654",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:37.239654",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:37.239654",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Landau%27s_algorithm_1_1749014801119_8935",
    "text": "Another simple example, 2 3 = 2 6 {\\displaystyle {\\sqrt[{3}]{\\sqrt {2}}}={\\sqrt[{6}]{2}}} Rewriting a nested radical in this way is called denesting . This is not always possible, and, even when possible, it is often difficult. Two nested square roots [ edit ] In the case of two nested square roots, the following theorem completely solves the problem of denesting. [ 2 ] If a and c are rational numbers and c is not the square of a rational number, there are two rational numbers x and y such that a + c = x ± y {\\displaystyle {\\sqrt {a+{\\sqrt {c}}}}={\\sqrt {x}}\\pm {\\sqrt {y}}} if and only if a 2 − c {\\displaystyle a^{2}-c~} is the square of a rational number d . If the nested radical is real, x and y are the two numbers a + d 2 {\\displaystyle {\\frac {a+d}{2}}~} and a − d 2 , {\\displaystyle ~{\\frac {a-d}{2}}~,~} where d = a 2 − c {\\displaystyle ~d={\\sqrt {a^{2}-c}}~} is a rational number. In particular, if a and c are integers, then 2 x and 2 y are integers.",
    "source_url": "https://en.wikipedia.org/wiki/Landau%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:41.119872",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:41.120883",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:41.120883",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Landau%27s_algorithm_1_1749014801153_2333",
    "text": "In particular, if a and c are integers, then 2 x and 2 y are integers. This result includes denestings of the form a + c = z ± y , {\\displaystyle {\\sqrt {a+{\\sqrt {c}}}}=z\\pm {\\sqrt {y}}~,} as z may always be written z = ± z 2 , {\\displaystyle z=\\pm {\\sqrt {z^{2}}},} and at least one of the terms must be positive (because the left-hand side of the equation is positive). A more general denesting formula could have the form a + c = α + β x + γ y + δ x y . {\\displaystyle {\\sqrt {a+{\\sqrt {c}}}}=\\alpha +\\beta {\\sqrt {x}}+\\gamma {\\sqrt {y}}+\\delta {\\sqrt {x}}{\\sqrt {y}}~.} However, Galois theory implies that either the left-hand side belongs to Q ( c ) , {\\displaystyle \\mathbb {Q} ({\\sqrt {c}}),} or it must be obtained by changing the sign of either x , {\\displaystyle {\\sqrt {x}},} y , {\\displaystyle {\\sqrt {y}},} or both. In the first case, this means that one can take x = c and γ = δ = 0. { \\displaystyle \\gamma =\\delta =0.}",
    "source_url": "https://en.wikipedia.org/wiki/Landau%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:41.153895",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:41.153895",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:41.153895",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Landau%27s_algorithm_1_1749014801525_1177",
    "text": "\\displaystyle \\gamma =\\delta =0.} In the second case, α {\\displaystyle \\alpha } and another coefficient must be zero. If β = 0 , {\\displaystyle \\beta =0,} one may rename xy as x for getting δ = 0. {\\displaystyle \\delta =0.} Proceeding similarly if α = 0 , {\\displaystyle \\alpha =0,} it results that one can suppose α = δ = 0. { \\displaystyle \\alpha =\\delta =0.} This shows that the apparently more general denesting can always be reduced to the above one. Proof : By squaring, the equation a + c = x ± y {\\displaystyle {\\sqrt {a+{\\sqrt {c}}}}={\\sqrt {x}}\\pm {\\sqrt {y}}} is equivalent with a + c = x + y ± 2 x y , {\\displaystyle a+{\\sqrt {c}}=x+y\\pm 2{\\sqrt {xy}},} and, in the case of a minus in the right-hand side, | x | ≥ | y | , (square roots are nonnegative by definition of the notation). As the inequality may always be satisfied by possibly exchanging x and y , solving the first equation in x and y is equivalent with solving a + c = x + y ± 2 x y .",
    "source_url": "https://en.wikipedia.org/wiki/Landau%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:41.525712",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:41.526715",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:41.526715",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Landau%27s_algorithm_1_1749014801561_8385",
    "text": "c = x + y ± 2 x y . {\\displaystyle a+{\\sqrt {c}}=x+y\\pm 2{\\sqrt {xy}}.} This equality implies that x y {\\displaystyle {\\sqrt {xy}}} belongs to the quadratic field Q ( c ) . {\\displaystyle \\mathbb {Q} ({\\sqrt {c}}).} In this field every element may be uniquely written α + β c , {\\displaystyle \\alpha +\\beta {\\sqrt {c}},} with α {\\displaystyle \\alpha } and β {\\displaystyle \\beta } being rational numbers. This implies that ± 2 x y {\\displaystyle \\pm 2{\\sqrt {xy}}} is not rational (otherwise the right-hand side of the equation would be rational; but the left-hand side is irrational). As x and y must be rational, the square of ± 2 x y {\\displaystyle \\pm 2{\\sqrt {xy}}} must be rational. This implies that α = 0 {\\displaystyle \\alpha =0} in the expression of ± 2 x y {\\displaystyle \\pm 2{\\sqrt {xy}}} as α + β c . {\\displaystyle \\alpha +\\beta {\\sqrt {c}}.} Thus a + c = x + y + β c {\\displaystyle a+{\\sqrt {c}}=x+y+\\beta {\\sqrt {c}}} for some rational number β . {\\displaystyle \\beta .}",
    "source_url": "https://en.wikipedia.org/wiki/Landau%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:41.561707",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:41.561707",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:41.561707",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Landau%27s_algorithm_1_1749014801592_4627",
    "text": "{\\displaystyle \\beta .} The uniqueness of the decomposition over 1 and c {\\displaystyle {\\sqrt {c}}} implies thus that the considered equation is equivalent with a = x + y and ± 2 x y = c . {\\displaystyle a=x+y\\quad {\\text{and}}\\quad \\pm 2{\\sqrt {xy}}={\\sqrt {c}}.} It follows by Vieta's formulas that x and y must be roots of the quadratic equation z 2 − a z + c 4 = 0 ; {\\displaystyle z^{2}-az+{\\frac {c}{4}}=0~;} its Δ = a 2 − c = d 2 > 0 {\\displaystyle ~\\Delta =a^{2}-c=d^{2}>0~} ( ≠ 0 , otherwise c would be the square of a ), hence x and y must be a + a 2 − c 2 {\\displaystyle {\\frac {a+{\\sqrt {a^{2}-c}}}{2}}~} and a − a 2 − c 2 . {\\displaystyle ~{\\frac {a-{\\sqrt {a^{2}-c}}}{2}}~.} Thus x and y are rational if and only if d = a 2 − c {\\displaystyle d={\\sqrt {a^{2}-c}}~} is a rational number. For explicitly choosing the various signs, one must consider only positive real square roots, and thus assuming c > 0 .",
    "source_url": "https://en.wikipedia.org/wiki/Landau%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:41.592211",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:41.592211",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:41.592211",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Landau%27s_algorithm_1_1749014801612_1279",
    "text": "The equation a 2 = c + d 2 {\\displaystyle a^{2}=c+d^{2}} shows that | a | > √ c . Thus, if the nested radical is real, and if denesting is possible, then a > 0 . Then the solution is a + c = a + d 2 + a − d 2 , a − c = a + d 2 − a − d 2 . {\\displaystyle {\\begin{aligned}{\\sqrt {a+{\\sqrt {c}}}}&={\\sqrt {\\frac {a+d}{2}}}+{\\sqrt {\\frac {a-d}{2}}},\\\\[6pt]{\\sqrt {a-{\\sqrt {c}}}}&={\\sqrt {\\frac {a+d}{2}}}-{\\sqrt {\\frac {a-d}{2}}}.\\end{aligned}}} Some identities of Ramanujan [ edit ] Srinivasa Ramanujan demonstrated a number of curious identities involving nested radicals.",
    "source_url": "https://en.wikipedia.org/wiki/Landau%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:41.612222",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:41.612222",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:41.612222",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Landau%27s_algorithm_1_1749014801715_5502",
    "text": "For example, sin ⁡ π 60 = sin ⁡ 3 ∘ = 1 16 [ 2 ( 1 − 3 ) 5 + 5 + 2 ( 5 − 1 ) ( 3 + 1 ) ] {\\displaystyle \\sin {\\frac {\\pi }{60}}=\\sin 3^{\\circ }={\\frac {1}{16}}\\left[2(1-{\\sqrt {3}}){\\sqrt {5+{\\sqrt {5}}}}+{\\sqrt {2}}({\\sqrt {5}}-1)({\\sqrt {3}}+1)\\right]} and sin ⁡ π 24 = sin ⁡ 7.5 ∘ = 1 2 2 − 2 + 3 = 1 2 2 − 1 + 3 2 . {\\displaystyle \\sin {\\frac {\\pi }{24}}=\\sin 7.5^{\\circ }={\\frac {1}{2}}{\\sqrt {2-{\\sqrt {2+{\\sqrt {3}}}}}}={\\frac {1}{2}}{\\sqrt {2-{\\frac {1+{\\sqrt {3}}}{\\sqrt {2}}}}}.} The last equality results directly from the results of § Two nested square roots . In the solution of the cubic equation [ edit ] Nested radicals appear in the algebraic solution of the cubic equation . Any cubic equation can be written in simplified form without a quadratic term, as x 3 + p x + q = 0 , {\\displaystyle x^{3}+px+q=0,} whose general solution for one of the roots is x = − q 2 + q 2 4 + p 3 27 3 + − q 2 − q 2 4 + p 3 27 3 .",
    "source_url": "https://en.wikipedia.org/wiki/Landau%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:41.715367",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:41.715367",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:41.715367",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Landau%27s_algorithm_1_1749014801742_6821",
    "text": "= − q 2 + q 2 4 + p 3 27 3 + − q 2 − q 2 4 + p 3 27 3 . {\\displaystyle x={\\sqrt[{3}]{-{q \\over 2}+{\\sqrt {{q^{2} \\over 4}+{p^{3} \\over 27}}}}}+{\\sqrt[{3}]{-{q \\over 2}-{\\sqrt {{q^{2} \\over 4}+{p^{3} \\over 27}}}}}.} In the case in which the cubic has only one real root, the real root is given by this expression with the radicands of the cube roots being real and with the cube roots being the real cube roots. In the case of three real roots, the square root expression is an imaginary number; here any real root is expressed by defining the first cube root to be any specific complex cube root of the complex radicand, and by defining the second cube root to be the complex conjugate of the first one. The nested radicals in this solution cannot in general be simplified unless the cubic equation has at least one rational solution.",
    "source_url": "https://en.wikipedia.org/wiki/Landau%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:41.742103",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:41.742103",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:41.742103",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=List_of_computer_algebra_systems&oldid=1290607931_1_1749014805756_8298",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by 2001:9e8:35f2:d300:a877:3214:6ed9:8a25 ( talk ) at 21:18, 15 May 2025 ( → General : update GiNaC version) . The present address (URL) is a permanent link to this version. Revision as of 21:18, 15 May 2025 by 2001:9e8:35f2:d300:a877:3214:6ed9:8a25 ( talk ) ( → General : update GiNaC version) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) The following tabl",
    "source_url": "https://en.wikipedia.org/w/index.php?title=List_of_computer_algebra_systems&oldid=1290607931",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:45.756713",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:45.756713",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:45.756713",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Category:Free_computer_algebra_systems_1_1749014810282_3057",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is a category of articles relating to software which can be freely used, copied, studied, modified, and redistributed by everyone that obtains a copy: \" free software \" or \" open source software \".  Typically, this means software which is distributed with a free software license , and whose source code is available to anyone who receives a copy of the software. See also [ edit ] Free software portal Mathematics portal Comparison of ",
    "source_url": "https://en.wikipedia.org/wiki/Category:Free_computer_algebra_systems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:50.282595",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:50.282595",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:50.282595",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Computer_algebra_systems&oldid=969154662_1_1749014811550_6429",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by BrownHairedGirl ( talk | contribs ) at 18:14, 23 July 2020 (remove navbox which belongs on articles, where it appears at the bottom of the page.  Placing it at the TOP of a category page is an impediment to navigation, because it appears above the listing of the category's content) . The present address (URL) is a permanent link to this version. Revision as of 18:14, 23 July 2020 by",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Computer_algebra_systems&oldid=969154662",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:51.550480",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:51.550480",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:51.550480",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Multivariate_division_algorithm_1_1749014813965_4114",
    "text": "In the context of Gröbner bases, a nonzero polynomial in R = K [ x 1 , … , x n ] {\\displaystyle R=K[x_{1},\\ldots ,x_{n}]} is commonly represented as a sum c 1 M 1 + ⋯ + c m M m , {\\displaystyle c_{1}M_{1}+\\cdots +c_{m}M_{m},} where the c i {\\displaystyle c_{i}} are nonzero elements of K , called coefficients , and the M i {\\displaystyle M_{i}} are monomials (called power products by Buchberger and some of his followers) of the form x 1 a 1 ⋯ x n a n , {\\displaystyle x_{1}^{a_{1}}\\cdots x_{n}^{a_{n}},} where the a i {\\displaystyle a_{i}} are nonnegative integers. The vector A = [ a 1 , … , a n ] {\\displaystyle A=[a_{1},\\ldots ,a_{n}]} is called the exponent vector of the monomial. When the list X = [ x 1 , … , x n ] {\\displaystyle X=[x_{1},\\ldots ,x_{n}]} of the variables is fixed, the notation of monomials is often abbreviated as x 1 a 1 ⋯ x n a n = X A . {\\displaystyle x_{1}^{a_{1}}\\cdots x_{n}^{a_{n}}=X^{A}.}",
    "source_url": "https://en.wikipedia.org/wiki/Multivariate_division_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:53.965298",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:53.965298",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:53.965298",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Multivariate_division_algorithm_1_1749014814017_1953",
    "text": "i = 1 k g i f i {\\textstyle \\sum _{i=1}^{k}g_{i}f_{i}} with g 1 , … , g k ∈ R . {\\displaystyle g_{1},\\ldots ,g_{k}\\in R.} Monomial ordering [ edit ] Main article: Monomial order All operations related to Gröbner bases require the choice of a total order on the monomials, with the following properties of compatibility with multiplication. For all monomials M , N , P , M ≤ N ⟺ M P ≤ N P {\\displaystyle M\\leq N\\Longleftrightarrow MP\\leq NP} M ≤ M P {\\displaystyle M\\leq MP} . A total order satisfying these condition is sometimes called an admissible ordering . These conditions imply that the order is a well-order , that is, every strictly decreasing sequence of monomials is finite. Although Gröbner basis theory does not depend on a particular choice of an admissible monomial ordering, three monomial orderings are especially important for the applications: Lexicographical ordering , commonly called lex or plex (for pure lexical ordering).",
    "source_url": "https://en.wikipedia.org/wiki/Multivariate_division_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:54.017683",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:54.018685",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:54.018685",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Multivariate_division_algorithm_1_1749014814075_1913",
    "text": "This makes the representation of a polynomial as a sorted list of pairs coefficient–exponent vector a canonical representation of the polynomials (that is, two polynomials are equal if and only if they have the same representation). The first (greatest) term of a polynomial p for this ordering and the corresponding monomial and coefficient are respectively called the leading term , leading monomial and leading coefficient and denoted, in this article, lt( p ), lm( p ) and lc( p ) . Most polynomial operations related to Gröbner bases involve the leading terms. So, the representation of polynomials as sorted lists make these operations particularly efficient (reading the first element of a list takes a constant time, independently of the length of the list). Polynomial operations [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Multivariate_division_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:54.075851",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:54.075851",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:54.075851",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Multivariate_division_algorithm_1_1749014814130_2199",
    "text": "This does not change the term ordering by definition of a monomial ordering. Divisibility of monomials [ edit ] Let M = x 1 a 1 ⋯ x n a n {\\displaystyle M=x_{1}^{a_{1}}\\cdots x_{n}^{a_{n}}} and N = x 1 b 1 ⋯ x n b n {\\displaystyle N=x_{1}^{b_{1}}\\cdots x_{n}^{b_{n}}} be two monomials, with exponent vectors A = [ a 1 , … , a n ] {\\displaystyle A=[a_{1},\\ldots ,a_{n}]} and B = [ b 1 , … , b n ] . {\\displaystyle B=[b_{1},\\ldots ,b_{n}].} One says that M divides N , or that N is a multiple of M , if a i ≤ b i {\\displaystyle a_{i}\\leq b_{i}} for every i ; that is, if A is componentwise not greater than B . In this case, the quotient N M {\\textstyle {\\frac {N}{M}}} is defined as N M = x 1 b 1 − a 1 ⋯ x n b n − a n . {\\textstyle {\\frac {N}{M}}=x_{1}^{b_{1}-a_{1}}\\cdots x_{n}^{b_{n}-a_{n}}.} In other words, the exponent vector of N M {\\textstyle {\\frac {N}{M}}} is the componentwise subtraction of the exponent vectors of N and M .",
    "source_url": "https://en.wikipedia.org/wiki/Multivariate_division_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:54.130948",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:54.131412",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:54.131412",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Multivariate_division_algorithm_1_1749014814159_7257",
    "text": "The greatest common divisor gcd( M , N ) of M and N is the monomial x 1 min ( a 1 , b 1 ) ⋯ x n min ( a n , b n ) {\\textstyle x_{1}^{\\min(a_{1},b_{1})}\\cdots x_{n}^{\\min(a_{n},b_{n})}} whose exponent vector is the componentwise minimum of A and B . The least common multiple lcm( M , N ) is defined similarly with max instead of min . One has lcm ⁡ ( M , N ) = M N gcd ( M , N ) . {\\displaystyle \\operatorname {lcm} (M,N)={\\frac {MN}{\\gcd(M,N)}}.} Reduction [ edit ] The reduction of a polynomial by other polynomials with respect to a monomial ordering is central to Gröbner basis theory. It is a generalization of both row reduction occurring in Gaussian elimination and division steps of the Euclidean division of univariate polynomials . [ 1 ] When completed as much as possible, it is sometimes called multivariate division although its result is not uniquely defined. Lead-reduction is a special case of reduction that is easier to compute.",
    "source_url": "https://en.wikipedia.org/wiki/Multivariate_division_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:54.159418",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:54.160418",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:54.160418",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Multivariate_division_algorithm&redirect=no_1_1749014815319_9375",
    "text": "Jump to content From Wikipedia, the free encyclopedia Redirect to: Gröbner basis#Reduction This page is a redirect . The following categories are used to track and monitor this redirect: To a section : This is a redirect from a topic that does not have its own page to a section of a page on the subject. For redirects to embedded anchors on a page, use {{ R to anchor }} instead . From a merge : This is a redirect from a page that was merged into another page. This redirect was kept in order to pr",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Multivariate_division_algorithm&redirect=no",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:26:55.319284",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:26:55.319284",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:26:55.319284",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quine%E2%80%93McCluskey_algorithm_1_1749014820896_1097",
    "text": "= ∑ m ( 4 , 8 , 10 , 11 , 12 , 15 ) + d ( 9 , 14 ) . {\\displaystyle f(A,B,C,D)=\\sum m(4,8,10,11,12,15)+d(9,14).\\,} This expression says that the output function f will be 1 for the minterms 4 , 8 , 10 , 11 , 12 {\\displaystyle 4,8,10,11,12} and 15 {\\displaystyle 15} (denoted by the 'm' term) and that we don't care about the output for 9 {\\displaystyle 9} and 14 {\\displaystyle 14} combinations (denoted by the 'd' term). The summation symbol ∑ {\\displaystyle \\sum } denotes the logical sum (logical OR, or disjunction) of all the terms being summed over. Step 1: Finding the prime implicants [ edit ] First, we write the function as a table (where 'x' stands for don't care): A B C D f m0 0 0 0 0 0 m1 0 0 0 1 0 m2 0 0 1 0 0 m3 0 0 1 1 0 m4 0 1 0 0 1 m5 0 1 0 1 0 m6 0 1 1 0 0 m7 0",
    "source_url": "https://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:00.896053",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:00.896053",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:00.896053",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quine%E2%80%93McCluskey_algorithm_1_1749014820962_6116",
    "text": "If two terms differ by only a single digit, that digit is replaced with a dash indicating that the digit doesn't matter. For instance 1000 and 1001 can be combined to give 100- , indicating that both minterms imply the first digit is 1 and the next two are 0 . Terms that can't be combined any more are marked with an asterisk ( * ). Number of 1s Minterm 0-Cube Size 2 Implicants 1 m4 0100 m(4,12) -100 * m8 1000 m(8,9) 100- — m(8,10) 10-0 — m(8,12) 1-00 2 m9 1001 m(9,11) 10-1 m10 1010 m(10,11) 101- — m(10,14) 1-10 m12 1100 m(12,14) 11-0 3 m11 1011 m(11,15) 1-11 m14 1110 m(14,15) 111- 4 m15 1111 — When going from Size 2 to Size 4, treat - as a third bit value. Match up the - 's first. The terms represent products and to combine two product terms they must have the same variables. One of the variables should be complemented in one term and uncomplemented in the other. The remaining variables present should agree.",
    "source_url": "https://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:00.962803",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:00.962803",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:00.962803",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quine%E2%80%93McCluskey_algorithm_1_1749014820996_7004",
    "text": "The remaining variables present should agree. So to match two terms the - 's must align and all but one of the other digits must be the same. For instance, -110 and -100 can be combined to give -1-0 , as can -110 and -010 to give --10 , but -110 and 011- cannot since the - 's do not align. -110 corresponds to BCD' while 011- corresponds to A'BC, and BCD' + A'BC is not equivalent to a product term. Number of 1s Minterm 0-Cube Size 2 Implicants Size 4 Implicants 1 m4 0100 m(4,12) -100 * — m8 1000 m(8,9) 100- m(8,9,10,11) 10-- * — m(8,10) 10-0 m(8,10,12,14) 1--0 * — m(8,12) 1-00 — 2 m9 1001 m(9,11) 10-1 — m10 1010 m(10,11) 101- m(10,11,14,15) 1-1- * — m(10,14) 1-10 — m12 1100 m(12,14) 11-0 — 3 m11 1011 m(11,15) 1-11 — m14 1110 m(14,15) 111- — 4 m15 1111 — — Note: In this example, none of the terms in the size 4 implicants table can be combined any further. In general, this process is continued in sizes that are powers of 2 (sizes 8, 16 etc.) until no more terms can be combined.",
    "source_url": "https://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:00.996337",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:00.997351",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:00.997351",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quine%E2%80%93McCluskey_algorithm_1_1749014821029_3652",
    "text": "Step 2: Prime implicant chart [ edit ] None of the terms can be combined any further than this, so at this point we construct an essential prime implicant table. Along the side goes the prime implicants that have just been generated (these are the ones that have been marked with a \" * \" in the previous step), and along the top go the minterms specified earlier. The don't care terms are not placed on top—they are omitted from this section because they are not necessary inputs. 4 8 10 11 12 15 ⇒ A B C D m(4,12) # ⇒ — 1 0 0 m(8,9,10,11) ⇒ 1 0 — — m(8,10,12,14) ⇒ 1 — — 0 m(10,11,14,15) # ⇒ 1 — 1 — To find the essential prime implicants, we look for columns with only one \"✓\". If a column has only one \"✓\", this means that the minterm can only be covered by one prime implicant. This prime implicant is essential . For example: in the first column, with minterm 4, there is only one \"✓\". This means that m(4,12) is essential (hence marked by # ).",
    "source_url": "https://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:01.029038",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:01.029038",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:01.029038",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Quine–McCluskey_algorithm&oldid=1292241520_1_1749014822950_7522",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 23:17, 25 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 23:17, 25 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Algo",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Quine–McCluskey_algorithm&oldid=1292241520",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:02.950665",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:02.950665",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:02.950665",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Boolean_algebra_1_1749014831748_3179",
    "text": "They are used to store either true or false values. [ 21 ] The basic operations on Boolean variables x and y are defined as follows: Logical operation Operator Notation Alternative notations Definition Conjunction AND x ∧ y x AND y , K xy x ∧ y = 1 if x = y = 1, x ∧ y = 0 otherwise Disjunction OR x ∨ y x OR y , A xy x ∨ y = 0 if x = y = 0, x ∨ y = 1 otherwise Negation NOT ¬ x NOT x , N x , x̅ , x' , ! x ¬ x = 0 if x = 1, ¬ x = 1 if x = 0 Alternatively, the values of x ∧ y , x ∨ y , and ¬ x can be expressed by tabulating their values with truth tables as follows: [ 22 ] x {\\displaystyle x} y {\\displaystyle y} x ∧ y {\\displaystyle x\\wedge y} x ∨ y {\\displaystyle x\\vee y} 0 0 0 0 1 0 0 1 0 1 0 1 1 1 1 1 x {\\displaystyle x} ¬ x {\\displaystyle \\neg x} 0 1 1 0 When used in expressions, the operators are applied according to the precedence rules. As with elementary algebra, expressions in parentheses are evaluated first, following the precedence rules. [ 23 ]",
    "source_url": "https://en.wikipedia.org/wiki/Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:11.748782",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:11.748782",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:11.748782",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Boolean_algebra_1_1749014831774_9868",
    "text": "[ 23 ] If the truth values 0 and 1 are interpreted as integers, these operations may be expressed with the ordinary operations of arithmetic (where x + y uses addition and xy uses multiplication), or by the minimum/maximum functions: x ∧ y = x y = min ( x , y ) x ∨ y = x + y − x y = x + y ( 1 − x ) = max ( x , y ) ¬ x = 1 − x {\\displaystyle {\\begin{aligned}x\\wedge y&=xy=\\min(x,y)\\\\x\\vee y&=x+y-xy=x+y(1-x)=\\max(x,y)\\\\\\neg x&=1-x\\end{aligned}}} One might consider that only negation and one of the two other operations are basic because of the following identities that allow one to define conjunction in terms of negation and the disjunction, and vice versa ( De Morgan's laws ): [ 24 ] x ∧ y = ¬ ( ¬ x ∨ ¬ y ) x",
    "source_url": "https://en.wikipedia.org/wiki/Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:11.774782",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:11.774782",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:11.774782",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Boolean_algebra_1_1749014831807_7014",
    "text": "x ∨ y = ¬ ( ¬ x ∧ ¬ y ) {\\displaystyle {\\begin{aligned}x\\wedge y&=\\neg (\\neg x\\vee \\neg y)\\\\x\\vee y&=\\neg (\\neg x\\wedge \\neg y)\\end{aligned}}} Secondary operations [ edit ] Operations composed from the basic operations include, among others, the following: Material conditional : x → y = ¬ x ∨ y {\\textstyle x\\rightarrow y=\\neg {x}\\vee y} Material biconditional : x ↔ y = ( x ∧ y ) ∨ ( ¬ x ∧ ¬ y ) = ( x ∨ ¬ y ) ∧ ( ¬ x ∨ y ) {\\textstyle x\\leftrightarrow y=(x\\land y)\\lor (\\neg x\\land \\neg y)=(x\\lor \\neg y)\\land (\\neg x\\lor y)} Exclusive OR ( XOR ): x ⊕ y = ¬ ( x ↔ y ) = ( x ∨ y ) ∧ ¬ ( x ∧ y ) = ( x ∨ y ) ∧ ( ¬ x ∨ ¬ y ) = ( x ∧ ¬ y ) ∨ ( ¬ x ∧ y ) {\\textstyle x\\oplus y=\\neg (x\\leftrightarrow y)=(x\\vee y)\\wedge \\neg (x\\wedge y)=(x\\vee y)\\wedge (\\neg x\\vee \\neg y)=(x\\wedge \\neg y)\\vee (\\neg x\\wedge y)} These definitions give rise to the following truth tables giving the values of these operations for all four possible inputs. Secondary operations. Table 1",
    "source_url": "https://en.wikipedia.org/wiki/Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:11.807299",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:11.807299",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:11.807299",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Self-replicating_machine_1_1749014838671_8904",
    "text": "Jump to content From Wikipedia, the free encyclopedia Device able to make copies of itself A simple form of machine self-replication A self-replicating machine is a type of autonomous robot that is capable of reproducing itself autonomously using raw materials found in the environment, thus exhibiting self-replication in a way analogous to that found in nature . [ 1 ] [ 2 ] [ 3 ] The concept of self-replicating machines has been advanced and examined by Homer Jacobson , Edward F. Moore , Freeman",
    "source_url": "https://en.wikipedia.org/wiki/Self-replicating_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:18.671858",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:18.672858",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:18.672858",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=List_of_computer_hardware_manufacturers&oldid=1282622571_1_1749014846153_5968",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Tom94022 ( talk | contribs ) at 15:38, 27 March 2025 (Undid revision 1282621794 by 162.218.182.22 ( talk )rmv unlinked addition per page policy) . The present address (URL) is a permanent link to this version. Revision as of 15:38, 27 March 2025 by Tom94022 ( talk | contribs ) (Undid revision 1282621794 by 162.218.182.22 ( talk )rmv unlinked addition per page policy) ( diff ) ← Previous ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=List_of_computer_hardware_manufacturers&oldid=1282622571",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:26.153095",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:26.153095",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:26.153095",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Computer_hardware&oldid=1274311538_1_1749014854878_5725",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Robby ( talk | contribs ) at 16:44, 6 February 2025 (link to Commons is now defined on Wikidata) . The present address (URL) is a permanent link to this version. Revision as of 16:44, 6 February 2025 by Robby ( talk | contribs ) (link to Commons is now defined on Wikidata) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Pages in this category should b",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Computer_hardware&oldid=1274311538",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:34.878280",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:34.879280",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:34.879280",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Routing_algorithm_1_1749014856178_9729",
    "text": "Routing has become the dominant form of addressing on the Internet. Bridging is still widely used within local area networks . Delivery schemes [ edit ] Routing schemes Unicast Broadcast Multicast Anycast Routing schemes differ in how they deliver messages: Unicast delivers a message to a single specific node using a one-to-one association between a sender and destination: each destination address uniquely identifies a single receiver endpoint. Broadcast delivers a message to all nodes in the network using a one-to-all association; a single datagram (or packet ) from one sender is routed to all of the possibly multiple endpoints associated with the broadcast address . The network automatically replicates datagrams as needed to reach all the recipients within the scope of the broadcast, which is generally an entire network subnet .",
    "source_url": "https://en.wikipedia.org/wiki/Routing_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:36.178893",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:36.178893",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:36.178893",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Cole%E2%80%93Vishkin_algorithm_1_1749014860027_8593",
    "text": "Main article: Chromatic polynomial The chromatic polynomial counts the number of ways a graph can be colored using some of a given number of colors. For example, using three colors, the graph in the adjacent image can be colored in 12 ways. With only two colors, it cannot be colored at all. With four colors, it can be colored in 24 + 4 × 12 = 72 ways: using all four colors, there are 4! = 24 valid colorings ( every assignment of four colors to any 4-vertex graph is a proper coloring); and for every choice of three of the four colors, there are 12 valid 3-colorings. So, for the graph in the example, a table of the number of valid colorings would start like this: Available colors 1 2 3 4 ... Number of colorings 0 0 12 72 ... The chromatic polynomial is a function P ( G , t ) that counts the number of t -colorings of G . As the name indicates, for a given G the function is indeed a polynomial in t . For the example graph, P ( G , t ) = t ( t − 1) 2 ( t − 2) , and indeed P ( G , 4) = 72 .",
    "source_url": "https://en.wikipedia.org/wiki/Cole%E2%80%93Vishkin_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:40.027779",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:40.027779",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:40.027779",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Cole%E2%80%93Vishkin_algorithm_1_1749014860092_4850",
    "text": "The smallest number of colors needed for an edge coloring of a graph G is the chromatic index , or edge chromatic number , χ ′ ( G ) . A Tait coloring is a 3-edge coloring of a cubic graph . The four color theorem is equivalent to the assertion that every planar cubic bridgeless graph admits a Tait coloring. Total coloring [ edit ] Main article: Total coloring Total coloring is a type of coloring on the vertices and edges of a graph. When used without any qualification, a total coloring is always assumed to be proper in the sense that no adjacent vertices, no adjacent edges, and no edge and its end-vertices are assigned the same color. The total chromatic number χ ″( G ) of a graph G is the fewest colors needed in any total coloring of G . Face coloring [ edit ] For a graph with a strong embedding on a surface, the face coloring is the dual of the vertex coloring problem.",
    "source_url": "https://en.wikipedia.org/wiki/Cole%E2%80%93Vishkin_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:40.092308",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:40.092308",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:40.092308",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Turing_machine_equivalents_1_1749014866670_7800",
    "text": "Many authors later introduced variants of the machines discussed by Wang: Minsky evolved Wang's notion with his version of the (multi-tape) \"counter machine\" model that allowed SHIFT-LEFT and SHIFT-RIGHT motion of the separate heads but no printing at all. [ 3 ] In this case the tapes would be left-ended, each end marked with a single \"mark\" to indicate the end. He was able to reduce this to a single tape, but at the expense of introducing multi-tape-square motion equivalent to multiplication and division rather than the much simpler { SHIFT-LEFT = DECREMENT, SHIFT-RIGHT = INCREMENT }. Davis, adding an explicit HALT instruction to one of the machines discussed by Wang, used a model with the instruction-set { SHIFT-LEFT, SHIFT-RIGHT, ERASE, MARK, JUMP-IF-SQUARE-MARKED-to xxx, JUMP-to xxx, HALT } and also considered versions with tape-alphabets of size larger than 2.",
    "source_url": "https://en.wikipedia.org/wiki/Turing_machine_equivalents",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:46.670716",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:46.671718",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:46.671718",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Turing_machine_equivalents_1_1749014866849_2043",
    "text": "[ 3 ] In this model the single-ended tapes-as-registers are thought of as \"counters\", their instructions restricted to only two (or three if the TEST/DECREMENT instruction is atomised). Two common instruction sets are the following: (1): { INC ( r ), DEC ( r ), JZ ( r,z ) }, i.e. { INCrement contents of register #r; DECrement contents of register #r; IF contents of #r=Zero THEN Jump-to Instruction #z} (2): { CLR ( r ); INC ( r ); JE ( r i , r j , z ) }, i.e. { CLeaR contents of register r; INCrement contents of r; compare contents of r i to r j and if Equal then Jump to instruction z} Although his model is more complicated than this simple description, the Melzak \"pebble\" model extended this notion of \"counter\" to permit multi-\npebble adds and subtracts.",
    "source_url": "https://en.wikipedia.org/wiki/Turing_machine_equivalents",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:46.848999",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:46.848999",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:46.848999",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Turing_machine_examples_1_1749014869561_5959",
    "text": "1. A machine can be constructed to compute the sequence 0 1 0 1 0 1...\" (0 <blank> 1 <blank> 0...) [ 1 ] Configuration Behavior m-configuration (state) Tape symbol Tape operations Final m-configuration (state) b blank P0, R c c blank R e e blank P1, R f f blank R b With regard to what actions the machine actually does, Turing (1936) [ 2 ] states the following: \"This [example] table (and all succeeding tables of the same kind) is to be understood to mean that for a configuration described in the first two columns the operations in the third column are carried out successively, and the machine then goes over into the m-configuration in the final column.\" [ 2 ] He makes this very clear when he reduces the above table to a single instruction called \"b\", [ 3 ] but his instruction consists of 3 lines. Instruction \"b\" has three different symbol possibilities {None, 0, 1}.",
    "source_url": "https://en.wikipedia.org/wiki/Turing_machine_examples",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:49.561586",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:49.561586",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:49.561586",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Turing_machine_examples_1_1749014869872_3121",
    "text": "P rints symbol S or E rases or does N othing A \"run\" of the machine sequences through 16 machine-configurations (aka Turing states): Sequence Instruction identifier Head 1 s 1 0 0 0 0 1 1 0 0 0 0 0 2 s 2 0 0 0 0 0 1 0 0 0 0 0 3 s 2 0 0 0 0 0 0 1 0 0 0 0 4 s 3 0 0 0 0 0 0 0 1 0 0 0 5 s 4 0 0 0 0 1 0 1 0 0 0 0 6 s 5 0 0 0 1 0 1 0 0 0 0 0 7 s 5 0 0 1 0 1 0 0 0 0 0 0 8 s 1 0 0 0 1 0 1 1 0 0 0 0 9 s 2 0 0 0 0 1 0 0 1 0 0 0 10 s 3 0 0 0 0 0 1 0 0 1 0 0 11 s 3 0 0 0 0 0 0 1 0 0 1 0 12 s 4 0 0 0 0 1 1 0 0 1 0 0 13 s 4 0 0 0 1 1 0 0 1 0 0 0 14 s 5 0 0 1 1 0 0 1 0 0 0 0 15 s 1 0 0 0 1 1 0 1 1 0 0 0 16 H 0 0 0 1 1 0 1 1 0 0 0 The behavior of this machine can be described as a loop:\nit starts out in s 1 , replaces the first 1 with a 0, then uses s 2 to move to the right, skipping over 1s and the first 0 encountered.",
    "source_url": "https://en.wikipedia.org/wiki/Turing_machine_examples",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:49.872698",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:49.872698",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:49.872698",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Turing_machine_examples_1_1749014869900_5879",
    "text": "s 3 then skips over the next sequence of 1s (initially there are none) and replaces the first 0 it finds with a 1. s 4 moves back to the left, skipping over 1s until it finds a 0 and switches to s 5 . s 5 then moves to the left, skipping over 1s until it finds the 0 that was originally written by s 1 . It replaces that 0 with a 1, moves one position to the right and enters s 1 again for another round of the loop. This continues until s 1 finds a 0 (this is the 0 in the middle of the two strings of 1s) at which time the machine halts. Alternative description [ edit ] Another description sees the problem as how to keep track of how many \"1\"s there are. We can't use one state for each possible number (a state for each of 0,1,2,3,4,5,6 etc), because then we'd need infinite states to represent all the natural numbers, and the state machine is finite - we'll have to track this using the tape in some way.",
    "source_url": "https://en.wikipedia.org/wiki/Turing_machine_examples",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:49.900715",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:49.900715",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:49.901707",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Turing_machine_examples_1_1749014869936_1488",
    "text": "The basic way it works is by copying each \"1\" to the other side, by moving back and forth - it is intelligent enough to remember which part of the trip it is on. In more detail, it carries each \"1\" across to the other side, by recognizing the separating \"0\" in the middle, and recognizing the \"0\" on the other side to know it's reached the end. It comes back using the same method, detecting the middle \"0\", and then the \"0\" on the original side. This \"0\" on the original side is the key to the puzzle of how it keeps track of the number of 1's. The trick is that before carrying the \"1\", it marks that digit as \"taken\" by replacing it with an \"0\". When it returns, it fills that \"0\" back in with a \"1\", then moves on to the next one , marking it with an \"0\" and repeating the cycle, carrying that \"1\" across and so on. With each trip across and back, the marker \"0\" moves one step closer to the centre . This is how it keeps track of how many \"1\"'s it has taken across.",
    "source_url": "https://en.wikipedia.org/wiki/Turing_machine_examples",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:27:49.936116",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:27:49.936116",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:27:49.936116",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Multi-tape_Turing_machine_1_1749014884879_6597",
    "text": "[ 2 ] Thus, multi-tape machines cannot calculate any more functions than single-tape machines, [ 3 ] and none of the robust complexity classes (such as polynomial time ) are affected by a change between single-tape and multi-tape machines.",
    "source_url": "https://en.wikipedia.org/wiki/Multi-tape_Turing_machine",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:04.879430",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:04.879430",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:04.879430",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Read-only_right_moving_Turing_machines_1_1749014887605_8447",
    "text": "A 1 in the input does not change the state of the automaton. When the input ends, the state will show whether the input contained an even number of 0s or not. If the input did contain an even number of 0s, M will finish in state S 1 , an accepting state, so the input string will be accepted. The language recognized by M is the regular language given by the regular expression (1*) (0 (1*) 0 (1*))* , where * is the Kleene star , e.g., 1* denotes any number (possibly zero) of consecutive ones. Variations [ edit ] Complete and incomplete [ edit ] According to the above definition, deterministic finite automata are always complete : they define from each state a transition for each input symbol. While this is the most common definition, some authors use the term deterministic finite automaton for a slightly different notion: an automaton that defines at most one transition for each state and each input symbol; the transition function is allowed to be partial .",
    "source_url": "https://en.wikipedia.org/wiki/Read-only_right_moving_Turing_machines",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:07.605496",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:07.605496",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:07.605496",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Read-only_right_moving_Turing_machines_1_1749014887635_1265",
    "text": "[ 5 ] When no transition is defined, such an automaton halts. Local automata [ edit ] A local automaton is a DFA, not necessarily complete, for which all edges with the same label lead to a single vertex. Local automata accept the class of local languages , those for which membership of a word in the language is determined by a \"sliding window\" of length two on the word. [ 6 ] [ 7 ] A Myhill graph over an alphabet A is a directed graph with vertex set A and subsets of vertices labelled \"start\" and \"finish\". The language accepted by a Myhill graph is the set of directed paths from a start vertex to a finish vertex: the graph thus acts as an automaton. [ 6 ] The class of languages accepted by Myhill graphs is the class of local languages. [ 8 ] Randomness [ edit ] When the start state and accept states are ignored, a DFA of n states and an alphabet of size k can be seen as a digraph of n vertices in which all vertices have k out-arcs labeled 1, ..., k (a k -out digraph).",
    "source_url": "https://en.wikipedia.org/wiki/Read-only_right_moving_Turing_machines",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:07.635933",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:07.635933",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:07.635933",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Read-only_right_moving_Turing_machines_1_1749014887717_1574",
    "text": "As a transition monoid [ edit ] A run of a given DFA can be seen as a sequence of compositions of a very general formulation of the transition function with itself. Here we construct that function. For a given input symbol a ∈ Σ {\\displaystyle a\\in \\Sigma } , one may construct a transition function δ a : Q → Q {\\displaystyle \\delta _{a}:Q\\rightarrow Q} by defining δ a ( q ) = δ ( q , a ) {\\displaystyle \\delta _{a}(q)=\\delta (q,a)} for all q ∈ Q {\\displaystyle q\\in Q} . (This trick is called currying .) From this perspective, δ a {\\displaystyle \\delta _{a}} \"acts\" on a state in Q to yield another state. One may then consider the result of function composition repeatedly applied to the various functions δ a {\\displaystyle \\delta _{a}} , δ b {\\displaystyle \\delta _{b}} , and so on.",
    "source_url": "https://en.wikipedia.org/wiki/Read-only_right_moving_Turing_machines",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:07.717010",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:07.718009",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:07.718009",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Read-only_right_moving_Turing_machines_1_1749014887751_9872",
    "text": "Given a pair of letters a , b ∈ Σ {\\displaystyle a,b\\in \\Sigma } , one may define a new function δ ^ a b = δ a ∘ δ b {\\displaystyle {\\widehat {\\delta }}_{ab}=\\delta _{a}\\circ \\delta _{b}} , where ∘ {\\displaystyle \\circ } denotes function composition. Clearly, this process may be recursively continued, giving the following recursive definition of δ ^ : Q × Σ ⋆ → Q {\\displaystyle {\\widehat {\\delta }}:Q\\times \\Sigma ^{\\star }\\rightarrow Q} : δ ^ ( q , ϵ ) = q {\\displaystyle {\\widehat {\\delta }}(q,\\epsilon )=q} , where ϵ {\\displaystyle \\epsilon } is the empty string and δ ^ ( q , w a ) = δ a ( δ ^ ( q , w ) ) {\\displaystyle {\\widehat {\\delta }}(q,wa)=\\delta _{a}({\\widehat {\\delta }}(q,w))} , where w ∈ Σ ∗ , a ∈ Σ {\\displaystyle w\\in \\Sigma ^{*},a\\in \\Sigma } and q ∈ Q {\\displaystyle q\\in Q} . δ ^ {\\displaystyle {\\widehat {\\delta }}} is defined for all words w ∈ Σ ∗ {\\displaystyle w\\in \\Sigma ^{*}} .",
    "source_url": "https://en.wikipedia.org/wiki/Read-only_right_moving_Turing_machines",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:07.751539",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:07.751539",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:07.751539",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Read-only_right_moving_Turing_machines&redirect=no_1_1749014889336_1145",
    "text": "Jump to content From Wikipedia, the free encyclopedia Redirect to: Deterministic finite automaton#Equivalent models This page is a redirect . The following categories are used to track and monitor this redirect: From a page move : This is a redirect from a page that has been moved (renamed). This page was kept as a redirect to avoid breaking links, both internal and external, that may have been made to the old page name. When appropriate, protection levels are automatically sensed, described and",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Read-only_right_moving_Turing_machines&redirect=no",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:09.336544",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:09.336544",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:09.337543",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann_universe_1_1749014891181_1496",
    "text": "Therefore, P ( x ) ⊆ V α + 1 {\\displaystyle {\\mathcal {P}}(x)\\subseteq V_{\\alpha +1}} and P ( x ) ∈ V α + 2 ⊆ V {\\displaystyle {\\mathcal {P}}(x)\\in V_{\\alpha +2}\\subseteq V} . For unions of subsets, if x ⊆ V {\\displaystyle x\\subseteq V} , then for every y ∈ x {\\displaystyle y\\in x} , let β y {\\displaystyle \\beta _{y}} be the smallest ordinal for which y ∈ V β y {\\displaystyle y\\in V_{\\beta _{y}}} . Because by assumption x {\\displaystyle x} is a set, we can form the limit α = sup { β y : y ∈ x } {\\displaystyle \\alpha =\\sup\\{\\beta _{y}:y\\in x\\}} . The stages are cumulative, and therefore again every y ∈ x {\\displaystyle y\\in x} is y ∈ V α {\\displaystyle y\\in V_{\\alpha }} . Then every z ∈ y {\\displaystyle z\\in y} is also z ∈ V α {\\displaystyle z\\in V_{\\alpha }} , and so ∪ x ⊆ V α {\\displaystyle \\cup x\\subseteq V_{\\alpha }} and ∪ x ∈ V α + 1 {\\displaystyle \\cup x\\in V_{\\alpha +1}} . Hilbert's paradox implies that no set with the above properties exists .",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann_universe",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:11.181968",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:11.181968",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:11.181968",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann_universe_1_1749014891213_6356",
    "text": "Hilbert's paradox implies that no set with the above properties exists . [ 9 ] For suppose V {\\displaystyle V} was a set. Then V {\\displaystyle V} would be a subset of itself, and U = ∪ V {\\displaystyle U=\\cup V} would belong to V {\\displaystyle V} , and so would P ( U ) {\\displaystyle {\\mathcal {P}}(U)} . But more generally, if A ∈ B {\\displaystyle A\\in B} , then A ⊆ ∪ B {\\displaystyle A\\subseteq \\cup B} . Hence, P ( U ) ⊆ ∪ V = U {\\displaystyle {\\mathcal {P}}(U)\\subseteq \\cup V=U} , which is impossible in models of ZFC such as V {\\displaystyle V} itself. Interestingly, x {\\displaystyle x} is a subset of V {\\displaystyle V} if, and only if, x {\\displaystyle x} is a member of V {\\displaystyle V} . Therefore, we can consider what happens if the union condition is replaced with x ∈ V ⟹ ∪ x ∈ V {\\displaystyle x\\in V\\implies \\cup x\\in V} . In this case, there are no known contradictions, and any Grothendieck universe satisfies the new pair of properties.",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann_universe",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:11.213476",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:11.213476",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:11.213476",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749014895942_5081",
    "text": "[ 3 ] Classes in set theory [ edit ] The uses of classes [ edit ] Classes have several uses in NBG: They produce a finite axiomatization of set theory. [ 4 ] They are used to state a \"very strong form of the axiom of choice \" [ 5 ] —namely, the axiom of global choice : There exists a global choice function G {\\displaystyle G} defined on the class of all nonempty sets such that G ( x ) ∈ x {\\displaystyle G(x)\\in x} for every nonempty set x . {\\displaystyle x.} This is stronger than ZFC's axiom of choice: For every set s {\\displaystyle s} of nonempty sets, there exists a choice function f {\\displaystyle f} defined on s {\\displaystyle s} such that f ( x ) ∈ x {\\displaystyle f(x)\\in x} for all x ∈ s . {\\displaystyle x\\in s.} [ a ] The set-theoretic paradoxes are handled by recognizing that some classes cannot be sets. For example, assume that the class O r d {\\displaystyle Ord} of all ordinals is a set.",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:15.942145",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:15.942145",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:15.942145",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749014895972_7770",
    "text": "The constructible universe is the image of this function. [ 7 ] Axiom schema versus class existence theorem [ edit ] Once classes are added to the language of ZFC, it is easy to transform ZFC into a set theory with classes. First, the axiom schema of class comprehension is added. This axiom schema states: For every formula ϕ ( x 1 , … , x n ) {\\displaystyle \\phi (x_{1},\\ldots ,x_{n})} that quantifies only over sets, there exists a class A {\\displaystyle A} consisting of the n {\\displaystyle n} - tuples satisfying the formula—that is, ∀ x 1 ⋯ ∀ x n [ ( x 1 , … , x n ) ∈ A ⟺ ϕ ( x 1 , … , x n ) ] . {\\displaystyle \\forall x_{1}\\cdots \\,\\forall x_{n}[(x_{1},\\ldots ,x_{n})\\in A\\iff \\phi (x_{1},\\ldots ,x_{n})].} Then the axiom schema of replacement is replaced by a single axiom that uses a class. Finally, ZFC's axiom of extensionality is modified to handle classes: If two classes have the same elements, then they are identical. The other axioms of ZFC are not modified. [ 8 ]",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:15.972683",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:15.972683",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:15.972683",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749014896003_4561",
    "text": "[ non-primary source needed ] Bernays used many-sorted logic with two sorts: classes and sets. [ 2 ] Gödel avoided sorts by introducing primitive predicates: C l s ( A ) {\\displaystyle {\\mathfrak {Cls}}(A)} for \" A {\\displaystyle A} is a class\" and M ( A ) {\\displaystyle {\\mathfrak {M}}(A)} for \" A {\\displaystyle A} is a set\" (in German, \"set\" is Menge ). He also introduced axioms stating that every set is a class and that if class A {\\displaystyle A} is a member of a class, then A {\\displaystyle A} is a set. [ 9 ] Using predicates is the standard way to eliminate sorts. Elliott Mendelson modified Gödel's approach by having everything be a class and defining the set predicate M ( A ) {\\displaystyle M(A)} as ∃ C ( A ∈ C ) . {\\displaystyle \\exists C(A\\in C).} [ 10 ] This modification eliminates Gödel's class predicate and his two axioms. Bernays' two-sorted approach may appear more natural at first, but it creates a more complex theory.",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:16.003679",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:16.003679",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:16.003679",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749014896067_4815",
    "text": "ϕ ( x ) ) {\\displaystyle \\forall x{\\bigl (}\\exists C(x\\in C)\\implies \\phi (x){\\bigr )}} The following axioms and definitions are needed for the proof of the class existence theorem. Axiom of extensionality. If two classes have the same elements, then they are identical. ∀ A ∀ B [ ∀ x ( x ∈ A ⟺ x ∈ B ) ⟹ A = B ] {\\displaystyle \\forall A\\,\\forall B\\,[\\forall x(x\\in A\\iff x\\in B)\\implies A=B]} [ 13 ] This axiom generalizes ZFC's axiom of extensionality to classes. Axiom of pairing . If x {\\displaystyle x} and y {\\displaystyle y} are sets, then there exists a set p {\\displaystyle p} whose only members are x {\\displaystyle x} and y {\\displaystyle y} . ∀ x ∀ y ∃ p ∀ z [ z ∈ p ⟺ ( z = x ∨ z = y ) ] {\\displaystyle \\forall x\\,\\forall y\\,\\exists p\\,\\forall z\\,[z\\in p\\iff (z=x\\,\\lor \\,z=y)]} [ 14 ] As in ZFC, the axiom of extensionality implies the uniqueness of the set p {\\displaystyle p} , which allows us to introduce the notation { x , y } . {\\displaystyle \\{x,y\\}.}",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:16.067348",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:16.067348",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:16.067348",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749014896095_5637",
    "text": "Example 1: If the classes F {\\displaystyle F} and G {\\displaystyle G} are functions, then the composite function G ∘ F {\\displaystyle G\\circ F} is defined by the formula: ∃ t [ ( x , t ) ∈ F ∧ ( t , y ) ∈ G ] . {\\displaystyle \\exists t[(x,t)\\in F\\,\\land \\,(t,y)\\in G].} Since this formula has two free set variables, x {\\displaystyle x} and y , {\\displaystyle y,} the class existence theorem constructs the class of ordered pairs: G ∘ F = { ( x , y ) : ∃ t [ ( x , t ) ∈ F ∧ ( t , y ) ∈ G ] } . {\\displaystyle G\\circ F\\,=\\,\\{(x,y):\\exists t[(x,t)\\in F\\,\\land \\,(t,y)\\in G]\\}.} Because this formula is built from simpler formulas using conjunction ∧ {\\displaystyle \\land } and existential quantification ∃ {\\displaystyle \\exists } , class operations are needed that take classes representing the simpler formulas and produce classes representing the formulas with ∧ {\\displaystyle \\land } and ∃ {\\displaystyle \\exists } .",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:16.095865",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:16.095865",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:16.095865",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749014896132_8051",
    "text": "F ′ = { ( x , t , y ) : ( x , t ) ∈ F } {\\displaystyle F'=\\{(x,t,y):(x,t)\\in F\\}\\,} and G ′ = { ( t , y , x ) : ( t , y ) ∈ G } {\\displaystyle \\,G'=\\{(t,y,x):(t,y)\\in G\\}} In the definition of F ′ , {\\displaystyle F',} the variable y {\\displaystyle y} is not restricted by the statement ( x , t ) ∈ F , {\\displaystyle (x,t)\\in F,} so y {\\displaystyle y} ranges over the class V {\\displaystyle V} of all sets. Similarly, in the definition of G ′ , {\\displaystyle G',} the variable x {\\displaystyle x} ranges over V . {\\displaystyle V.} So an axiom is needed that adds an extra component (whose values range over V {\\displaystyle V} ) to the tuples of a given class. Next, the variables are put in the same order to prepare for the intersection: F ″ = { ( x , y , t ) : ( x , t ) ∈ F } {\\displaystyle F''=\\{(x,y,t):(x,t)\\in F\\}\\,} and G ″ = { ( x , y , t ) : ( t , y ) ∈ G } {\\displaystyle \\,G''=\\{(x,y,t):(t,y)\\in G\\}}",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:16.132087",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:16.133087",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:16.133087",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749014896162_7776",
    "text": "So axioms of intersection and domain are needed. The class existence axioms are divided into two groups: axioms handling language primitives and axioms handling tuples. There are four axioms in the first group and three axioms in the second group. [ d ] Axioms for handling language primitives: Membership. There exists a class E {\\displaystyle E} containing all the ordered pairs whose first component is a member of the second component. ∃ E ∀ x ∀ y [ ( x , y ) ∈ E ⟺ x ∈ y ] {\\displaystyle \\exists E\\,\\forall x\\,\\forall y\\,[(x,y)\\in E\\iff x\\in y]\\!} [ 18 ] Intersection (conjunction). For any two classes A {\\displaystyle A} and B {\\displaystyle B} , there is a class C {\\displaystyle C} consisting precisely of the sets that belong to both A {\\displaystyle A} and B {\\displaystyle B} . ∀ A ∀ B ∃ C ∀ x [ x ∈ C ⟺ ( x ∈ A ∧ x ∈ B ) ] {\\displaystyle \\forall A\\,\\forall B\\,\\exists C\\,\\forall x\\,[x\\in C\\iff (x\\in A\\,\\land \\,x\\in B)]} [ 19 ] Complement (negation).",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:16.162609",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:16.162609",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:16.162609",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749014896190_3099",
    "text": "A , {\\displaystyle \\complement A,} and D o m ( A ) , {\\displaystyle Dom(A),} respectively. [ e ] The first three axioms imply the existence of the empty class and the class of all sets: The membership axiom implies the existence of a class E . {\\displaystyle E.} The intersection and complement axioms imply the existence of E ∩ ∁ E {\\displaystyle E\\cap \\complement E} , which is empty. By the axiom of extensionality, this class is unique; it is denoted by ∅ . { \\displaystyle \\emptyset .} The complement of ∅ {\\displaystyle \\emptyset } is the class V {\\displaystyle V} of all sets, which is also unique by extensionality. The set predicate M ( A ) {\\displaystyle M(A)} , which was defined as ∃ C ( A ∈ C ) { \\displaystyle \\exists C(A\\in C)} , is now redefined as A ∈ V {\\displaystyle A\\in V} to avoid quantifying over classes. Axioms for handling tuples: Product by V {\\displaystyle V} .",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:16.190808",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:16.190808",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:16.190808",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory_1_1749014896221_2354",
    "text": "For any class A {\\displaystyle A} , there is a class B {\\displaystyle B} whose 3‑tuples are obtained by transposing the last two components of the 3‑tuples of A {\\displaystyle A} . ∀ A ∃ B ∀ x ∀ y ∀ z [ ( x , y , z ) ∈ B ⟺ ( x , z , y ) ∈ A ] {\\displaystyle \\forall A\\,\\exists B\\,\\forall x\\,\\forall y\\,\\forall z\\,[(x,y,z)\\in B\\iff (x,z,y)\\in A]} [ 25 ] By extensionality, the product by V {\\displaystyle V} axiom implies the existence of a unique class, which is denoted by A × V . {\\displaystyle A\\times V.} This axiom is used to define the class V n {\\displaystyle V^{n}} of all n {\\displaystyle n} -tuples : V 1 = V {\\displaystyle V^{1}=V} and V n + 1 = V n × V . {\\displaystyle V^{n+1}=V^{n}\\times V.\\,} If A {\\displaystyle A} is a class, extensionality implies that A ∩ V n {\\displaystyle A\\cap V^{n}} is the unique class consisting of the n {\\displaystyle n} -tuples of A .",
    "source_url": "https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:16.221171",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:16.222163",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:16.222163",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Non-deterministic_Turing_machine&redirect=no_1_1749014902595_6514",
    "text": "In cases of modification from distinctly longer or shorter names, please use {{ R from long name }} or {{ R from short name }} , respectively. An abbreviation should be tagged with {{ R from initialism }} or, if it can be spoken like a word such as NASA and RADAR, use {{ R from acronym }} . Use this rcat instead of {{ R from other capitalisation }} and {{ R from plural }} in namespaces other than mainspace for those types of modification. This may also apply to several other subcategories of modification; please check those templates' output before saving if using outside of mainspace. From a page move : This is a redirect from a page that has been moved (renamed). This page was kept as a redirect to avoid breaking links, both internal and external, that may have been made to the old page name. When appropriate, protection levels are automatically sensed, described and categorized.",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Non-deterministic_Turing_machine&redirect=no",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:22.595911",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:22.596911",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:22.596911",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quantum_phase_estimation_algorithm_1_1749014906448_1129",
    "text": "This evolution can also be written concisely as U C = ∑ k = 0 2 n − 1 | k ⟩ ⟨ k | ⊗ U k , {\\displaystyle U_{C}=\\sum _{k=0}^{2^{n}-1}|k\\rangle \\!\\langle k|\\otimes U^{k},} which highlights its controlled nature: it applies U k {\\displaystyle U^{k}} to the second register conditionally to the first register being | k ⟩ {\\displaystyle |k\\rangle } . Remembering the eigenvalue condition holding for | ψ ⟩ {\\displaystyle |\\psi \\rangle } , applying U C {\\displaystyle U_{C}} to | Ψ 1 ⟩ {\\displaystyle |\\Psi _{1}\\rangle } thus gives | Ψ 2 ⟩ ≡ U C | Ψ 1 ⟩ = ( 1 2 n / 2 ∑ k = 0 2 n − 1 e 2 π i θ k | k ⟩ ) ⊗ | ψ ⟩ , {\\displaystyle |\\Psi _{2}\\rangle \\equiv U_{C}|\\Psi _{1}\\rangle =\\left({\\frac {1}{2^{n/2}}}\\sum _{k=0}^{2^{n}-1}e^{2\\pi i\\theta k}|k\\rangle \\right)\\otimes |\\psi \\rangle ,} where we used U k | ψ ⟩ = e 2 π i k θ | ψ ⟩ {\\displaystyle U^{k}|\\psi \\rangle =e^{2\\pi ik\\theta }|\\psi \\rangle } .",
    "source_url": "https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:26.448138",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:26.448138",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:26.448138",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quantum_phase_estimation_algorithm_1_1749014906593_8565",
    "text": "N − 1 e 2 π i N j k | j ⟩ , Q F T N − 1 | k ⟩ = N − 1 / 2 ∑ j = 0 N − 1 e − 2 π i N j k | j ⟩ . {\\displaystyle {\\begin{aligned}{\\mathcal {QFT}}_{N}|k\\rangle &=N^{-1/2}\\sum _{j=0}^{N-1}e^{{\\frac {2\\pi i}{N}}jk}|j\\rangle ,\\\\{\\mathcal {QFT}}_{N}^{-1}|k\\rangle &=N^{-1/2}\\sum _{j=0}^{N-1}e^{-{\\frac {2\\pi i}{N}}jk}|j\\rangle .\\end{aligned}}} It follows that | Ψ ~ 3 ⟩ = 1 2 n 2 ∑ k = 0 2 n − 1 e 2 π i θ k ( 1 2 n 2 ∑ x = 0 2 n − 1 e − 2 π i k x 2 n | x ⟩ ) = 1 2 n ∑ x = 0 2 n − 1 ∑ k = 0 2 n − 1 e − 2 π i k 2 n ( x − 2 n θ ) | x ⟩ . {\\displaystyle |{\\tilde {\\Psi }}_{3}\\rangle ={\\frac {1}{2^{\\frac {n}{2}}}}\\sum _{k=0}^{2^{n}-1}e^{2\\pi i\\theta k}\\left({\\frac {1}{2^{\\frac {n}{2}}}}\\sum _{x=0}^{2^{n}-1}e^{\\frac {-2\\pi ikx}{2^{n}}}|x\\rangle \\right)={\\frac {1}{2^{n}}}\\sum _{x=0}^{2^{n}-1}\\sum _{k=0}^{2^{n}-1}e^{-{\\frac {2\\pi ik}{2^{n}}}\\left(x-2^{n}\\theta \\right)}|x\\rangle .}",
    "source_url": "https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:26.593547",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:26.593547",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:26.593547",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Quantum_phase_estimation_algorithm&oldid=1277535446_1_1749014908370_1835",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Chococandy9 ( talk | contribs ) at 06:19, 25 February 2025 (Fix the latex, removing all the \"[6pt]\" stuff.) . The present address (URL) is a permanent link to this version. Revision as of 06:19, 25 February 2025 by Chococandy9 ( talk | contribs ) (Fix the latex, removing all the \"[6pt]\" stuff.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Quantum algori",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Quantum_phase_estimation_algorithm&oldid=1277535446",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:28.370962",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:28.370962",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:28.370962",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quantum_approximate_optimization_algorithm_1_1749014910211_5706",
    "text": "The variable X {\\displaystyle X} must lie in the (closed convex) cone of positive semidefinite symmetric matrices S + n {\\displaystyle \\mathbb {S} _{+}^{n}} . The inner product of two matrices is defined as: ⟨ A , B ⟩ S n = t r ( A T B ) = ∑ i = 1 , j = 1 n A i j B i j . {\\displaystyle \\langle A,B\\rangle _{\\mathbb {S} ^{n}}={\\rm {tr}}(A^{T}B)=\\sum _{i=1,j=1}^{n}A_{ij}B_{ij}.} The problem may have additional constraints (given as inputs), also usually formulated as inner products. Each constraint forces the inner product of the matrices A k {\\displaystyle A_{k}} (given as an input) with the optimization variable X {\\displaystyle X} to be smaller than a specified value b k {\\displaystyle b_{k}} (given as an input).",
    "source_url": "https://en.wikipedia.org/wiki/Quantum_approximate_optimization_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:30.211846",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:30.212840",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:30.212840",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quantum_approximate_optimization_algorithm_1_1749014910412_5470",
    "text": "Defining a mixer Hamiltonian H M {\\displaystyle H_{M}} . Defining the oracles U C ( γ ) = exp ⁡ ( − ı γ H C ) {\\displaystyle U_{C}(\\gamma ) =\\exp(-\\imath \\gamma H_{C})} and U M ( α ) = exp ⁡ ( − ı α H M ) {\\displaystyle U_{M}(\\alpha )=\\exp(-\\imath \\alpha H_{M})} , with parameters γ {\\displaystyle \\gamma } and α. Repeated application of the oracles U C {\\displaystyle U_{C}} and U M {\\displaystyle U_{M}} , in the order: U ( γ , α ) = ∐ i = 1 N ( U C ( γ i ) U M ( α i ) ) {\\displaystyle U({\\boldsymbol {\\gamma }},{\\boldsymbol {\\alpha }})=\\coprod _{i=1}^{N}(U_{C}(\\gamma _{i})U_{M}(\\alpha _{i}))} Preparing an initial state, that is a superposition of all possible states and apply U ( γ , α ) {\\displaystyle U({\\boldsymbol {\\gamma }},{\\boldsymbol {\\alpha }})} to the state.",
    "source_url": "https://en.wikipedia.org/wiki/Quantum_approximate_optimization_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:30.412365",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:30.412365",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:30.412365",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quantum_optimization_algorithms_1_1749014913870_9803",
    "text": "The variable X {\\displaystyle X} must lie in the (closed convex) cone of positive semidefinite symmetric matrices S + n {\\displaystyle \\mathbb {S} _{+}^{n}} . The inner product of two matrices is defined as: ⟨ A , B ⟩ S n = t r ( A T B ) = ∑ i = 1 , j = 1 n A i j B i j . {\\displaystyle \\langle A,B\\rangle _{\\mathbb {S} ^{n}}={\\rm {tr}}(A^{T}B)=\\sum _{i=1,j=1}^{n}A_{ij}B_{ij}.} The problem may have additional constraints (given as inputs), also usually formulated as inner products. Each constraint forces the inner product of the matrices A k {\\displaystyle A_{k}} (given as an input) with the optimization variable X {\\displaystyle X} to be smaller than a specified value b k {\\displaystyle b_{k}} (given as an input).",
    "source_url": "https://en.wikipedia.org/wiki/Quantum_optimization_algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:33.870799",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:33.870799",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:33.870799",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quantum_optimization_algorithms_1_1749014914069_4388",
    "text": "Defining a mixer Hamiltonian H M {\\displaystyle H_{M}} . Defining the oracles U C ( γ ) = exp ⁡ ( − ı γ H C ) {\\displaystyle U_{C}(\\gamma ) =\\exp(-\\imath \\gamma H_{C})} and U M ( α ) = exp ⁡ ( − ı α H M ) {\\displaystyle U_{M}(\\alpha )=\\exp(-\\imath \\alpha H_{M})} , with parameters γ {\\displaystyle \\gamma } and α. Repeated application of the oracles U C {\\displaystyle U_{C}} and U M {\\displaystyle U_{M}} , in the order: U ( γ , α ) = ∐ i = 1 N ( U C ( γ i ) U M ( α i ) ) {\\displaystyle U({\\boldsymbol {\\gamma }},{\\boldsymbol {\\alpha }})=\\coprod _{i=1}^{N}(U_{C}(\\gamma _{i})U_{M}(\\alpha _{i}))} Preparing an initial state, that is a superposition of all possible states and apply U ( γ , α ) {\\displaystyle U({\\boldsymbol {\\gamma }},{\\boldsymbol {\\alpha }})} to the state.",
    "source_url": "https://en.wikipedia.org/wiki/Quantum_optimization_algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:34.069645",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:34.069645",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:34.069645",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithmic_cooling_1_1749014918149_5582",
    "text": "β | 1 ⟩ , {\\displaystyle |\\psi \\rangle =\\alpha |0\\rangle +\\beta |1\\rangle ,} where | α | 2 + | β | 2 = 1 {\\displaystyle |\\alpha |^{2}+|\\beta |^{2}=1} and α , β ∈ C {\\displaystyle \\alpha ,\\beta \\in \\mathbb {C} } . If one measures the state of the qubit in the orthonormal basis composed of | 0 ⟩ {\\displaystyle |0\\rangle } and | 1 ⟩ {\\displaystyle |1\\rangle } , one gets the result | 0 ⟩ {\\displaystyle |0\\rangle } with probability | α | 2 {\\displaystyle |\\alpha |^{2}} and the result | 1 ⟩ {\\displaystyle |1\\rangle } with probability | β | 2 {\\displaystyle |\\beta |^{2}} . The above description is known as a quantum pure state. A general mixed quantum state can be prepared as a probability distribution over pure states, and is represented by a density matrix of the general form ρ = ∑ i p i | ψ i ⟩ ⟨ ψ i | {\\textstyle \\rho =\\sum _{i}p_{i}|\\psi _{i}\\rangle \\langle \\psi _{i}|} , where each | ψ",
    "source_url": "https://en.wikipedia.org/wiki/Algorithmic_cooling",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:38.149617",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:38.150617",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:38.150617",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Quantum_algorithms&oldid=546482778_1_1749014928070_5882",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Addbot ( talk | contribs ) at 06:21, 23 March 2013 ( Bot: Migrating 7 interwiki links, now provided by Wikidata on d:q7783886 ) . The present address (URL) is a permanent link to this version. Revision as of 06:21, 23 March 2013 by Addbot ( talk | contribs ) ( Bot: Migrating 7 interwiki links, now provided by Wikidata on d:q7783886 ) ( diff ) ← Previous revision | Latest revision (d",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Quantum_algorithms&oldid=546482778",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:48.070652",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:48.070652",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:48.070652",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Operating_system_kernel_1_1749014930097_6722",
    "text": "Input/output devices [ edit ] I/O devices include, but are not limited to, peripherals such as keyboards, mice, disk drives, printers, USB devices, network adapters, and display devices . The kernel provides convenient methods for applications to use these devices which are typically abstracted by the kernel so that applications do not need to know their implementation details. Resource management [ edit ] Key aspects necessary in resource management are defining the execution domain ( address space ) and the protection mechanism used to mediate access to the resources within a domain. [ 5 ] Kernels also provide methods for synchronization and inter-process communication (IPC). These implementations may be located within the kernel itself or the kernel can also rely on other processes it is running.",
    "source_url": "https://en.wikipedia.org/wiki/Operating_system_kernel",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:50.097690",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:50.097690",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:50.097690",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shuffling_algorithm_1_1749014935530_4653",
    "text": "[ 1 ] In detail as normally performed, with the pack initially held in the left hand (say), most of the cards are grasped as a group from the bottom of the pack between the thumb and fingers of the right hand and lifted clear of the small group that remains in the left hand. Small packets are then released from the right hand a packet at a time so that they drop on the top of the pack accumulating in the left hand. The process is repeated several times. The randomness of the whole shuffle is increased by the number of small packets in each shuffle and the number of repeat shuffles performed. The overhand shuffle offers sufficient opportunity for sleight of hand techniques to be used to affect the ordering of cards, creating a stacked deck.",
    "source_url": "https://en.wikipedia.org/wiki/Shuffling_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:55.530242",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:55.530242",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:55.530242",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shuffling_algorithm_1_1749014935554_9136",
    "text": "The most common way that players cheat with the overhand shuffle is by having a card at the top or bottom of the pack that they require, and then slipping it to the bottom at the start of a shuffle (if it was on top to start), or leaving it as the last card in a shuffle and just dropping it on top (if it was originally on the bottom of the deck). Riffle [ edit ] Cards lifted after a riffle shuffle, forming what is called a bridge which puts the cards back into place After a riffle shuffle, the cards cascade A common shuffling technique is called the riffle, or dovetail shuffle or leafing the cards , in which half of the deck is held in each hand with the thumbs inward, then cards are released by the thumbs so that they fall to the table interleaved.",
    "source_url": "https://en.wikipedia.org/wiki/Shuffling_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:55.554242",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:55.554242",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:55.554242",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shuffling_algorithm_1_1749014935580_1501",
    "text": "Many also lift the cards up after a riffle, forming what is called a bridge which puts the cards back into place; it can also be done by placing the halves flat on the table with their rear corners touching, then lifting the back edges with the thumbs while pushing the halves together. While this method is more difficult, it is often used in casinos because it minimizes the risk of exposing cards during the shuffle. There are two types of perfect riffle shuffles: if the top card moves to be second from the top then it is an in shuffle , otherwise it is known as an out shuffle (which preserves both the top and bottom cards). The Gilbert–Shannon–Reeds model provides a mathematical model of the random outcomes of riffling that has been shown experimentally to be a good fit to human shuffling [ 2 ] and that forms the basis for a recommendation that card decks be riffled seven times in order to randomize them thoroughly.",
    "source_url": "https://en.wikipedia.org/wiki/Shuffling_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:55.580242",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:55.580242",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:55.580242",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shuffling_algorithm_1_1749014935967_7495",
    "text": "[ 3 ] Later, mathematicians Lloyd M. Trefethen and Lloyd N. Trefethen authored a paper using a tweaked version of the Gilbert–Shannon–Reeds model showing that the minimum number of riffles for total randomization could also be six, if the method of defining randomness is changed. [ 4 ] [ 5 ] Box [ edit ] Also known as \"strip.\" The deck is held from the top by one hand close to the top of the table, and a pile is stripped off the top of the deck with the other hand and placed on the table. Additional piles are stripped off and placed on top of the previous pile until all cards have been placed onto the new pile. Boxing the cards is functionally the same as an overhand shuffle, however, by keeping the cards close to the table, it is less likely that cards will be accidentally exposed. Hindu [ edit ] Also known as the \"Indian\", \"Kattar\", \"Kenchi\" ( Hindi for scissor) or \"Kutti Shuffle\".",
    "source_url": "https://en.wikipedia.org/wiki/Shuffling_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:55.967578",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:55.967578",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:55.967578",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shuffling_algorithm_1_1749014935996_1386",
    "text": "The deck is held face down, with the middle finger on one long edge and the thumb on the other on the bottom half of the deck. The other hand draws off a packet from the top of the deck. This packet is allowed to drop into the palm. The maneuver is repeated over and over, with newly drawn packets dropping onto previous ones, until the deck is all in the second hand. Indian shuffle differs from stripping in that all the action is in the hand taking the cards, whereas in stripping, the action is performed by the hand with the original deck, giving the cards to the resulting pile. This is the most common shuffling technique in Asia and other parts of the world, while the overhand shuffle is primarily used in Western countries. Pile [ edit ] Cards are simply dealt out into a number of piles, then the piles are stacked on top of each other. Though this is deterministic and does not randomize the cards at all, it ensures that cards that were next to each other are now separated.",
    "source_url": "https://en.wikipedia.org/wiki/Shuffling_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:55.996151",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:55.997153",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:55.997153",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shuffling_algorithm_1_1749014936024_2606",
    "text": "Some variations on the pile shuffle attempt to make it slightly random by dealing to the piles in a random order each circuit. 52 pickup [ edit ] Main article: 52 pickup A person may throw a deck of cards into the air or across a surface, and then pick up the cards in random order, assembled with the cards facing the same direction. If specific cards are observed too closely as they are picked up, an additional 52 pickup or an additional shuffling method may be needed for sufficient randomization. This method is useful for beginners, but the shuffle requires a large clean surface for spreading out the cards, and it may take more time than is desired. ' A game of 52 pickup' is also the name of a child's prank, where one child asks a 'friend' if they want to play 52 pickup. They then throw the cards into the air, and demand the other child 'pick them up'. Corgi [ edit ] This method is similar to 52 pickup and also useful for beginners.",
    "source_url": "https://en.wikipedia.org/wiki/Shuffling_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:56.024503",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:56.025503",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:56.025503",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shuffling_algorithm_1_1749014936048_8243",
    "text": "Corgi [ edit ] This method is similar to 52 pickup and also useful for beginners. Also known as the Chemmy, Irish, wash, scramble, hard shuffle, smooshing, schwirsheling [ citation needed ] , or washing the cards, this involves simply spreading the cards out face down, and sliding them around and over each other with one's hands. Then the cards are moved into one pile so that they begin to intertwine and are then arranged back into a stack. Statistically random shuffling is achieved after approximately one minute of smooshing. Smooshing has been largely popularized by Simon Hofman. [ 6 ] Mongean [ edit ] The Mongean shuffle, or Monge's shuffle, is performed as follows (by a right-handed person): Start with the unshuffled deck in the left hand and transfer the top card to the right.",
    "source_url": "https://en.wikipedia.org/wiki/Shuffling_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:56.048552",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:56.048552",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:56.048552",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shuffling_algorithm_1_1749014936078_5837",
    "text": "Then repeatedly take the top card from the left hand and transfer it to the right, putting the second card at the top of the new deck, the third at the bottom, the fourth at the top, the fifth at the bottom, etc. The result, if one started with cards numbered consecutively 1 , 2 , 3 , 4 , 5 , 6 , … , 2 n {\\displaystyle \\scriptstyle 1,2,3,4,5,6,\\dots ,2n} , would be a deck with the cards in the following order: 2 n , 2 n − 2 , 2 n − 4 , … , 4 , 2 , 1 , 3 , … , 2 n − 3 , 2 n − 1 {\\displaystyle \\scriptstyle 2n,2n-2,2n-4,\\dots ,4,2,1,3,\\dots ,2n-3,2n-1} . Faro [ edit ] Main article: Faro shuffle Weaving is the procedure of pushing the ends of two halves of a deck against each other in such a way that they naturally intertwine. Sometimes the deck is split into equal halves of 26 cards which are then pushed together in a certain way so as to make them perfectly interweave. This is known as a Faro Shuffle .",
    "source_url": "https://en.wikipedia.org/wiki/Shuffling_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:56.078128",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:56.078128",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:56.078128",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ford%E2%80%93Johnson_algorithm_1_1749014938253_9005",
    "text": "[ 1 ] To choose an insertion ordering that produces these lengths, consider the sorted sequence S {\\displaystyle S} after step 4 of the outline above (before inserting the remaining elements),\nand let x i {\\displaystyle x_{i}} denote the i {\\displaystyle i} th element of this sorted sequence. Thus, S = ( x 1 , x 2 , x 3 , … ) , {\\displaystyle S=(x_{1},x_{2},x_{3},\\dots ),} where each element x i {\\displaystyle x_{i}} with i ≥ 3 {\\displaystyle i\\geq 3} is paired with an element y i < x i {\\displaystyle y_{i}<x_{i}} that has not yet been inserted. (There are no elements y 1 {\\displaystyle y_{1}} or y 2 {\\displaystyle y_{2}} because x 1 {\\displaystyle x_{1}} and x 2 {\\displaystyle x_{2}} were paired with each other.) If n {\\displaystyle n} is odd, the remaining unpaired element should also be numbered as y i {\\displaystyle y_{i}} with i {\\displaystyle i} larger than the indexes of the paired elements.",
    "source_url": "https://en.wikipedia.org/wiki/Ford%E2%80%93Johnson_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:58.253999",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:58.253999",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:58.253999",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ford%E2%80%93Johnson_algorithm_1_1749014938282_6333",
    "text": "Then, the final step of the outline above can be expanded into the following steps: [ 1 ] [ 2 ] [ 3 ] [ 4 ] Partition the uninserted elements y i {\\displaystyle y_{i}} into groups with contiguous indexes. There are two elements y 3 {\\displaystyle y_{3}} and y 4 {\\displaystyle y_{4}} in the first group, and the sums of sizes of every two adjacent groups form a sequence of powers of two. Thus, the sizes of groups are: 2, 2, 6, 10, 22, 42, ... Order the uninserted elements by their groups (smaller indexes to larger indexes), but within each group order them from larger indexes to smaller indexes. Thus, the ordering becomes y 4 , y 3 , y 6 , y 5 , y 12 , y 11 , y 10 , y 9 , y 8 , y 7 , y 22 , y 21 … {\\displaystyle y_{4},y_{3},y_{6},y_{5},y_{12},y_{11},y_{10},y_{9},y_{8},y_{7},y_{22},y_{21}\\dots } Use this ordering to insert the elements y i {\\displaystyle y_{i}} into S {\\displaystyle S} .",
    "source_url": "https://en.wikipedia.org/wiki/Ford%E2%80%93Johnson_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:58.282000",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:58.282000",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:58.282000",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ford%E2%80%93Johnson_algorithm_1_1749014938338_9050",
    "text": "First, y 4 {\\displaystyle y_{4}} is inserted into the three-element subsequence ( x 1 , x 2 , x 3 ) {\\displaystyle (x_{1},x_{2},x_{3})} . Then, y 3 {\\displaystyle y_{3}} is inserted into some permutation of the three-element subsequence ( x 1 , x 2 , y 4 ) {\\displaystyle (x_{1},x_{2},y_{4})} , or in some cases into the two-element subsequence ( x 1 , x 2 ) {\\displaystyle (x_{1},x_{2})} . Similarly, the elements y 6 {\\displaystyle y_{6}} and y 5 {\\displaystyle y_{5}} of the second group are each inserted into a subsequence of length at most seven, using three comparisons. More generally, the worst-case number of comparisons for the elements in the i {\\displaystyle i} th group is i + 1 {\\displaystyle i+1} , because each is inserted into a subsequence of length at most 2 i + 1 − 1 {\\displaystyle 2^{i+1}-1} .",
    "source_url": "https://en.wikipedia.org/wiki/Ford%E2%80%93Johnson_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:58.338157",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:58.338157",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:58.338157",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ford%E2%80%93Johnson_algorithm_1_1749014938374_5177",
    "text": "[ 1 ] [ 2 ] [ 3 ] [ 4 ] By summing the number of comparisons used for all the elements and solving the resulting recurrence relation ,\nthis analysis can be used to compute the values of C ( n ) {\\displaystyle C(n)} , giving the formula [ 7 ] C ( n ) = ∑ i = 1 n ⌈ log 2 ⁡ 3 i 4 ⌉ ≈ n log 2 ⁡ n − 1.415 n {\\displaystyle C(n)=\\sum _{i=1}^{n}\\left\\lceil \\log _{2}{\\frac {3i}{4}}\\right\\rceil \\approx n\\log _{2}n-1.415n} or, in closed form , [ 8 ] C ( n ) = n ⌈ log 2 ⁡ 3 n 4 ⌉ − ⌊ 2 ⌊ log 2 ⁡ 6 n ⌋ 3 ⌋ + ⌊ log 2 ⁡ 6 n 2 ⌋ . {\\displaystyle C(n)=n{\\biggl \\lceil }\\log _{2}{\\frac {3n}{4}}{\\biggr \\rceil }-{\\biggl \\lfloor }{\\frac {2^{\\lfloor \\log _{2}6n\\rfloor }}{3}}{\\biggr \\rfloor }+{\\biggl \\lfloor }{\\frac {\\log _{2}6n}{2}}{\\biggr \\rfloor }.} For n = 1 , 2 , … {\\displaystyle n=1,2,\\dots } the numbers of comparisons are [ 1 ] 0, 1, 3, 5, 7, 10, 13, 16, 19, 22, 26, 30, 34, ... (sequence A001768 in the OEIS ) Relation to other comparison sorts [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Ford%E2%80%93Johnson_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:28:58.374157",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:28:58.374157",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:28:58.374157",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662_1_1749014953454_1872",
    "text": "Crucially, a {\\displaystyle a} and b {\\displaystyle b} must not depend on n {\\displaystyle n} . The theorem below also assumes that, as a base case for the recurrence, T ( n ) = Θ ( 1 ) {\\displaystyle T(n)=\\Theta (1)} when n {\\displaystyle n} is less than some bound κ > 0 {\\displaystyle \\kappa >0} , the smallest input size that will lead to a recursive call. Recurrences of this form often satisfy one of the three following regimes, based on how the work to split/recombine the problem f ( n ) {\\displaystyle f(n)} relates to the critical exponent c crit = log b ⁡ a {\\displaystyle c_{\\operatorname {crit} }=\\log _{b}a} . (The table below uses standard big O notation ). Throughout, ( log ⁡ n ) k {\\displaystyle (\\log n)^{k}} is used for clarity, though in textbooks this is usually rendered log k ⁡ n {\\displaystyle \\log ^{k}n} . c crit = log b ⁡ a = log ⁡ ( # subproblems ) /",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:29:13.454765",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:29:13.454765",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:29:13.454765",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662_1_1749014953481_5668",
    "text": "c crit = log b ⁡ a = log ⁡ ( # subproblems ) / log ⁡ ( relative subproblem size ) {\\displaystyle c_{\\operatorname {crit} }=\\log _{b}a=\\log(\\#{\\text{subproblems}})/\\log({\\text{relative subproblem size}})} Case Description Condition on f ( n ) {\\displaystyle f(n)} in relation to c crit {\\displaystyle c_{\\operatorname {crit} }} , i.e. log b ⁡ a {\\displaystyle \\log _{b}a} Master Theorem bound Notational examples 1 Work to split/recombine a problem is dominated by subproblems. i.e. the recursion tree is leaf-heavy. When f ( n ) = O ( n c ) {\\displaystyle f(n)=O(n^{c})} where c < c crit {\\displaystyle c<c_{\\operatorname {crit} }} (upper-bounded by a lesser exponent polynomial) ... then T ( n ) = Θ ( n c crit ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}\\right)} (The splitting term does not appear; the recursive tree structure dominates.)",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:29:13.481772",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:29:13.482772",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:29:13.482772",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662_1_1749014953516_9160",
    "text": "If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = O ( n 1 / 2 − ϵ ) {\\displaystyle f(n)=O(n^{1/2-\\epsilon })} , then T ( n ) = Θ ( n 1 / 2 ) {\\displaystyle T(n)=\\Theta (n^{1/2})} . 2 Work to split/recombine a problem is comparable to subproblems. When f ( n ) = Θ ( n c crit ( log ⁡ n ) k ) {\\displaystyle f(n)=\\Theta (n^{c_{\\operatorname {crit} }}(\\log n)^{k})} for a k ≥ 0 {\\displaystyle k\\geq 0} (rangebound by the critical-exponent polynomial, times zero or more optional log {\\displaystyle \\log } s) ... then T ( n ) = Θ ( n c crit ( log ⁡ n ) k + 1 ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}(\\log n)^{k+1}\\right)} (The bound is the splitting term, where the log is augmented by a single power.) If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 ) {\\displaystyle f(n)=\\Theta (n^{1/2})} , then T ( n ) = Θ ( n 1 / 2 log ⁡ n ) {\\displaystyle T(n)=\\Theta (n^{1/2}\\log n)} .",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:29:13.516009",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:29:13.516009",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:29:13.516009",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662_1_1749014953547_6625",
    "text": "If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 log ⁡ n ) {\\displaystyle f(n)=\\Theta (n^{1/2}\\log n)} , then T ( n ) = Θ ( n 1 / 2 ( log ⁡ n ) 2 ) {\\displaystyle T(n)=\\Theta (n^{1/2}(\\log n)^{2})} . 3 Work to split/recombine a problem dominates subproblems. i.e. the recursion tree is root-heavy. When f ( n ) = Ω ( n c ) {\\displaystyle f(n)=\\Omega (n^{c})} where c > c crit {\\displaystyle c>c_{\\operatorname {crit} }} (lower-bounded by a greater-exponent polynomial) ... this doesn't necessarily yield anything. Furthermore, if a f ( n b ) ≤ k f ( n ) {\\displaystyle af\\left({\\frac {n}{b}}\\right)\\leq kf(n)} for some constant k < 1 {\\displaystyle k<1} and all sufficiently large n {\\displaystyle n} (often called the regularity condition ) then the total is dominated by the splitting term f ( n ) {\\displaystyle f(n)} : T ( n ) = Θ ( f ( n ) ) {\\displaystyle T\\left(n\\right)=\\Theta \\left(f(n)\\right)}",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:29:13.547063",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:29:13.548063",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:29:13.548063",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662_1_1749014953579_2949",
    "text": "If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Ω ( n 1 / 2 + ϵ ) {\\displaystyle f(n)=\\Omega (n^{1/2+\\epsilon })} and the regularity condition holds, then T ( n ) = Θ ( f ( n ) ) {\\displaystyle T(n)=\\Theta (f(n))} . A useful extension of Case 2 handles all values of k {\\displaystyle k} : [ 3 ] Case Condition on f ( n ) {\\displaystyle f(n)} in relation to c crit {\\displaystyle c_{\\operatorname {crit} }} , i.e. log b ⁡ a {\\displaystyle \\log _{b}a} Master Theorem bound Notational examples 2a When f ( n ) = Θ ( n c crit ( log ⁡ n ) k ) {\\displaystyle f(n)=\\Theta (n^{c_{\\operatorname {crit} }}(\\log n)^{k})} for any k > − 1 {\\displaystyle k>-1} ... then T ( n ) = Θ ( n c crit ( log ⁡ n ) k + 1 ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}(\\log n)^{k+1}\\right)} (The bound is the splitting term, where the log is augmented by a single power.)",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:29:13.579069",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:29:13.579069",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:29:13.579069",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662_1_1749014953617_2113",
    "text": "If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 / ( log ⁡ n ) 1 / 2 ) {\\displaystyle f(n)=\\Theta (n^{1/2}/(\\log n)^{1/2})} , then T ( n ) = Θ ( n 1 / 2 ( log ⁡ n ) 1 / 2 ) {\\displaystyle T(n)=\\Theta (n^{1/2}(\\log n)^{1/2})} . 2b When f ( n ) = Θ ( n c crit ( log ⁡ n ) k ) {\\displaystyle f(n)=\\Theta (n^{c_{\\operatorname {crit} }}(\\log n)^{k})} for k = − 1 {\\displaystyle k=-1} ... then T ( n ) = Θ ( n c crit log ⁡ log ⁡ n ) {\\displaystyle T(n)=\\Theta \\left(n^{c_{\\operatorname {crit} }}\\log \\log n\\right)} (The bound is the splitting term, where the log reciprocal is replaced by an iterated log.) If b = a 2 {\\displaystyle b=a^{2}} and f ( n ) = Θ ( n 1 / 2 / log ⁡ n ) {\\displaystyle f(n)=\\Theta (n^{1/2}/\\log n)} , then T ( n ) = Θ ( n 1 / 2 log ⁡ log ⁡ n ) {\\displaystyle T(n)=\\Theta (n^{1/2}\\log \\log n)} . 2c When f ( n ) = Θ ( n c crit ( log ⁡ n ) k ) {\\displaystyle f(n)=\\Theta (n^{c_{\\operatorname {crit} }}(\\log n)^{k})} for any k < − 1 {\\displaystyle k<-1} ...",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Master_theorem_(analysis_of_algorithms)&oldid=1277959662",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:29:13.617199",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:29:13.617199",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:29:13.617199",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Kernel_(operating_system)_1_1749014967182_7907",
    "text": "Input/output devices [ edit ] I/O devices include, but are not limited to, peripherals such as keyboards, mice, disk drives, printers, USB devices, network adapters, and display devices . The kernel provides convenient methods for applications to use these devices which are typically abstracted by the kernel so that applications do not need to know their implementation details. Resource management [ edit ] Key aspects necessary in resource management are defining the execution domain ( address space ) and the protection mechanism used to mediate access to the resources within a domain. [ 5 ] Kernels also provide methods for synchronization and inter-process communication (IPC). These implementations may be located within the kernel itself or the kernel can also rely on other processes it is running.",
    "source_url": "https://en.wikipedia.org/wiki/Kernel_(operating_system)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:29:27.182608",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:29:27.182608",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:29:27.182608",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Usage_share_of_operating_systems_1_1749014974613_7469",
    "text": "However, in the end, according to Gartner, PC shipments grew 10.7% in the fourth quarter of 2020 and reached 275 million units in 2020, a 4.8% increase from 2019 and the highest growth in ten years.\" Apple in 4th place for PCs had the largest growth in shipments for a company in Q4 of 31.3%, while \"the fourth quarter of 2020 was another remarkable period of growth for Chromebooks, with shipments increasing around 200% year over year to reach 11.7 million units. In 2020, Chromebook shipments increased over 80% to total nearly 30 million units, largely due to demand from the North American education market.\" Chromebooks sold more (30 million) than Apple's Macs worldwide (22.5 million) in pandemic year 2020. [ 25 ] According to the Catalyst group, the year 2021 had record high PC shipments with total shipments of 341 million units (including Chromebooks), 15% higher than 2020 and 27% higher than 2019, while being the largest shipment total since 2012. [ 26 ]",
    "source_url": "https://en.wikipedia.org/wiki/Usage_share_of_operating_systems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:29:34.613481",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:29:34.613481",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:29:34.613481",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Usage_share_of_operating_systems_1_1749014974670_9090",
    "text": "— USA Today [ 29 ] This conflicts with statistics from IDC that say the tablet market contracted by 10% in 2015 with only Huawei , ranked fifth, with big gains, more than doubling their share; for fourth quarter 2015, the five biggest vendors were the same except that Amazon Fire tablets ranked third worldwide, new on the list, enabled by its not quite tripling of market share to 7.9%, with its Fire OS Android-derivative. [ 30 ] Global tablet shipments [ a ] Source Year Android iOS Windows Others Strategy Analytics [ 31 ] Q2 2022 49% 38% 11% 2% Statista [ 32 ] 2020 59.4% 29.8% 10.21% 0.59% Strategy Analytics [ 33 ] 2015 68% 22% 10% <0.1% Gartner [ 34 ] 2013 61.9% 36.0% 2.1% <0.1% Gartner [ 34 ] 2012 45.8% 52.8% 1.0% 0.3% Gartner excludes some devices from their tablet shipment statistic and includes them in a different category called \"premium ultramobiles\" with screen sizes of more than 10\" inches.",
    "source_url": "https://en.wikipedia.org/wiki/Usage_share_of_operating_systems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:29:34.670387",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:29:34.670387",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:29:34.670387",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Usage_share_of_operating_systems_1_1749014974719_2336",
    "text": "[ 48 ] iOS Others Counterpoint [ 49 ] Units sold per quarter 2024 Q4 74% 4% 22% 0% Gartner [ 50 ] Units sold in quarter 2018 Q1 85.9% — 14.1% 0.0% Gartner [ 51 ] Units sold per year 2017 85.9% — 14.0% 0.1% Gartner [ 52 ] Units sold in quarter 2017 Q1 86.1% — 13.7% 0.2% Smartphone shipments by OS until 2016 Source Method Year/quarter Android (including forks ) BlackBerry (all versions) iOS Symbian Windows (all versions)",
    "source_url": "https://en.wikipedia.org/wiki/Usage_share_of_operating_systems",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:29:34.719072",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:29:34.719072",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:29:34.719072",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_%C3%89sope_(operating_system)_1_1749014990336_8309",
    "text": "Jump to content From Wikipedia, the free encyclopedia You can help expand this article with text translated from the corresponding article in French . (March 2025) Click [show] for important translation instructions. View a machine-translated version of the French article. Machine translation, like DeepL or Google Translate , is a useful starting point for translations, but translators must revise errors as necessary and confirm that the translation is accurate, rather than simply copy-pasting m",
    "source_url": "https://en.wikipedia.org/wiki/%C3%89sope_(operating_system)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:29:50.336259",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:29:50.336259",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:29:50.336259",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Long_multiplication_1_1749015002453_9579",
    "text": "Grid method [ edit ] Main article: Grid method multiplication The grid method (or box method) is an introductory method for multiple-digit multiplication that is often taught to pupils at primary school or elementary school . It has been a standard part of the national primary school mathematics curriculum in England and Wales since the late 1990s. [ 3 ] Both factors are broken up (\"partitioned\") into their hundreds, tens and units parts, and the products of the parts are then calculated explicitly in a relatively simple multiplication-only stage, before these contributions are then totalled to give the final answer in a separate addition stage. The calculation 34 × 13, for example, could be computed using the grid: 300\n   40\n   90\n + 12\n ————\n  442 × 30 4 10 300 40 3 90 12 followed by addition to obtain 442, either in a single sum (see right), or through forming the row-by-row totals (300 + 40) + (90 + 12) = 340 + 102 = 442.",
    "source_url": "https://en.wikipedia.org/wiki/Long_multiplication",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:02.453048",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:02.454040",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:02.454040",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithmic_efficiency&oldid=1286247421_1_1749015006233_7437",
    "text": "O ( n ) {\\displaystyle O(n)} linear Finding an item in an unsorted list or a malformed tree (worst case) or in an unsorted array; Adding two n -bit integers by ripple carry .",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithmic_efficiency&oldid=1286247421",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:06.233727",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:06.233727",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:06.233727",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithmic_randomness_1_1749015009439_1743",
    "text": "[ 2 ] ) Theorem ( Abraham Wald , 1936, 1937) [ 3 ] If there are only countably many admissible rules, then almost any sequence is a collective. Proof sketch: Use measure-theoretic probability. Fix one admissible rule. Sample a random sequence from Bernoulli space. With probability 1 (use martingales), the subsequence picked by the admissible rule still has lim n 1 n ∑ i = 1 n x m i = p {\\displaystyle \\lim _{n}{\\frac {1}{n}}\\sum _{i=1}^{n}x_{m_{i}}=p} . Now add all the countably many rules. With probability 1, each subsequence picked by each rule still has lim n 1 n ∑ i = 1 n x m i = p {\\displaystyle \\lim _{n}{\\frac {1}{n}}\\sum _{i=1}^{n}x_{m_{i}}=p} . However, this definition was found not to be strong enough. Intuitively, the long-time average of a random sequence should oscillate on both sides of p {\\displaystyle p} , like how a random walk should cross the origin infinitely many times.",
    "source_url": "https://en.wikipedia.org/wiki/Algorithmic_randomness",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:09.439637",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:09.439637",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:09.439637",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Algorithmic_randomness_1_1749015009494_3604",
    "text": "For example, the Ville construction does not satisfy one of the laws of the iterated logarithm : lim sup n → ∞ − ∑ k = 1 n ( x k − 1 / 2 ) 2 n log ⁡ log ⁡ n ≠ 1 {\\displaystyle \\limsup _{n\\to \\infty }{\\frac {-\\sum _{k=1}^{n}(x_{k}-1/2)}{\\sqrt {2n\\log \\log n}}}\\neq 1} Naively, one can fix this by requiring a sequence to satisfy all possible laws of randomness, where a \"law of randomness\" is a property that is satisfied by all sequences with probability 1. However, for each infinite sequence y 1 : ∞ ∈ 2 N {\\displaystyle y_{1:\\infty }\\in 2^{\\mathbb {N} }} , we have a law of randomness that x 1 : ∞ ≠ y 1 : ∞ {\\displaystyle x_{1:\\infty }\\neq y_{1:\\infty }} , leading to the conclusion that there are no random sequences. ( Per Martin-Löf , 1966) [ 6 ] defined \"Martin-Löf randomness\" by only allowing laws of randomness that are Turing-computable. In other words, a sequence is random iff it passes all Turing-computable tests of randomness.",
    "source_url": "https://en.wikipedia.org/wiki/Algorithmic_randomness",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:09.494083",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:09.494083",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:09.494083",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quickselect_1_1749015015440_4830",
    "text": "This is known as the Lomuto partition scheme , which is simpler but less efficient than Hoare's original partition scheme . In quicksort, we recursively sort both branches, leading to best-case O ( n log ⁡ n ) { \\displaystyle O(n\\log n)} time. However, when doing selection, we already know which partition our desired element lies in, since the pivot is in its final sorted position, with all those preceding it in an unsorted order and all those following it in an unsorted order. Therefore, a single recursive call locates the desired element in the correct partition, and we build upon this for quickselect: // Returns the k-th smallest element of list within left..right inclusive // (i.e. left <= k <= right). function select(list, left, right, k) is if left = right then // If the list contains only one element, return list[left] // return that element pivotIndex  := ... //",
    "source_url": "https://en.wikipedia.org/wiki/Quickselect",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:15.440093",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:15.441093",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:15.441093",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Quickselect_1_1749015015547_5771",
    "text": "However, if bad pivots are consistently chosen, such as decreasing by only a single element each time, then worst-case performance is quadratic: O ( n 2 ) . {\\displaystyle O(n^{2}).} This occurs for example in searching for the maximum element of a set, using the first element as the pivot, and having sorted data. However, for randomly chosen pivots, this worst case is very unlikely: the probability of using more than C n {\\displaystyle Cn} comparisons, for any sufficiently large constant C {\\displaystyle C} , is superexponentially small as a function of C {\\displaystyle C} . [ 2 ] Variants [ edit ] The easiest solution is to choose a random pivot, which yields almost certain linear time. Deterministically, one can use median-of-3 pivot strategy (as in the quicksort), which yields linear performance on partially sorted data, as is common in the real world.",
    "source_url": "https://en.wikipedia.org/wiki/Quickselect",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:15.547129",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:15.548129",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:15.548129",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pocklington%27s_algorithm_1_1749015017784_6464",
    "text": "Solution method [ edit ] Pocklington separates 3 different cases for p : The first case, if p = 4 m + 3 {\\displaystyle p=4m+3} , with m ∈ N {\\displaystyle m\\in \\mathbb {N} } , the solution is x ≡ ± a m + 1 {\\displaystyle x\\equiv \\pm a^{m+1}} . The second case, if p = 8 m + 5 {\\displaystyle p=8m+5} , with m ∈ N {\\displaystyle m\\in \\mathbb {N} } and a 2 m + 1 ≡ 1 {\\displaystyle a^{2m+1}\\equiv 1} , the solution is x ≡ ± a m + 1 {\\displaystyle x\\equiv \\pm a^{m+1}} . a 2 m + 1 ≡ − 1 {\\displaystyle a^{2m+1}\\equiv -1} , 2 is a (quadratic) non-residue so 4 2 m + 1 ≡ − 1 {\\displaystyle 4^{2m+1}\\equiv -1} . This means that ( 4 a ) 2 m + 1 ≡ 1 {\\displaystyle (4a)^{2m+1}\\equiv 1} so y ≡ ± ( 4 a ) m + 1 {\\displaystyle y\\equiv \\pm (4a)^{m+1}} is a solution of y 2 ≡ 4 a {\\displaystyle y^{2}\\equiv 4a} . Hence x ≡ ± y / 2 {\\displaystyle x\\equiv \\pm y/2} or, if y is odd, x ≡ ± ( p + y ) / 2 {\\displaystyle x\\equiv \\pm (p+y)/2} .",
    "source_url": "https://en.wikipedia.org/wiki/Pocklington%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:17.784812",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:17.785811",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:17.785811",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pocklington%27s_algorithm_1_1749015017818_4974",
    "text": "The third case, if p = 8 m + 1 {\\displaystyle p=8m+1} , put D ≡ − a {\\displaystyle D\\equiv -a} , so the equation to solve becomes x 2 + D ≡ 0 {\\displaystyle x^{2}+D\\equiv 0} . Now find by trial and error t 1 {\\displaystyle t_{1}} and u 1 {\\displaystyle u_{1}} so that N = t 1 2 − D u 1 2 {\\displaystyle N=t_{1}^{2}-Du_{1}^{2}} is a quadratic non-residue. Furthermore, let t n = ( t 1 + u 1 D ) n + ( t 1 − u 1 D ) n 2 , u n = ( t 1 + u 1 D ) n − ( t 1 − u 1 D ) n 2 D {\\displaystyle t_{n}={\\frac {(t_{1}+u_{1}{\\sqrt {D}})^{n}+(t_{1}-u_{1}{\\sqrt {D}})^{n}}{2}},\\qquad u_{n}={\\frac {(t_{1}+u_{1}{\\sqrt {D}})^{n}-(t_{1}-u_{1}{\\sqrt {D}})^{n}}{2{\\sqrt {D}}}}} . The following equalities now hold: t m + n = t m t n + D u m u n , u m + n = t m u n + t n u m and t n 2 − D u n 2 = N n {\\displaystyle t_{m+n}=t_{m}t_{n}+Du_{m}u_{n},\\quad u_{m+n}=t_{m}u_{n}+t_{n}u_{m}\\quad {\\mbox{and}}\\quad t_{n}^{2}-Du_{n}^{2}=N^{n}} .",
    "source_url": "https://en.wikipedia.org/wiki/Pocklington%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:17.818642",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:17.818642",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:17.818642",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pocklington%27s_algorithm_1_1749015018233_7699",
    "text": "Supposing that p is of the form 4 m + 1 {\\displaystyle 4m+1} (which is true if p is of the form 8 m + 1 {\\displaystyle 8m+1} ), D is a quadratic residue and t p ≡ t 1 p ≡ t 1 , u p ≡ u 1 p D ( p − 1 ) / 2 ≡ u 1 {\\displaystyle t_{p}\\equiv t_{1}^{p}\\equiv t_{1},\\quad u_{p}\\equiv u_{1}^{p}D^{(p-1)/2}\\equiv u_{1}} . Now the equations t 1 ≡ t p − 1 t 1 + D u p − 1 u 1 and u 1 ≡ t p − 1 u 1 + t 1 u p − 1 {\\displaystyle t_{1}\\equiv t_{p-1}t_{1}+Du_{p-1}u_{1}\\quad {\\mbox{and}}\\quad u_{1}\\equiv t_{p-1}u_{1}+t_{1}u_{p-1}} give a solution t p − 1 ≡ 1 , u p − 1 ≡ 0 {\\displaystyle t_{p-1}\\equiv 1,\\quad u_{p-1}\\equiv 0} . Let p − 1 = 2 r {\\displaystyle p-1=2r} . Then 0 ≡ u p − 1 ≡ 2 t r u r {\\displaystyle 0\\equiv u_{p-1}\\equiv 2t_{r}u_{r}} . This means that either t r {\\displaystyle t_{r}} or u r {\\displaystyle u_{r}} is divisible by p . If it is u r {\\displaystyle u_{r}} , put r = 2 s {\\displaystyle r=2s} and proceed similarly with 0 ≡ 2 t s u s {\\displaystyle 0\\equiv 2t_{s}u_{s}} .",
    "source_url": "https://en.wikipedia.org/wiki/Pocklington%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:18.233775",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:18.233775",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:18.233775",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pocklington%27s_algorithm_1_1749015018263_5086",
    "text": "Not every u i {\\displaystyle u_{i}} is divisible by p , for u 1 {\\displaystyle u_{1}} is not. The case u m ≡ 0 {\\displaystyle u_{m}\\equiv 0} with m odd is impossible, because t m 2 − D u m 2 ≡ N m {\\displaystyle t_{m}^{2}-Du_{m}^{2}\\equiv N^{m}} holds and this would mean that t m 2 {\\displaystyle t_{m}^{2}} is congruent to a quadratic non-residue, which is a contradiction. So this loop stops when t l ≡ 0 {\\displaystyle t_{l}\\equiv 0} for a particular l . This gives − D u l 2 ≡ N l {\\displaystyle -Du_{l}^{2}\\equiv N^{l}} , and because − D {\\displaystyle -D} is a quadratic residue, l must be even. Put l = 2 k {\\displaystyle l=2k} . Then 0 ≡ t l ≡ t k 2 + D u k 2 {\\displaystyle 0\\equiv t_{l}\\equiv t_{k}^{2}+Du_{k}^{2}} . So the solution of x 2 + D ≡ 0 {\\displaystyle x^{2}+D\\equiv 0} is got by solving the linear congruence u k x ≡ ± t k {\\displaystyle u_{k}x\\equiv \\pm t_{k}} .",
    "source_url": "https://en.wikipedia.org/wiki/Pocklington%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:18.263767",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:18.264770",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:18.264770",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pocklington%27s_algorithm_1_1749015018344_5792",
    "text": "This is 23 = 4 ⋅ 5 + 3 {\\displaystyle 23=4\\cdot 5+3} , so m = 5 {\\displaystyle m=5} . The solution should be x ≡ ± 18 6 ≡ ± 8 ( mod 23 ) {\\displaystyle x\\equiv \\pm 18^{6}\\equiv \\pm 8{\\pmod {23}}} , which is indeed true: ( ± 8 ) 2 ≡ 64 ≡ 18 ( mod 23 ) {\\displaystyle (\\pm 8)^{2}\\equiv 64\\equiv 18{\\pmod {23}}} . Example 2 [ edit ] Solve the congruence x 2 ≡ 10 ( mod 13 ) . {\\displaystyle x^{2}\\equiv 10{\\pmod {13}}.} The modulus is 13. This is 13 = 8 ⋅ 1 + 5 {\\displaystyle 13=8\\cdot 1+5} , so m = 1 {\\displaystyle m=1} . Now verifying 10 2 m + 1 ≡ 10 3 ≡ − 1 ( mod 13 ) { \\displaystyle 10^{2m+1}\\equiv 10^{3}\\equiv -1{\\pmod {13}}} . So the solution is x ≡ ± y / 2 ≡ ± ( 4 a ) 2 / 2 ≡ ± 800 ≡ ± 7 ( mod 13 ) { \\displaystyle x\\equiv \\pm y/2\\equiv \\pm (4a)^{2}/2\\equiv \\pm 800\\equiv \\pm 7{\\pmod {13}}} . This is indeed true: ( ± 7 ) 2 ≡ 49 ≡ 10 ( mod 13 ) {\\displaystyle (\\pm 7)^{2}\\equiv 49\\equiv 10{\\pmod {13}}} .",
    "source_url": "https://en.wikipedia.org/wiki/Pocklington%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:18.344479",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:18.345479",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:18.345479",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pocklington%27s_algorithm_1_1749015018379_1318",
    "text": "Example 3 [ edit ] Solve the congruence x 2 ≡ 13 ( mod 17 ) {\\displaystyle x^{2}\\equiv 13{\\pmod {17}}} . For this, write x 2 − 13 = 0 {\\displaystyle x^{2}-13=0} . First find a t 1 {\\displaystyle t_{1}} and u 1 {\\displaystyle u_{1}} such that t 1 2 + 13 u 1 2 {\\displaystyle t_{1}^{2}+13u_{1}^{2}} is a quadratic nonresidue. Take for example t 1 = 3 , u 1 = 1 {\\displaystyle t_{1}=3,u_{1}=1} . Now find t 8 {\\displaystyle t_{8}} , u 8 {\\displaystyle u_{8}} by computing t 2 = t 1 t 1 + 13 u 1 u 1 = 9 − 13 = − 4 ≡ 13 ( mod 17 ) , {\\displaystyle t_{2}=t_{1}t_{1}+13u_{1}u_{1}=9-13=-4\\equiv 13{\\pmod {17}},} u 2 = t 1 u 1 + t 1 u 1 = 3 + 3 ≡ 6 ( mod 17 ) . {\\displaystyle u_{2}=t_{1}u_{1}+t_{1}u_{1}=3+3\\equiv 6{\\pmod {17}}.} And similarly t 4 = − 299 ≡ 7 ( mod 17 ) , u 4 = 156 ≡ 3 ( mod 17 ) {\\displaystyle t_{4}=-299\\equiv 7{\\pmod {17}},u_{4}=156\\equiv 3{\\pmod {17}}} such that t 8 = − 68 ≡ 0 ( mod 17 ) , u 8 = 42 ≡ 8 ( mod 17 ) .",
    "source_url": "https://en.wikipedia.org/wiki/Pocklington%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:18.379983",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:18.380987",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:18.380987",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pocklington%27s_algorithm_1_1749015018402_5058",
    "text": "{\\displaystyle t_{8}=-68\\equiv 0{\\pmod {17}},u_{8}=42\\equiv 8{\\pmod {17}}.} Since t 8 = 0 {\\displaystyle t_{8}=0} , the equation 0 ≡ t 4 2 + 13 u 4 2 ≡ 7 2 − 13 ⋅ 3 2 ( mod 17 ) {\\displaystyle 0\\equiv t_{4}^{2}+13u_{4}^{2}\\equiv 7^{2}-13\\cdot 3^{2}{\\pmod {17}}} which leads to solving the equation 3 x ≡ ± 7 ( mod 17 ) {\\displaystyle 3x\\equiv \\pm 7{\\pmod {17}}} . This has solution x ≡ ± 8 ( mod 17 ) {\\displaystyle x\\equiv \\pm 8{\\pmod {17}}} . Indeed, ( ± 8 ) 2 = 64 ≡ 13 ( mod 17 ) {\\displaystyle (\\pm 8)^{2}=64\\equiv 13{\\pmod {17}}} .",
    "source_url": "https://en.wikipedia.org/wiki/Pocklington%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:18.402012",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:18.402012",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:18.402012",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Karger%27s_algorithm_1_1749015020815_8884",
    "text": "= | { u v ∈ E : u ∈ S , v ∈ T } | . {\\displaystyle w(S,T)=|\\{\\,uv\\in E\\colon u\\in S,v\\in T\\,\\}|\\,.} There are 2 | V | {\\displaystyle 2^{|V|}} ways of choosing for each vertex whether it belongs to S {\\displaystyle S} or to T {\\displaystyle T} , but two of these choices make S {\\displaystyle S} or T {\\displaystyle T} empty and do not give rise to cuts. Among the remaining choices, swapping the roles of S {\\displaystyle S} and T {\\displaystyle T} does not change the cut, so each cut is counted twice; therefore, there are 2 | V | − 1 − 1 {\\displaystyle 2^{|V|-1}-1} distinct cuts. The minimum cut problem is to find a cut of smallest size among these cuts. For weighted graphs with positive edge weights w : E → R + {\\displaystyle w\\colon E\\rightarrow \\mathbf {R} ^{+}} the weight of the cut is the sum of the weights  of edges between vertices in each part w ( S , T )",
    "source_url": "https://en.wikipedia.org/wiki/Karger%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:20.815355",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:20.816049",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:20.816049",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Karger%27s_algorithm&oldid=1280996450_1_1749015022770_4514",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by David Eppstein ( talk | contribs ) at 17:39, 17 March 2025 (Undid revision 1280973643 by 22middend ( talk ) the first publication was at SODA 1993, in January 1993) . The present address (URL) is a permanent link to this version. Revision as of 17:39, 17 March 2025 by David Eppstein ( talk | contribs ) (Undid revision 1280973643 by 22middend ( talk ) the first publication was at SODA 199",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Karger%27s_algorithm&oldid=1280996450",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:22.770551",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:22.770551",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:22.770551",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Approximate_counting_algorithm_1_1749015024049_3047",
    "text": "1 2 1 or more 2 10 4 2 or more 6 11 8 3 or more 14 100 16 4 or more 30 101 32 5 or more 62 If the counter holds the value of 101, which equates to an exponent of 5 (the decimal equivalent of 101), then the estimated count is 2 5 {\\displaystyle 2^{5}} , or 32. There is a fairly low probability that the actual count of increment events was 5 ( 1 1024 = 1 × 1 2 × 1 4 × 1 8 × 1 16 {\\displaystyle {\\frac {1}{1024}}=1\\times {\\frac {1}{2}}\\times {\\frac {1}{4}}\\times {\\frac {1}{8}}\\times {\\frac {1}{16}}} ). The actual count of increment events is likely to be \"around 32\", but it could be arbitrarily high (with decreasing probabilities for actual counts above 39). Selecting counter values [ edit ] While using powers of 2 as counter values is memory efficient, arbitrary values tend to create a dynamic error range, and the smaller values will have a greater error ratio than bigger values.",
    "source_url": "https://en.wikipedia.org/wiki/Approximate_counting_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:24.049724",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:24.049724",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:24.049724",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Approximate_counting_algorithm&oldid=1276415768_1_1749015024809_5754",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by LR.127 ( talk | contribs ) at 19:02, 18 February 2025 (Adding short description : \"Optimization theory in computing\") . The present address (URL) is a permanent link to this version. Revision as of 19:02, 18 February 2025 by LR.127 ( talk | contribs ) (Adding short description : \"Optimization theory in computing\") ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Approximate_counting_algorithm&oldid=1276415768",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:24.809216",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:24.809216",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:24.809216",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Atlantic_City_algorithm_1_1749015026454_8644",
    "text": "Jump to content From Wikipedia, the free encyclopedia You can help expand this article with text translated from the corresponding article in French . (June 2022) Click [show] for important translation instructions. View a machine-translated version of the French article. Machine translation, like DeepL or Google Translate , is a useful starting point for translations, but translators must revise errors as necessary and confirm that the translation is accurate, rather than simply copy-pasting machine-translated text into the English Wikipedia. Consider adding a topic to this template: there are already 2,088 articles in the main category , and specifying |topic= will aid in categorization. Do not translate text that appears unreliable or low-quality. If possible, verify the text with references provided in the foreign-language article.",
    "source_url": "https://en.wikipedia.org/wiki/Atlantic_City_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:26.454921",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:26.454921",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:26.454921",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Atlantic_City_algorithm&oldid=1270522651_1_1749015027164_9499",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by HotMess ( talk | contribs ) at 23:14, 19 January 2025 ( → top : nomenclature wikilink) . The present address (URL) is a permanent link to this version. Revision as of 23:14, 19 January 2025 by HotMess ( talk | contribs ) ( → top : nomenclature wikilink) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) You can help expand this article with text translated fr",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Atlantic_City_algorithm&oldid=1270522651",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:27.164799",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:27.165800",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:27.165800",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Analysis_of_parallel_algorithms&oldid=644146827_1_1749015039647_5266",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Qwertyus ( talk | contribs ) at 20:11, 25 January 2015 (new empty cat, to be filled in over the next few minutes) . The present address (URL) is a permanent link to this version. Revision as of 20:11, 25 January 2015 by Qwertyus ( talk | contribs ) (new empty cat, to be filled in over the next few minutes) (diff) ← Previous revision | Latest revision (diff) | Newer revision → (diff)",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Analysis_of_parallel_algorithms&oldid=644146827",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:39.647472",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:39.647472",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:39.648472",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Computer_programming&oldid=1292996167_1_1749015059088_4751",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Meters ( talk | contribs ) at 01:48, 30 May 2025 (Undid revision 1292991799 by 27.34.67.53 ( talk )) . The present address (URL) is a permanent link to this version. Revision as of 01:48, 30 May 2025 by Meters ( talk | contribs ) (Undid revision 1292991799 by 27.34.67.53 ( talk )) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Process to create executable",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Computer_programming&oldid=1292996167",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:30:59.088897",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:30:59.088897",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:30:59.088897",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simple_continued_fraction_1_1749015072113_8918",
    "text": "Jump to content From Wikipedia, the free encyclopedia Number represented as a0+1/(a1+1/...) \"Recurring fraction\" redirects here and is not to be confused with Repeating decimal . A simple or regular continued fraction is a continued fraction with numerators all equal one, and denominators built from a sequence { a i } {\\displaystyle \\{a_{i}\\}} of integer numbers.",
    "source_url": "https://en.wikipedia.org/wiki/Simple_continued_fraction",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:12.113954",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:12.113954",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:12.113954",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simple_continued_fraction_1_1749015072144_5028",
    "text": "The sequence can be finite or infinite, resulting in a finite (or terminated ) continued fraction like a 0 + 1 a 1 + 1 a 2 + 1 ⋱ + 1 a n {\\displaystyle a_{0}+{\\cfrac {1}{a_{1}+{\\cfrac {1}{a_{2}+{\\cfrac {1}{\\ddots +{\\cfrac {1}{a_{n}}}}}}}}}} or an infinite continued fraction like a 0 + 1 a 1 + 1 a 2 + 1 ⋱ {\\displaystyle a_{0}+{\\cfrac {1}{a_{1}+{\\cfrac {1}{a_{2}+{\\cfrac {1}{\\ddots }}}}}}} Typically, such a continued fraction is obtained through an iterative process of representing a number as the sum of its integer part and the reciprocal of another number, then writing this other number as the sum of its integer part and another reciprocal, and so on. In the finite case, the iteration/ recursion is stopped after finitely many steps by using an integer in lieu of another continued fraction. In contrast, an infinite continued fraction is an infinite expression . In either case, all integers in the sequence, other than the first, must be positive .",
    "source_url": "https://en.wikipedia.org/wiki/Simple_continued_fraction",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:12.144567",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:12.144567",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:12.144567",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simple_continued_fraction_1_1749015072262_4170",
    "text": "Use 6 as an approximation for this to obtain 2 + ⁠ 1 / 6 ⁠ as an approximation for ⁠ 93 / 43 ⁠ and 4 + ⁠ 1 / 2 + ⁠ 1 / 6 ⁠ ⁠ , about 4.4615, as the third approximation. Further, ⁠ 43 / 7 ⁠ = 6 + ⁠ 1 / 7 ⁠ . Finally, the fractional part, ⁠ 1 / 7 ⁠ , is the reciprocal of 7, so its approximation in this scheme, 7, is exact ( ⁠ 7 / 1 ⁠ = 7 + ⁠ 0 / 1 ⁠ ) and produces the exact expression 4 + 1 2 + 1 6 + 1 7 {\\displaystyle 4+{\\cfrac {1}{2+{\\cfrac {1}{6+{\\cfrac {1}{7}}}}}}} for ⁠ 415 / 93 ⁠ . That expression is called the continued fraction representation of ⁠ 415 / 93 ⁠ . This can be represented by the abbreviated notation ⁠ 415 / 93 ⁠ = [4; 2, 6, 7]. It is customary to place a semicolon after the first number to indicate that it is the whole part. Some older textbooks use all commas in the ( n + 1) -tuple, for example, [4, 2, 6, 7].",
    "source_url": "https://en.wikipedia.org/wiki/Simple_continued_fraction",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:12.262255",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:12.262255",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:12.262255",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simple_continued_fraction_1_1749015072714_3917",
    "text": "The pattern repeats indefinitely with a period of 6. e = [2;1,2,1,1,4,1,1,6,1,1,8,...] (sequence A003417 in the OEIS ). The pattern repeats indefinitely with a period of 3 except that 2 is added to one of the terms in each cycle. π = [3;7,15,1,292,1,1,1,2,1,3,1,...] (sequence A001203 in the OEIS ). No pattern has ever been found in this representation. φ = [1;1,1,1,1,1,1,1,1,1,1,1,...] (sequence A000012 in the OEIS ). The golden ratio , the irrational number that is the \"most difficult\" to approximate rationally (see § A property of the golden ratio φ below) . γ = [0;1,1,2,1,2,1,4,3,13,5,1,...] (sequence A002852 in the OEIS ). The Euler–Mascheroni constant , which is expected but not known to be irrational, and whose continued fraction has no apparent pattern.",
    "source_url": "https://en.wikipedia.org/wiki/Simple_continued_fraction",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:12.714665",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:12.715666",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:12.715666",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simple_continued_fraction_1_1749015072744_6274",
    "text": "Continued fractions are, in some ways, more \"mathematically natural\" representations of a real number than other representations such as decimal representations , and they have several desirable properties: The continued fraction representation for a real number is finite if and only if it is a rational number. In contrast, the decimal representation of a rational number may be finite, for example ⁠ 137 / 1600 ⁠ = 0.085625 , or infinite with a repeating cycle, for example ⁠ 4 / 27 ⁠ = 0.148148148148... Every rational number has an essentially unique simple continued fraction representation. Each rational can be represented in exactly two ways, since [ a 0 ; a 1 ,... a n −1 , a n ] = [ a 0 ; a 1 ,... a n −1 ,( a n −1),1] . Usually the first, shorter one is chosen as the canonical representation . The simple continued fraction representation of an irrational number is unique. (However, additional representations are possible when using generalized continued fractions; see below.)",
    "source_url": "https://en.wikipedia.org/wiki/Simple_continued_fraction",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:12.744252",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:12.745251",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:12.745251",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simple_continued_fraction_1_1749015072765_8930",
    "text": "The real numbers whose continued fraction eventually repeats are precisely the quadratic irrationals . [ 4 ] For example, the repeating continued fraction [1;1,1,1,...] is the golden ratio , and the repeating continued fraction [1;2,2,2,...] is the square root of 2 . In contrast, the decimal representations of quadratic irrationals are apparently random . The square roots of all (positive) integers that are not perfect squares are quadratic irrationals, and hence are unique periodic continued fractions. The successive approximations generated in finding the continued fraction representation of a number, that is, by truncating the continued fraction representation, are in a certain sense (described below) the \"best possible\".",
    "source_url": "https://en.wikipedia.org/wiki/Simple_continued_fraction",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:12.765251",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:12.765251",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:12.765251",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simple_continued_fraction_1_1749015072787_2337",
    "text": "Formulation [ edit ] A continued fraction in canonical form is an expression of the form a 0 + 1 a 1 + 1 a 2 + 1 a 3 + 1 1 ⋱ {\\displaystyle a_{0}+{\\cfrac {1}{a_{1}+{\\cfrac {1}{a_{2}+{\\cfrac {1}{a_{3}+{\\vphantom {\\cfrac {1}{1}}}{_{\\ddots }}}}}}}}} where a i are integer numbers, called the coefficients or terms of the continued fraction. [ 1 ] When the expression contains finitely many terms, it is called a finite continued fraction. When the expression contains infinitely many terms, it is called an infinite continued fraction. [ 5 ] When the terms eventually repeat from some point onwards, the continued fraction is called periodic .",
    "source_url": "https://en.wikipedia.org/wiki/Simple_continued_fraction",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:12.787250",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:12.787250",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:12.787250",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Simple_continued_fraction_1_1749015072820_3377",
    "text": "[ 4 ] Thus, all of the following illustrate valid finite simple continued fractions: Examples of finite simple continued fractions Formula Numeric Remarks a 0 {\\displaystyle \\ a_{0}} 2 {\\displaystyle \\ 2} All integers are a degenerate case a 0 + 1 a 1 {\\displaystyle \\ a_{0}+{\\cfrac {1}{a_{1}}}} 2 + 1 3 {\\displaystyle \\ 2+{\\cfrac {1}{3}}} Simplest possible fractional form a 0 + 1 a 1 + 1 a 2 {\\displaystyle \\ a_{0}+{\\cfrac {1}{a_{1}+{\\cfrac {1}{a_{2}}}}}} − 3 + 1 2 + 1 18 {\\displaystyle \\ -3+{\\cfrac {1}{2+{\\cfrac {1}{18}}}}} First integer may be negative a 0 + 1 a 1 + 1 a 2 + 1 a 3 {\\displaystyle \\ a_{0}+{\\cfrac {1}{a_{1}+{\\cfrac {1}{a_{2}+{\\cfrac {1}{a_{3}}}}}}}} 1 15 + 1 1 + 1 102 {\\displaystyle \\ {\\cfrac {1}{15+{\\cfrac {1}{1+{\\cfrac {1}{102}}}}}}} First integer may be zero For simple continued fractions of the form r = a 0 + 1 a 1 + 1",
    "source_url": "https://en.wikipedia.org/wiki/Simple_continued_fraction",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:12.820164",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:12.821164",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:12.821164",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm_1_1749015087068_2255",
    "text": "LLL reduction [ edit ] The precise definition of LLL-reduced is as follows: Given a basis B = { b 1 , b 2 , … , b n } , {\\displaystyle \\mathbf {B} =\\{\\mathbf {b} _{1},\\mathbf {b} _{2},\\dots ,\\mathbf {b} _{n}\\},} define its Gram–Schmidt process orthogonal basis B ∗ = { b 1 ∗ , b 2 ∗ , … , b n ∗ } , {\\displaystyle \\mathbf {B} ^{*}=\\{\\mathbf {b} _{1}^{*},\\mathbf {b} _{2}^{*},\\dots ,\\mathbf {b} _{n}^{*}\\},} and the Gram-Schmidt coefficients μ i , j = ⟨ b i , b j ∗ ⟩ ⟨ b j ∗ , b j ∗ ⟩ , {\\displaystyle \\mu _{ i,j}={\\frac {\\langle \\mathbf {b} _{i},\\mathbf {b} _{j}^{*}\\rangle }{\\langle \\mathbf {b} _{j}^{*},\\mathbf {b} _{j}^{*}\\rangle }},} for any 1 ≤ j < i ≤ n {\\displaystyle 1\\leq j<i\\leq n} . Then the basis B {\\displaystyle B} is LLL-reduced if there exists a parameter δ {\\displaystyle \\delta } in (0.25, 1] such that the following holds: (size-reduced) For 1 ≤ j < i ≤ n : | μ i , j | ≤ 0.5 {\\displaystyle 1\\leq j<i\\leq n\\colon \\left|\\mu _{i,j}\\right|\\leq 0.5} .",
    "source_url": "https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:27.068193",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:27.069186",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:27.069186",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm_1_1749015087281_8194",
    "text": "In particular, for δ = 3 / 4 {\\displaystyle \\delta =3/4} , this gives ‖ b 1 ‖ ≤ 2 ( n − 1 ) / 2 ⋅ λ 1 ( L ) {\\displaystyle \\Vert \\mathbf {b} _{1}\\Vert \\leq 2^{(n-1)/2}\\cdot \\lambda _{1}({\\mathcal {L}})} . [ 8 ] The first vector in the basis is also bounded by the determinant of the lattice: ‖ b 1 ‖ ≤ ( 2 / ( 4 δ − 1 ) ) ( n − 1 ) / 2 ⋅ ( det ( L ) ) 1 / n {\\displaystyle \\Vert \\mathbf {b} _{1}\\Vert \\leq (2/({\\sqrt {4\\delta -1}}))^{(n-1)/2}\\cdot (\\det({\\mathcal {L}}))^{1/n}} . In particular, for δ = 3 / 4 {\\displaystyle \\delta =3/4} , this gives ‖ b 1 ‖ ≤ 2 ( n − 1 ) / 4 ⋅ ( det ( L ) ) 1 / n {\\displaystyle \\Vert \\mathbf {b} _{1}\\Vert \\leq 2^{(n-1)/4}\\cdot (\\det({\\mathcal {L}}))^{1/n}} .",
    "source_url": "https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:27.281683",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:27.281683",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:27.281683",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm_1_1749015087380_1513",
    "text": "(The naive method is to recompute B * whenever b i changes: B * <- GramSchmidt({ b 1 , ..., b n }) = { b 1 * , ..., b n * }) end if end for if InnerProduct( b k * , b k * ) > ( δ − μ 2 k , k −1 ) InnerProduct( b k −1 * , b k −1 * ) then k <- k + 1; else Swap b k and b k −1 ; Update B * and the related μ i , j 's as needed. k <- max( k −1, 2); end if end while return B the LLL reduced basis of {b 1 , ..., b n } OUTPUT the reduced basis b 1 , b 2 , ..., b n in Z m Examples [ edit ] Example from Z 3 [ edit ] Let a lattice basis b 1 , b 2 , b 3 ∈ Z 3 {\\displaystyle \\mathbf {b} _{1},\\mathbf {b} _{2},\\mathbf {b} _{3}\\in \\mathbf {Z} ^{3}} , be given by the columns of [ 1 − 1 3 1 0 5 1 2 6 ] {\\displaystyle {\\begin{bmatrix}1&-1&3\\\\1&0&5\\\\1&2&6\\end{bmatrix}}} then the reduced basis is [ 0 1 − 1 1 0 0 0 1 2 ] , {\\displaystyle {\\begin{bmatrix}0&1&-1\\\\1&0&0\\\\0&1&2\\end{bmatrix}},} which is size-reduced, satisfies the Lovász condition, and is hence LLL-reduced, as described above. See W. Bosma.",
    "source_url": "https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:27.380224",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:27.381217",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:27.381217",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm_1_1749015087419_5641",
    "text": "See W. Bosma. [ 10 ] for details of the reduction process. Example from Z[ i ] 4 [ edit ] Likewise, for the basis over the complex integers given by the columns of the matrix below, [ − 2 + 2 i 7 + 3 i 7 + 3 i − 5 + 4 i 3 + 3 i − 2 + 4 i 6 + 2 i − 1 + 4 i 2 + 2 i − 8 + 0 i − 9 + 1 i − 7 + 5 i 8 + 2 i − 9 + 0 i 6 + 3 i − 4 + 4 i ] , {\\displaystyle {\\begin{bmatrix}-2+2i&7+3i&7+3i&-5+4i\\\\3+3i&-2+4i&6+2i&-1+4i\\\\2+2i&-8+0i&-9+1i&-7+5i\\\\8+2i&-9+0i&6+3i&-4+4i\\end{bmatrix}},} then the columns of the matrix below give an LLL-reduced basis. [ − 6 + 3 i − 2 + 2 i 2 − 2 i − 3 + 6 i 6 − 1 i 3 + 3 i 5 − 5 i 2 + 1 i 2 − 2 i 2 + 2 i − 3 − 1 i − 5 + 3 i − 2 + 1 i 8 + 2 i 7 + 1 i − 2 − 4 i ] . {\\displaystyle {\\begin{bmatrix}-6+3i&-2+2i&2-2i&-3+6i\\\\6-1i&3+3i&5-5i&2+1i\\\\2-2i&2+2i&-3-1i&-5+3i\\\\-2+1i&8+2i&7+1i&-2-4i\\\\\\end{bmatrix}}.}",
    "source_url": "https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:27.419388",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:27.420391",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:27.420391",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pollard%27s_rho_algorithm_1_1749015097952_7756",
    "text": "If the sequences were to behave like random numbers, the birthday paradox implies that the number of x k {\\displaystyle x_{k}} before a repetition occurs would be expected to be O ( N ) {\\displaystyle O({\\sqrt {N}})} , where N {\\displaystyle N} is the number of possible values. So the sequence { x k mod p } {\\displaystyle \\{x_{k}{\\bmod {p}}\\}} will likely repeat much earlier than the sequence { x k } {\\displaystyle \\{x_{k}\\}} . When one has found a k 1 , k 2 {\\displaystyle k_{1},k_{2}} such that x k 1 ≠ x k 2 {\\displaystyle x_{k_{1}}\\neq x_{k_{2}}} but x k 1 ≡ x k 2 mod p {\\displaystyle x_{k_{1}}\\equiv x_{k_{2}}{\\bmod {p}}} , the number | x k 1 − x k 2 | {\\displaystyle |x_{k_{1}}-x_{k_{2}}|} is a multiple of p {\\displaystyle p} , so a non-trivial divisor has been found. [ 2 ] Once a sequence has a repeated value, the sequence will cycle, because each value depends only on the one before it.",
    "source_url": "https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:37.952381",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:37.952381",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:37.952381",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Euclidean_algorithm&oldid=1288126959_1_1749015106659_4907",
    "text": "The greatest common divisor g is the largest natural number that divides both a and b without leaving a remainder. Synonyms for GCD include greatest common factor (GCF), highest common factor (HCF), highest common divisor (HCD), and greatest common measure (GCM). The greatest common divisor is often written as gcd( a , b ) or, more simply, as ( a , b ) , [ 3 ] although the latter notation is ambiguous, also used for concepts such as an ideal in the ring of integers , which is closely related to GCD. If gcd( a , b ) = 1 , then a and b are said to be coprime (or relatively prime). [ 4 ] This property does not imply that a or b are themselves prime numbers . [ 5 ] For example, 6 and 35 factor as 6 = 2 × 3 and 35 = 5 × 7 , so they are not prime, but their prime factors are different, so 6 and 35 are coprime, with no common factors other than 1 . A 24×60 rectangle is covered with ten 12×12 square tiles, where 12 is the GCD of 24 and 60.",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Euclidean_algorithm&oldid=1288126959",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:46.659149",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:46.659149",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:46.659149",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Euclidean_algorithm&oldid=1288126959_1_1749015106689_4218",
    "text": "The sides of the rectangle can be divided into segments of length c , which divides the rectangle into a grid of squares of side length c . The GCD g is the largest value of c for which this is possible. For illustration, a 24×60 rectangular area can be divided into a grid of: 1×1 squares, 2×2 squares, 3×3 squares, 4×4 squares, 6×6 squares or 12×12 squares. Therefore, 12 is the GCD of 24 and 60 . A 24×60 rectangular area can be divided into a grid of 12×12 squares, with two squares along one edge ( 24/12 = 2 ) and five squares along the other ( 60/12 = 5 ). The greatest common divisor of two numbers a and b is the product of the prime factors shared by the two numbers, where each prime factor can be repeated as many times as it divides both a and b . [ 8 ] For example, since 1386 can be factored into 2 × 3 × 3 × 7 × 11 , and 3213 can be factored into 3 × 3 × 3 × 7 × 17 , the GCD of 1386 and 3213 equals 63 = 3",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Euclidean_algorithm&oldid=1288126959",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:46.689269",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:46.689269",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:46.690270",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Euclidean_algorithm&oldid=1288126959_1_1749015106720_4314",
    "text": "The set of all integral linear combinations of a and b is actually the same as the set of all multiples of g ( mg , where m is an integer). In modern mathematical language, the ideal generated by a and b is the ideal generated by g alone (an ideal generated by a single element is called a principal ideal , and all ideals of the integers are principal ideals). Some properties of the GCD are in fact easier to see with this description, for instance the fact that any common divisor of a and b also divides the GCD (it divides both terms of ua + vb ). The equivalence of this GCD definition with the other definitions is described below. The GCD of three or more numbers equals the product of the prime factors common to all the numbers, [ 13 ] but it can also be calculated by repeatedly taking the GCDs of pairs of numbers. [ 14 ] For example, gcd( a , b , c ) = gcd( a , gcd( b , c )) = gcd(gcd( a , b ), c ) = gcd(gcd( a , c ), b ).",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Euclidean_algorithm&oldid=1288126959",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:46.720401",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:46.720401",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:46.720401",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Two-element_Boolean_algebra_1_1749015115325_5751",
    "text": "The following equations may now be verified: A + A = A A ⋅ A = A A + 0 = A A + 1 = 1 A ⋅ 0 = 0 A ¯ ¯ = A {\\displaystyle {\\begin{aligned}&A+A=A\\\\&A\\cdot A=A\\\\&A+0=A\\\\&A+1=1\\\\&A\\cdot 0=0\\\\&{\\overline {\\overline {A}}}=A\\end{aligned}}} Each of '+' and '∙' distributes over the other: A ⋅ ( B + C ) = A ⋅ B + A ⋅ C ; {\\displaystyle \\ A\\cdot (B+C)=A\\cdot B+A\\cdot C;} A + ( B ⋅ C ) = ( A + B ) ⋅ ( A + C ) . {\\displaystyle \\ A+(B\\cdot C)=(A+B)\\cdot (A+C).} That '∙' distributes over '+' agrees with elementary algebra , but not '+' over '∙'. For this and other reasons, a sum of products (leading to a NAND synthesis) is more commonly employed than a product of sums (leading to a NOR synthesis). Each of '+' and '∙' can be defined in terms of the other and complementation: A ⋅ B = A ¯ + B ¯ ¯ {\\displaystyle A\\cdot B={\\overline {{\\overline {A}}+{\\overline {B}}}}} A + B = A ¯ ⋅ B ¯ ¯ . {\\displaystyle A+B={\\overline {{\\overline {A}}\\cdot {\\overline {B}}}}.}",
    "source_url": "https://en.wikipedia.org/wiki/Two-element_Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:55.325862",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:55.325862",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:55.325862",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Two-element_Boolean_algebra_1_1749015115400_7748",
    "text": "A 0 = A {\\displaystyle \\ A0=A} (0 is the lower bound ). A A B ¯ = A B ¯ {\\displaystyle A{\\overline {AB}}=A{\\overline {B}}} ( 2 is a distributive lattice ) Where concatenation = OR, 1 = true, and 0 = false, or concatenation = AND, 1 = false, and 0 = true. (overbar is negation in both cases.) If 0=1, (1)–(3) are the axioms for an abelian group . (1) only serves to prove that concatenation commutes and associates. First assume that (1) associates from either the left or the right, then prove commutativity. Then prove association from the other direction. Associativity is simply association from the left and right combined. This basis makes for an easy approach to proof, called \"calculation\" in Laws of Form , that proceeds by simplifying expressions to 0 or 1, by invoking axioms (2)–(4), and the elementary identities A A = A , A ¯ ¯ = A , 1 + A = 1 {\\displaystyle AA=A,{\\overline {\\overline {A}}}=A,1+A=1} , and the distributive law.",
    "source_url": "https://en.wikipedia.org/wiki/Two-element_Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:55.400399",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:55.400399",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:55.400399",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Boolean_algebras_canonically_defined_1_1749015118701_1467",
    "text": "The maximal such algebra consists of all finitary operations on {0,1}. The number of arguments taken by each operation is called the arity of the operation. An operation on {0,1} of arity n , or n -ary operation, can be applied to any of 2 n possible values for its n arguments. For each choice of arguments, the operation may return 0 or 1 , whence there are 2 2 n n -ary operations. The prototype therefore has two operations taking no arguments, called zeroary or nullary operations, namely zero and one. It has four unary operations , two of which are constant operations, another is the identity, and the most commonly used one, called negation , returns the opposite of its argument: 1 if 0 , 0 if 1 .",
    "source_url": "https://en.wikipedia.org/wiki/Boolean_algebras_canonically_defined",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:31:58.701287",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:31:58.701287",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:31:58.701287",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Abstract_rewriting_system_1_1749015123626_9893",
    "text": "Basic notions [ edit ] First define some basic notions and notations. [ 5 ] → + {\\displaystyle {\\stackrel {+}{\\rightarrow }}} is the transitive closure of → {\\displaystyle \\rightarrow } . → ∗ {\\displaystyle {\\stackrel {*}{\\rightarrow }}} is the reflexive transitive closure of → {\\displaystyle \\rightarrow } , i.e. the transitive closure of ( → ) ∪ ( = ) {\\displaystyle (\\rightarrow )\\cup (=)} , where = is the identity relation . Equivalently, → ∗ {\\displaystyle {\\stackrel {*}{\\rightarrow }}} is the smallest preorder containing → {\\displaystyle \\rightarrow } . Similarly, ← + {\\displaystyle {\\stackrel {+}{\\leftarrow }}} , and ← ∗ {\\displaystyle {\\stackrel {*}{\\leftarrow }}} are closures of ← {\\displaystyle {\\leftarrow }} , the converse relation of → {\\displaystyle {\\rightarrow }} . ↔ {\\displaystyle \\leftrightarrow } is the symmetric closure of → {\\displaystyle \\rightarrow } , that is, the union of → {\\displaystyle \\rightarrow } with ← {\\displaystyle {\\leftarrow }} .",
    "source_url": "https://en.wikipedia.org/wiki/Abstract_rewriting_system",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:03.626374",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:03.627367",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:03.627367",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Abstract_rewriting_system_1_1749015123657_6380",
    "text": "↔ ∗ {\\displaystyle {\\stackrel {*}{\\leftrightarrow }}} is the reflexive transitive symmetric closure of → {\\displaystyle \\rightarrow } , i.e. the transitive closure of ( ↔ ) ∪ ( = ) {\\displaystyle (\\leftrightarrow )\\cup (=)} . Equivalently, ↔ ∗ {\\displaystyle {\\stackrel {*}{\\leftrightarrow }}} is the smallest equivalence relation containing → {\\displaystyle \\rightarrow } . Normal forms [ edit ] Main article: Normal form (abstract rewriting) An object x in A is called reducible if there exist some other y in A and x → y {\\displaystyle x\\rightarrow y} ; otherwise it is called irreducible or a normal form . An object y is called a normal form of x if x → ∗ y {\\displaystyle x{\\stackrel {*}{\\rightarrow }}y} and y is irreducible. If x has a unique normal form, then this is usually denoted with x ↓ {\\displaystyle x\\downarrow } . In example 1 above, c is a normal form, and c = a ↓ = b ↓ {\\displaystyle c=a\\downarrow =b\\downarrow } .",
    "source_url": "https://en.wikipedia.org/wiki/Abstract_rewriting_system",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:03.657374",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:03.657374",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:03.657374",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Stone%27s_representation_theorem_for_Boolean_algebras_1_1749015125832_8075",
    "text": "JSTOR 1989664 . ^ \"Celebratio Mathematica — Stone — Mackey on Stone\" . celebratio.org . Retrieved 2025-04-22 . ^ Dimov, G. D. (2012). \"Some generalizations of the Stone Duality Theorem\" . Publ. Math. Debrecen . 80 ( 3– 4): 255– 293. doi : 10.5486/PMD.2012.4814 . ^ Doctor, H. P. (1964). \"The categories of Boolean lattices, Boolean rings and Boolean spaces\" . Canad. Math. Bull. 7 (2): 245– 252. doi : 10.4153/CMB-1964-022-6 . S2CID 124451802 . References [ edit ] Halmos, Paul ; Givant, Steven (1998). Logic as Algebra . Dolciani Mathematical Expositions. Vol. 21. The Mathematical Association of America . ISBN 0-88385-327-2 . Johnstone, Peter T. (1982). Stone Spaces . Cambridge University Press. ISBN 0-521-23893-5 . Burris, Stanley N.; Sankappanavar, H.P. (1981). A Course in Universal Algebra . Springer. ISBN 3-540-90578-2 .",
    "source_url": "https://en.wikipedia.org/wiki/Stone%27s_representation_theorem_for_Boolean_algebras",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:05.832875",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:05.833876",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:05.833876",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimal_axioms_for_Boolean_algebra_1_1749015128478_4030",
    "text": "∧ ¯ {\\displaystyle {\\overline {\\wedge }}} Converse implication ⇐ {\\displaystyle \\Leftarrow } Implication ( IMPLY gate ) ⇒ {\\displaystyle \\Rightarrow } Disjunction ( OR gate ) ∨ {\\displaystyle \\lor } Negation ( NOT gate ) ¬ {\\displaystyle \\neg } Exclusive or ( XOR gate ) ⊕ {\\displaystyle \\oplus } Biconditional ( XNOR gate ) ⊙ {\\displaystyle \\odot } Statement ( Digital buffer ) Joint denial ( NOR gate )",
    "source_url": "https://en.wikipedia.org/wiki/Minimal_axioms_for_Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:08.478911",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:08.478911",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:08.478911",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_Boolean_algebra_topics_1_1749015131072_7011",
    "text": "theorem Hausdorff maximal principle Knaster–Tarski theorem Kruskal's tree theorem Laver's theorem Mirsky's theorem Szpilrajn extension theorem Zorn's lemma Properties & Types ( list",
    "source_url": "https://en.wikipedia.org/wiki/List_of_Boolean_algebra_topics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:11.072160",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:11.073152",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:11.073152",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Canonical_form_(Boolean_algebra)_1_1749015133625_1778",
    "text": "Minterms [ edit ] For a boolean function of n {\\displaystyle n} variables x 1 , … , x n {\\displaystyle {x_{1},\\dots ,x_{n}}} , a minterm is a product term in which each of the n {\\displaystyle n} variables appears exactly once (either in its complemented or uncomplemented form). Thus, a minterm is a logical expression of n variables that employs only the complement operator and the conjunction operator ( logical AND ). A minterm gives a true value for just one combination of the input variables, the minimum nontrivial amount. For example, a b ' c , is true only when a and c both are true and b is false—the input arrangement where a = 1, b = 0, c = 1 results in 1. Indexing minterms [ edit ] There are 2 n minterms of n variables, since a variable in the minterm expression can be in either its direct or its complemented form—two choices per variable.",
    "source_url": "https://en.wikipedia.org/wiki/Canonical_form_(Boolean_algebra)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:13.625428",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:13.625428",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:13.625428",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Canonical_form_(Boolean_algebra)_1_1749015133685_2205",
    "text": "This is a special form of disjunctive normal form . For example, if given the truth table for the arithmetic sum bit u of one bit position's logic of an adder circuit, as a function of x and y from the addends and the carry in, ci : ci x y u(ci,x,y) 0 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 Observing that the rows that have an output of 1 are the 2nd, 3rd, 5th, and 8th, we can write u as a sum of minterms m 1 , m 2 , m 4 , {\\displaystyle m_{1},m_{2},m_{4},} and m 7 {\\displaystyle m_{7}} . If we wish to verify this: u ( c i , x , y ) = m 1 + m 2 + m 4 + m 7 = ( c i ′ , x ′ , y ) + ( c i ′ , x , y ′ ) + ( c i , x ′ , y ′ ) + ( c i , x , y ) {\\displaystyle u(ci,x,y)=m_{1}+m_{2}+m_{4}+m_{7}=(ci',x',y)+(ci',x,y')+(ci,x',y')+(ci,x,y)} evaluated for all 8 combinations of the three variables will match the table.",
    "source_url": "https://en.wikipedia.org/wiki/Canonical_form_(Boolean_algebra)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:13.685430",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:13.685933",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:13.685933",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Canonical_form_(Boolean_algebra)_1_1749015133713_4375",
    "text": "Maxterms [ edit ] For a boolean function of n variables x 1 , … , x n {\\displaystyle {x_{1},\\dots ,x_{n}}} , a maxterm is a sum term in which each of the n variables appears exactly once (either in its complemented or uncomplemented form). Thus, a maxterm is a logical expression of n variables that employs only the complement operator and the disjunction operator ( logical OR ). Maxterms are a dual of the minterm idea, following the complementary symmetry of De Morgan's laws . Instead of using ANDs and complements, we use ORs and complements and proceed similarly. It is apparent that a maxterm gives a false value for just one combination of the input variables, i.e. it is true at the maximal number of possibilities. For example, the maxterm a ′ + b + c ′ is false only when a and c both are true and b is false—the input arrangement where a = 1, b = 0, c = 1 results in 0.",
    "source_url": "https://en.wikipedia.org/wiki/Canonical_form_(Boolean_algebra)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:13.713553",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:13.713553",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:13.713553",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Canonical_form_(Boolean_algebra)_1_1749015133774_6888",
    "text": "= m 6 {\\displaystyle abc'=m_{6}} , using de Morgan's law . Maxterm canonical form [ edit ] If one is given a truth table of a logical function, it is possible to write the function as a \"product of sums\" or \"product of maxterms\". This is a special form of conjunctive normal form . For example, if given the truth table for the carry-out bit co of one bit position's logic of an adder circuit, as a function of x and y from the addends and the carry in, ci : ci x y co(ci,x,y) 0 0 0 0 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 1 1 1 1 1 Observing that the rows that have an output of 0 are the 1st, 2nd, 3rd, and 5th, we can write co as a product of maxterms M 0 , M 1 , M 2 {\\displaystyle M_{0},M_{1},M_{2}} and M 4 {\\displaystyle M_{4}} . If we wish to verify this: c o ( c i , x , y ) = M 0 M 1 M 2 M 4 = ( c i + x + y ) ( c i + x + y ′ ) ( c i + x ′ + y )",
    "source_url": "https://en.wikipedia.org/wiki/Canonical_form_(Boolean_algebra)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:13.774998",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:13.774998",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:13.774998",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Canonical_form_(Boolean_algebra)_1_1749015133811_7753",
    "text": "= M 0 M 1 M 2 M 4 = ( c i + x + y ) ( c i + x + y ′ ) ( c i + x ′ + y ) ( c i ′ + x + y ) {\\displaystyle co(ci,x,y)=M_{0}M_{1}M_{2}M_{4}=(ci+x+y)(ci+x+y')(ci+x'+y)(ci'+x+y)} evaluated for all 8 combinations of the three variables will match the table. Minimal PoS and SoP forms [ edit ] It is often the case that the canonical minterm form is equivalent to a smaller SoP form. This smaller form would still consist of a sum of product terms, but have fewer product terms and/or product terms that contain fewer variables. For example, the following 3-variable function: a b c f(a,b,c) 0 0 0 0 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 0 1 1 0 0 1 1 1 1 has the canonical minterm representation f = a ′ b c + a b c {\\displaystyle f=a'bc+abc} , but it has an equivalent SoP form f = b c {\\displaystyle f=bc} . In this trivial example, it is obvious that b c = a ′ b c + a b c {\\displaystyle bc=a'bc+abc} , and the smaller form has both fewer product terms and fewer variables within each term.",
    "source_url": "https://en.wikipedia.org/wiki/Canonical_form_(Boolean_algebra)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:13.811506",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:13.811506",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:13.811506",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Lindenbaum%E2%80%93Tarski_algebra_1_1749015147638_1513",
    "text": "Jump to content From Wikipedia, the free encyclopedia Not to be confused with Jónsson–Tarski algebra . In mathematical logic , the Lindenbaum–Tarski algebra (or Lindenbaum algebra ) of a logical theory T consists of the equivalence classes of sentences of the theory (i.e., the quotient , under the equivalence relation ~ defined such that p ~ q exactly when p and q are provably equivalent in T ). That is, two sentences are equivalent if the theory T proves that each implies the other. The Lindenb",
    "source_url": "https://en.wikipedia.org/wiki/Lindenbaum%E2%80%93Tarski_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:27.638905",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:27.639905",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:27.639905",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Boolean_satisfiability_algorithm_heuristics_1_1749015150468_5823",
    "text": "However, as Boolean expressions get larger, more complicated, or more structured, these heuristics fail to capture useful information about these problems that could improve efficiency; they often get stuck in local maxima or do not consider the distribution of variables. Additionally, larger problems require more processing, as the operation of counting free variables in unsatisfied clauses dominates the run-time. Variable State Independent Decaying Sum [ edit ] An influential heuristic called Variable State Independent Decaying Sum (VSIDS) attempts to score each variable. VSIDS starts by looking at small portions of the Boolean expression and assigning each phase of a variable (a variable and its negated complement) a score proportional to the number of clauses that variable phase is in. As VSIDS progresses and searches more parts of the Boolean expression, periodically, all scores are divided by a constant.",
    "source_url": "https://en.wikipedia.org/wiki/Boolean_satisfiability_algorithm_heuristics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:30.468633",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:30.468633",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:30.468633",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Boolean_satisfiability_algorithm_heuristics_1_1749015150686_5898",
    "text": "This relaxes the problem by introducing new variables into the Boolean expression, [ 4 ] which has the effect of removing many of the constraints in the expression. Because any assignment of variables in B {\\displaystyle B} can be represented by an assignment of variables in B ∗ {\\displaystyle B^{*}} , the minimization and maximization of the weights of B ∗ {\\displaystyle B^{*}} represent lower and upper bounds on the minimization and maximization of the weights of B {\\displaystyle B} . Partial Max-SAT [ edit ] Partial Max-SAT can be solved by first considering all of the hard clauses and solving them as an instance of SAT. The total maximum (or minimum) weight of the soft clauses can be evaluated given the variable assignment necessary to satisfy the hard clauses and trying to optimize the free variables (the variables that the satisfaction of the hard clauses does not depend on). The latter step is an implementation of Max-SAT given some pre-defined variables.",
    "source_url": "https://en.wikipedia.org/wiki/Boolean_satisfiability_algorithm_heuristics",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:30.686613",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:30.686613",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:30.686613",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Tseytin_transformation_1_1749015151539_4479",
    "text": "Jump to content From Wikipedia, the free encyclopedia Operation in Boolean circuit theory The Tseytin transformation , alternatively written Tseitin transformation , takes as input an arbitrary combinatorial logic circuit and produces an equisatisfiable boolean formula in conjunctive normal form (CNF).  The length of the formula is linear in the size of the circuit.  Input vectors that make the circuit output \"true\" are in 1-to-1 correspondence with assignments that satisfy the formula. This red",
    "source_url": "https://en.wikipedia.org/wiki/Tseytin_transformation",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:31.539788",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:31.540403",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:31.540403",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Boolean_satisfiability_algorithm_heuristics&oldid=1281524715_1_1749015152110_6706",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by 69.151.176.180 ( talk ) at 22:30, 20 March 2025 ( → Variable State Independent Decaying Sum : I changed an incorrect subject-verb agreement) . The present address (URL) is a permanent link to this version. Revision as of 22:30, 20 March 2025 by 69.151.176.180 ( talk ) ( → Variable State Independent Decaying Sum : I changed an incorrect subject-verb agreement) ( diff ) ← Previous revision",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Boolean_satisfiability_algorithm_heuristics&oldid=1281524715",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:32.110290",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:32.110290",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:32.110290",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Chaff_algorithm_1_1749015153491_5756",
    "text": "It is now maintained by researchers at Princeton University and available for download as both source code and binaries on Linux . zChaff is free for non-commercial use. References [ edit ] M. Moskewicz, C. Madigan, Y. Zhao, L. Zhang, S. Malik. Chaff: Engineering an Efficient SAT Solver , 39th Design Automation Conference (DAC 2001), Las Vegas, ACM 2001. Vizel, Y.; Weissenbacher, G.; Malik, S. (2015). \"Boolean Satisfiability Solvers and Their Applications in Model Checking\". Proceedings of the IEEE . 103 (11): 2021– 2035. doi : 10.1109/JPROC.2015.2455034 . S2CID 10190144 . External links [ edit ] Web page about zChaff This formal methods -related article is a stub . You can help Wikipedia by expanding it .",
    "source_url": "https://en.wikipedia.org/wiki/Chaff_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:33.491719",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:33.491719",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:33.491719",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Davis%E2%80%93Putnam_algorithm_1_1749015155676_8824",
    "text": "function DP-SAT(Φ) repeat // unit propagation: while Φ contains a unit clause { l } do for every clause c in Φ that contains l do Φ ← remove-from-formula ( c , Φ); for every clause c in Φ that contains ¬ l do Φ ← remove-from-formula ( c , Φ);\n              Φ ← add-to-formula ( c \\ {¬ l }, Φ);\n       // eliminate clauses not in normal form: for every clause c in Φ that contains both a literal l and its negation ¬ l do Φ ← remove-from-formula ( c , Φ);\n       // pure literal elimination: while there is a literal l all of which occurrences in Φ have the same polarity do for every clause c in Φ that contains l do Φ ← remove-from-formula ( c , Φ);\n       // stopping conditions: if Φ is empty then return true; if Φ contains an empty clause then return false;\n       // Davis-Putnam procedure: pick a literal l that occurs with both polarities in Φ for every clause c in Φ containing l and every clause n in Φ containing its negation ¬ l do // resolve c with n: r ← ( c \\ { l }) ∪ ( n \\ {¬ l });",
    "source_url": "https://en.wikipedia.org/wiki/Davis%E2%80%93Putnam_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:35.676746",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:35.676746",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:35.676746",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Davis%E2%80%93Putnam_algorithm_1_1749015155686_9120",
    "text": "Φ ← add-to-formula ( r , Φ); for every clause c that contains l or ¬ l do Φ ← remove-from-formula ( c , Φ); \"←\" denotes assignment",
    "source_url": "https://en.wikipedia.org/wiki/Davis%E2%80%93Putnam_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:35.686259",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:35.686259",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:35.686259",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Davis–Putnam_algorithm&oldid=1238818652_1_1749015157080_3283",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Macrakis ( talk | contribs ) at 20:59, 5 August 2024 (Adding short description : \"Check the validity of a logic formula\") . The present address (URL) is a permanent link to this version. Revision as of 20:59, 5 August 2024 by Macrakis ( talk | contribs ) (Adding short description : \"Check the validity of a logic formula\") ( diff ) ← Previous revision | Latest revision (diff) | Newer revi",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Davis–Putnam_algorithm&oldid=1238818652",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:37.080526",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:37.080526",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:37.080526",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Residuated_Boolean_algebra_1_1749015159921_7202",
    "text": "This permits an alternative expression of the three inequalities y ≤ x \\ z ⇔ x • y ≤ z ⇔ x ≤ z / y in the axiomatization of the two residuals in terms of disjointness, via the equivalence x ≤ y ⇔ x ∧¬ y = 0. Abbreviating x ∧ y = 0 to x # y as the expression of their disjointness, and substituting ¬ z for z in the axioms, they become with a little Boolean manipulation ¬( x \\¬ z ) # y ⇔ x • y # z ⇔   ¬(¬ z / y ) # x Now ¬( x \\¬ z ) is reminiscent of De Morgan duality , suggesting that x \\ be thought of as a unary operation f , defined by f (y) = x \\ y , that has a De Morgan dual ¬ f (¬ y ), analogous to ∀ x φ( x ) = ¬∃ x ¬φ( x ). Denoting this dual operation as x ▷, we define x ▷ z as ¬( x \\¬ z ). Similarly we define another operation z ◁ y as ¬(¬ z / y ). By analogy with x \\ as the residual operation associated with the operation x •, we refer to x ▷ as the conjugate operation, or simply conjugate , of x •. Likewise ◁ y is the conjugate of • y .",
    "source_url": "https://en.wikipedia.org/wiki/Residuated_Boolean_algebra",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:39.921932",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:39.921932",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:39.921932",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=The_Algorithm&oldid=1152929205_1_1749015162731_8545",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Egeymi ( talk | contribs ) at 04:53, 3 May 2023 (Filled in 2 bare reference(s) with reFill 2) . The present address (URL) is a permanent link to this version. Revision as of 04:53, 3 May 2023 by Egeymi ( talk | contribs ) (Filled in 2 bare reference(s) with reFill 2) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) French musical project For other uses, see",
    "source_url": "https://en.wikipedia.org/w/index.php?title=The_Algorithm&oldid=1152929205",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:42.731501",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:42.731501",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:42.731501",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithm_(My_Heart_to_Fear_album)&oldid=1279440336_1_1749015165020_4097",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by GreenC bot ( talk | contribs ) at 16:14, 8 March 2025 (Rescued 1 archive link; reformat 1 link. Wayback Medic 2.5 per WP:USURPURL and JUDI batch #26ae ) . The present address (URL) is a permanent link to this version. Revision as of 16:14, 8 March 2025 by GreenC bot ( talk | contribs ) (Rescued 1 archive link; reformat 1 link. Wayback Medic 2.5 per WP:USURPURL and JUDI batch #26ae ) ( di",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithm_(My_Heart_to_Fear_album)&oldid=1279440336",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:45.020424",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:45.020424",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:45.020424",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithm_(Lucky_Daye_album)&oldid=1277405142_1_1749015166925_3062",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by PrimeBOT ( talk | contribs ) at 13:35, 24 February 2025 ( → top : Task 30 : cleanup bad parameters in Template:Start date ) . The present address (URL) is a permanent link to this version. Revision as of 13:35, 24 February 2025 by PrimeBOT ( talk | contribs ) ( → top : Task 30 : cleanup bad parameters in Template:Start date ) ( diff ) ← Previous revision | Latest revision (diff) | Newer ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithm_(Lucky_Daye_album)&oldid=1277405142",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:46.925466",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:46.925466",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:46.925466",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_The_Algorithm_(Filter_album)_1_1749015168076_4858",
    "text": "[ 9 ] The two took the message to heart, and decided to work on a new album together. [ 8 ] By October 2018, they had announced the concept; the two decided on calling the album Rebus —an allusion to the only Filter album the two had worked together on—and centered the album's conception around the idea of recording a follow-up to that album, but with more modern sounds and concepts. [ 8 ] [ 9 ] [ 10 ] The band had planned to procure funding for the album creation process through crowd sourcing platform PledgeMusic . [ 11 ] However, the band had gone quiet on the progress of the project through the mid-part of 2019, until July 2019, when Patrick announced that the collaboration with Liesegang had been cancelled due to the bankruptcy of the PledgeMusic company [ 12 ] [ 13 ] and \"a variety of other reasons\". [ 14 ] He announced that the scope of the album would be changing - Liesegang would not be working on the album moving forward, and that it had changed names to They've Got Us",
    "source_url": "https://en.wikipedia.org/wiki/The_Algorithm_(Filter_album)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:48.076330",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:48.076488",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:48.076488",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_The_Algorithm_(Filter_album)_1_1749015168282_5921",
    "text": "Blabbermouth.net . July 18, 2019. ^ a b c Childers, Chad (October 3, 2018). \"Original Filter Pair Making New Album\" . Loudwire . ^ \"Filter's Richard Patrick Explains Why Texas Concert Was Canceled Over Anti-Trump Facebook Post\" . Billboard . March 8, 2019. ^ \"FILTER's Reunion Album Called Off\" . Metal Injection . July 18, 2019. ^ \"Filter reunion album canceled due to PledgeMusic bankruptcy - Music News - ABC News Radio\" . abcnewsradioonline.com . ^ \"Classic Filter Lineup Reunion Album is Now a No-Go\" . MetalSucks . July 19, 2019. ^ a b \"RICHARD PATRICK Reveals New FILTER Album Title\" . Blabbermouth.net . July 25, 2019. ^ Childers, Chad (July 25, 2019). \"Exclusive: Filter Shelve Reunion Project, Richard Patrick Names Next Album\" . Loudwire . ^ \"FILTER To Release New Song 'Thoughts And Prayers' This Thursday\" . Blabbermouth.net . June 16, 2020. ^ \"FILTER Unveils Murica album cover\" . Blabbermouth.net . October 29, 2020. ^ \"An Interview with Richard Patrick of Filter\" . August 12, 2022.",
    "source_url": "https://en.wikipedia.org/wiki/The_Algorithm_(Filter_album)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:48.282682",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:48.283099",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:48.283099",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Snoop_Dogg_Presents_Algorithm_1_1749015170662_4549",
    "text": "Some publications described the recording as a compilation album, but the rapper's official website describes it as a studio album. [ 2 ] Released on November 19, 2021 by Doggy Style Records and Def Jam Recordings and featured contributions from various artists including Method Man & Redman , Eric Bellinger , Usher , Blxst , Fabolous , and Dave East . [ 3 ] Background [ edit ] Following his appointment as executive creative consultant at Def Jam Recordings in June, Snoop Dogg officially announced the album on October 26, 2021. [ 4 ] He subsequently released the singles \"Big Subwoofer\" on October 20 and \"Murder Music\" on November 5. [ 5 ] [ 6 ] He appeared on The Tonight Show Starring Jimmy Fallon on September 27 to tease the album, [ 7 ] and he also appeared on the podcast The Joe Rogan Experience on November 12 in promotion of the album. [ 8 ] Critical reception [ edit ] Professional ratings Aggregate scores Source Rating Metacritic 70/100",
    "source_url": "https://en.wikipedia.org/wiki/Snoop_Dogg_Presents_Algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:50.662573",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:50.662573",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:50.662573",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Snoop_Dogg_Presents_Algorithm_1_1749015170742_3626",
    "text": "\"No Bammer Weed\" Rick Rock 3:05 4. \"New Oldie\" (performed by Eric Bellinger and Usher featuring Snoop Dogg) Rance D. Phelps Quintin \"Q\" Gulledge 3:20 5. \"Make Some Money\" (performed by Fabolous and Dave East featuring Snoop Dogg) Hi-Tek 2:42 6. \"Anxiety\" (performed by Malaya ) Terrace Martin Kid Culture 2:36 7. \"Like My Weed\" (performed by Jane Handcock) SNDTRK 3:01 8. \"Applying Pressure\" (performed by YK Osiris featuring Snoop Dogg) Poo Bear Mark \"The Mogul\" Jackson 2:43 9. \"Go to War\" (with Blxst ) Jay Millian 2:51 10. \"I Want You\" (performed by October London) Soopafly Lhanze Beats 2:28 11. \"GYU\" (performed by August 08 featuring Ty Dolla Sign and Bino Rideaux) FnZ Nonstop Da Hitman Keanu Beats 3:25 12. \"Inspiration\" (performed by Malaya) Soopafly 2:27 13. \" Big Subwoofer \" (performed by Mount Westmore ) Kato P. Keys 3:43 14. \"Murder Music\" (with Benny the Butcher , Jadakiss , and Busta Rhymes ) Nottz 4:02 15. \"Been Thru\" (performed by HeyDeon) Mike Free Dilip 1:45 16.",
    "source_url": "https://en.wikipedia.org/wiki/Snoop_Dogg_Presents_Algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:50.742640",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:50.743788",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:50.743788",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Snoop_Dogg_Presents_Algorithm_1_1749015171434_5680",
    "text": "That's My Work 2 That's My Work 3 That's My Work 4 (with The Eastsidaz ) That's My Work 5 (with The Dogg Pound) LBC Movement presents Beach City Collaborations Tha Eastsidaz (with Tha Eastsidaz ) Duces 'n Trayz: The Old Fashioned Way (with Tha Eastsidaz) The Hard Way (with 213 ) 7 Days of Funk (with Dâm-Funk ) Cuzznz (with Daz Dillinger ) Snoop Cube 40 $hort (with Ice Cube , E-40 & Too $hort ) Concert tours Up in Smoke Tour Rock the Bells Related articles 213 Tha Dogg Pound Tha Eastsidaz 7 Days of Funk Mount Westmore Doggy Style Records Leafs By Snoop Mary + Jane Martha & Snoop's Potluck Dinner Party Pleezbaleevit! One More Light World Tour Snoop Dogg's Doggystyle Tekken Tag Tournament 2 Reincarnated (film)",
    "source_url": "https://en.wikipedia.org/wiki/Snoop_Dogg_Presents_Algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:51.434991",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:51.434991",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:51.434991",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Snoop_Dogg_Presents_Algorithm&oldid=1279162091_1_1749015172209_4927",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by 2a0a:ef40:a54:7501:883c:e189:8645:19d6 ( talk ) at 22:16, 6 March 2025 ( → Track listing : added page link) . The present address (URL) is a permanent link to this version. Revision as of 22:16, 6 March 2025 by 2a0a:ef40:a54:7501:883c:e189:8645:19d6 ( talk ) ( → Track listing : added page link) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) 2021 compilati",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Snoop_Dogg_Presents_Algorithm&oldid=1279162091",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:52.209343",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:52.210343",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:52.210343",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithm_(song)&oldid=1258502202_1_1749015174251_6663",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by GreenC bot ( talk | contribs ) at 02:45, 20 November 2024 (Move 1 url. Wayback Medic 2.5 per WP:URLREQ#nztop40.co.nz ) . The present address (URL) is a permanent link to this version. Revision as of 02:45, 20 November 2024 by GreenC bot ( talk | contribs ) (Move 1 url. Wayback Medic 2.5 per WP:URLREQ#nztop40.co.nz ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision →",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithm_(song)&oldid=1258502202",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:54.251108",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:54.252109",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:54.252109",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithms_(journal)&oldid=1280402334_1_1749015178426_7252",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by 1AmNobody24 ( talk | contribs ) at 12:25, 14 March 2025 (removed Category:Open access journals ; added Category:Creative Commons Attribution-licensed journals using HotCat ) . The present address (URL) is a permanent link to this version. Revision as of 12:25, 14 March 2025 by 1AmNobody24 ( talk | contribs ) (removed Category:Open access journals ; added Category:Creative Commons Attribu",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithms_(journal)&oldid=1280402334",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:32:58.426637",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:32:58.427637",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:32:58.427637",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Multi-armed_bandit_1_1749015183867_3229",
    "text": "Jump to content From Wikipedia, the free encyclopedia Resource problem in machine learning A row of slot machines in Las Vegas In probability theory and machine learning , the multi-armed bandit problem (sometimes called the K - [ 1 ] or N -armed bandit problem [ 2 ] ) is a problem in which a decision maker iteratively selects one of multiple fixed choices (i.e., arms or actions) when the properties of each choice are only partially known at the time of allocation, and may become better understo",
    "source_url": "https://en.wikipedia.org/wiki/Multi-armed_bandit",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:03.867411",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:03.867411",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:03.867411",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Algorithm_characterizations&oldid=1292124277_1_1749015193545_5975",
    "text": "By means of what Couturat (1914) called a \"sort of logical piano [,] ... the equalities which represent the premises ... are \"played\" on a keyboard like that of a typewriter. ... When all the premises have been \"played\", the panel shows only those constituents whose sum is equal to 1, that is, ... its logical whole. This mechanical method has the advantage over VENN's geometrical method...\" (Couturat 1914:75). For his part John Venn , a logician contemporary to Jevons, was less than thrilled, opining that \"it does not seem to me that any contrivances at present known or likely to be discovered really deserve the name of logical machines\" (italics added, Venn 1881:120).",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Algorithm_characterizations&oldid=1292124277",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:13.545294",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:13.545294",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:13.545294",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Multiplication_algorithm_1_1749015198091_8506",
    "text": "Grid method [ edit ] Main article: Grid method multiplication The grid method (or box method) is an introductory method for multiple-digit multiplication that is often taught to pupils at primary school or elementary school . It has been a standard part of the national primary school mathematics curriculum in England and Wales since the late 1990s. [ 3 ] Both factors are broken up (\"partitioned\") into their hundreds, tens and units parts, and the products of the parts are then calculated explicitly in a relatively simple multiplication-only stage, before these contributions are then totalled to give the final answer in a separate addition stage. The calculation 34 × 13, for example, could be computed using the grid: 300\n   40\n   90\n + 12\n ————\n  442 × 30 4 10 300 40 3 90 12 followed by addition to obtain 442, either in a single sum (see right), or through forming the row-by-row totals (300 + 40) + (90 + 12) = 340 + 102 = 442.",
    "source_url": "https://en.wikipedia.org/wiki/Multiplication_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:18.091157",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:18.091157",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:18.091157",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Multiplication_algorithm&oldid=1271824745_1_1749015200394_6149",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Henning Makholm ( talk | contribs ) at 22:32, 25 January 2025 ( → Further improvements : Missing star in the first big-O.) . The present address (URL) is a permanent link to this version. Revision as of 22:32, 25 January 2025 by Henning Makholm ( talk | contribs ) ( → Further improvements : Missing star in the first big-O.) ( diff ) ← Previous revision | Latest revision (diff) | Newer re",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Multiplication_algorithm&oldid=1271824745",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:20.394418",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:20.395418",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:20.395418",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Remez_algorithm_1_1749015202428_8036",
    "text": "\\inf _{p\\in P_{n}}\\lVert f-p\\rVert } with the norm or Lebesgue constant of the Lagrange interpolation operator L n of the nodes ( t 1 , ..., t n + 1 ) being ‖ L n ‖ ∞ = Λ ¯ n ( T ) = max − 1 ≤ x ≤ 1 λ n ( T ; x ) , {\\displaystyle \\lVert L_{n}\\rVert _{\\infty }={\\overline {\\Lambda }}_{n}(T)=\\max _{-1\\leq x\\leq 1}\\lambda _{n}(T;x),} T being the zeros of the Chebyshev polynomials, and the Lebesgue functions being λ n ( T ; x ) = ∑ j = 1 n + 1 | l j ( x ) | , l j ( x ) = ∏ i ≠ j i = 1 n + 1 ( x − t i ) ( t j − t i ) . {\\displaystyle \\lambda _{n}(T;x)=\\sum _{j=1}^{n+1}\\left|l_{j}(x)\\right|,\\quad l_{j}(x)=\\prod _{\\stackrel {i=1}{i\\neq j}}^{n+1}{\\frac {(x-t_{i})}{(t_{j}-t_{i})}}.} Theodore A. Kilgore, [ 4 ] Carl de Boor, and Allan Pinkus [ 5 ] proved that there exists a unique t i for each L n , although not known explicitly for (ordinary) polynomials. Similarly, Λ _ n ( T ) = min − 1 ≤ x",
    "source_url": "https://en.wikipedia.org/wiki/Remez_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:22.428965",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:22.428965",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:22.428965",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Remez_algorithm_1_1749015202464_2932",
    "text": "Similarly, Λ _ n ( T ) = min − 1 ≤ x ≤ 1 λ n ( T ; x ) {\\displaystyle {\\underline {\\Lambda }}_{n}(T)=\\min _{-1\\leq x\\leq 1}\\lambda _{n}(T;x)} , and the optimality of a choice of nodes can be expressed as Λ ¯ n − Λ _ n ≥ 0. {\\displaystyle {\\overline {\\Lambda }}_{n}-{\\underline {\\Lambda }}_{n}\\geq 0.} For Chebyshev nodes, which provides a suboptimal, but analytically explicit choice, the asymptotic behavior is known as [ 6 ] Λ ¯ n ( T ) = 2 π log ⁡ ( n + 1 ) + 2 π ( γ + log ⁡ 8 π ) + α n + 1 {\\displaystyle {\\overline {\\Lambda }}_{n}(T)={\\frac {2}{\\pi }}\\log(n+1)+{\\frac {2}{\\pi }}\\left(\\gamma +\\log {\\frac {8}{\\pi }}\\right)+\\alpha _{n+1}} ( γ being the Euler–Mascheroni constant ) with 0 < α n < π 72 n 2 {\\displaystyle 0<\\alpha _{n}<{\\frac {\\pi }{72n^{2}}}} for n ≥ 1 , {\\displaystyle n\\geq 1,} and upper bound [ 7 ] Λ ¯ n ( T ) ≤ 2 π log ⁡ ( n + 1 ) + 1 {\\displaystyle {\\overline {\\Lambda }}_{",
    "source_url": "https://en.wikipedia.org/wiki/Remez_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:22.464473",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:22.464473",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:22.464473",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Remez_algorithm_1_1749015202501_9811",
    "text": "upper bound [ 7 ] Λ ¯ n ( T ) ≤ 2 π log ⁡ ( n + 1 ) + 1 {\\displaystyle {\\overline {\\Lambda }}_{ n}(T)\\leq {\\frac {2}{\\pi }}\\log(n+1)+1} Lev Brutman [ 8 ] obtained the bound for n ≥ 3 {\\displaystyle n\\geq 3} , and T ^ {\\displaystyle {\\hat {T}}} being the zeros of the expanded Chebyshev polynomials: Λ ¯ n ( T ^ ) − Λ _ n ( T ^ ) < Λ ¯ 3 − 1 6 cot ⁡ π 8 + π 64 1 sin 2 ⁡ ( 3 π / 16 ) − 2 π ( γ − log ⁡ π ) ≈ 0.201. {\\displaystyle {\\overline {\\Lambda }}_{n}({\\hat {T}})-{\\underline {\\Lambda }}_{n}({\\hat {T}})<{\\overline {\\Lambda }}_{3}-{\\frac {1}{6}}\\cot {\\frac {\\pi }{8}}+{\\frac {\\pi }{64}}{\\frac {1}{\\sin ^{2}(3\\pi /16)}}-{\\frac {2}{\\pi }}(\\gamma -\\log \\pi )\\approx 0.201.} Rüdiger Günttner [ 9 ] obtained from a sharper estimate for n ≥ 40 {\\displaystyle n\\geq 40} Λ ¯ n ( T ^ ) − Λ _ n ( T ^ ) < 0.0196. {\\displaystyle {\\overline {\\Lambda }}_{n}({\\hat {T}})-{\\underline {\\Lambda }}_{n}({\\hat {T}})<0.0196.} Detailed discussion [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Remez_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:22.501486",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:22.501486",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:22.501486",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Remez_algorithm_1_1749015202602_1733",
    "text": ", n {\\displaystyle 0,...,n} and O ( n 2 ) {\\displaystyle O(n^{2})} arithmetic operations. The polynomial p 2 ( x ) {\\displaystyle p_{2}(x)} has its i -th zero between x i − 1 {\\displaystyle x_{i-1}} and x i , i = 1 , . . . , n {\\displaystyle x_{i},\\ i=1,...,n} , and thus no further zeroes between x n {\\displaystyle x_{n}} and x n + 1 {\\displaystyle x_{n+1}} : p 2 ( x n ) {\\displaystyle p_{2}(x_{n})} and p 2 ( x n + 1 ) {\\displaystyle p_{2}(x_{n+1})} have the same sign ( − 1 ) n {\\displaystyle (-1)^{n}} . The linear combination p ( x ) := p 1 ( x ) − p 2 ( x ) ⋅ E {\\displaystyle p(x):=p_{1}(x)-p_{2}(x)\\!\\cdot \\!E} is also a polynomial of degree n and p ( x i ) = p 1 ( x i ) − p 2 ( x i ) ⋅ E = f ( x i ) − ( − 1 ) i E , i = 0 , … , n . {\\displaystyle p(x_{i})=p_{1}(x_{i})-p_{2}(x_{i})\\!\\cdot \\!E\\ =\\ f(x_{i})-(-1)^{i}E,\\ \\ \\ \\ i=0,\\ldots ,n.} This is the same as the equation above for i = 0 , . . . , n {\\displaystyle i=0,...,n} and for any choice of E . The same equation for i = n",
    "source_url": "https://en.wikipedia.org/wiki/Remez_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:22.602136",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:22.602136",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:22.602136",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Remez_algorithm_1_1749015202637_4843",
    "text": ", n {\\displaystyle i=0,...,n} and for any choice of E . The same equation for i = n +1 is p ( x n + 1 ) = p 1 ( x n + 1 ) − p 2 ( x n + 1 ) ⋅ E = f ( x n + 1 ) − ( − 1 ) n + 1 E {\\displaystyle p(x_{n+1})\\ =\\ p_{1}(x_{n+1})-p_{2}(x_{n+1})\\!\\cdot \\!E\\ =\\ f(x_{n+1})-(-1)^{n+1}E} and needs special reasoning:  solved for the variable E , it is the definition of E : E := p 1 ( x n + 1 ) − f ( x n + 1 ) p 2 ( x n + 1 ) + ( − 1 ) n . {\\displaystyle E\\ :=\\ {\\frac {p_{1}(x_{n+1})-f(x_{n+1})}{p_{2}(x_{n+1})+(-1)^{n}}}.} As mentioned above, the two terms in the denominator have same sign: E and thus p ( x ) ≡ b 0 + b 1 x + … + b n x n {\\displaystyle p(x)\\equiv b_{0}+b_{1}x+\\ldots +b_{n}x^{n}} are always well-defined. The error at the given n +2 ordered nodes is positive and negative in turn because p ( x i ) − f ( x i ) = − ( − 1 ) i E , i = 0 , . . . , n + 1. {\\displaystyle p(x_{i})-f(x_{i})\\ =\\ -(-1)^{i}E,\\ \\ i=0,...,n\\!+\\!1.}",
    "source_url": "https://en.wikipedia.org/wiki/Remez_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:22.637740",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:22.637740",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:22.637740",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Remez_algorithm_1_1749015202672_4938",
    "text": "i E , i = 0 , . . . , n + 1. {\\displaystyle p(x_{i})-f(x_{i})\\ =\\ -(-1)^{i}E,\\ \\ i=0,...,n\\!+\\!1.} The theorem of de La Vallée Poussin states that under this condition no polynomial of degree n exists with error less than E . Indeed, if such a polynomial existed, call it p ~ ( x ) {\\displaystyle {\\tilde {p}}(x)} , then the difference p ( x ) − p ~ ( x ) = ( p ( x ) − f ( x ) ) − ( p ~ ( x ) − f ( x ) ) {\\displaystyle p(x)-{\\tilde {p}}(x)=(p(x)-f(x))-({\\tilde {p}}(x)-f(x))} would still be positive/negative at the n +2 nodes x i {\\displaystyle x_{i}} and therefore have at least n +1 zeros which is impossible for a polynomial of degree n . Thus, this E is a lower bound for the minimum error which can be achieved with polynomials of degree n . Step 2 changes the notation from b 0 + b 1 x + . . . + b n x n {\\displaystyle b_{0}+b_{1}x+...+b_{n}x^{n}} to p ( x ) {\\displaystyle p(x)} . Step 3 improves upon the input nodes x 0 , . . .",
    "source_url": "https://en.wikipedia.org/wiki/Remez_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:22.672255",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:22.672255",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:22.672255",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Division_algorithm&oldid=1289772055_1_1749015206325_1604",
    "text": "Step 5 :  R < D, so skip statement Step 2 :  Set i=2 Step 3 :  R=010 Step 4 :  R=011 Step 5 :  R < D, statement skipped Step 2 : Set i=1 Step 3 :  R=0110 Step 4 : R=0110 Step 5 :  R>=D, statement entered Step 5b :  R=10 (R−D) Step 5c :  Q=10 (setting Q(i) to 1) Step 2 : Set i=0 Step 3 :  R=100 Step 4 :  R=100 Step 5 :  R>=D, statement entered Step 5b :  R=0 (R−D) Step 5c :  Q=11 (setting Q(i) to 1) end Q=11 2 (3 10 ) and R=0.",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Division_algorithm&oldid=1289772055",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:26.325837",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:26.325837",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:26.325837",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Profiling_(computer_programming)&oldid=1286436094_1_1749015215719_9882",
    "text": "/* ------------ source------------------------- count */             \n0001 IF X = \"A\"                      0055\n0002                THEN DO                       \n0003                    ADD 1 to XCOUNT         0032\n0004                ELSE\n0005 IF X = \"B\"                      0055 A stream of recorded events (a trace ) For sequential programs, a summary profile is usually sufficient, but performance problems in parallel programs (waiting for messages or synchronization issues) often depend on the time relationship of events, thus requiring a full trace to get an understanding of what is happening. The size of a (full) trace is linear to the program's instruction path length , making it somewhat impractical. A trace may therefore be initiated at one point in a program and terminated at another point to limit the output. An ongoing interaction with the hypervisor (continuous or periodic monitoring via on-screen display for instance)",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Profiling_(computer_programming)&oldid=1286436094",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:35.719469",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:35.719469",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:35.719469",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Profiling_(computer_programming)&oldid=1286436094_1_1749015215810_8850",
    "text": "In 1982 gprof extended the concept to a complete call graph analysis. [ 8 ] In 1994, Amitabh Srivastava and Alan Eustace of Digital Equipment Corporation published a paper describing ATOM [ 9 ] (Analysis Tools with OM). The ATOM platform converts a program into its own profiler: at compile time , it inserts code into the program to be analyzed. That inserted code outputs analysis data. This technique - modifying a program to analyze itself - is known as \" instrumentation \". In 2004 both the gprof and ATOM papers appeared on the list of the 50 most influential PLDI papers for the 20-year period ending in 1999. [ 10 ] Profiler types based on output [ edit ] Flat profiler [ edit ] Flat profilers compute the average call times, from the calls, and do not break down the call times based on the callee or the context. Call-graph profiler [ edit ] Call graph profilers [ 8 ] show the call times, and frequencies of the functions, and also the call-chains involved based on the callee.",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Profiling_(computer_programming)&oldid=1286436094",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:35.810997",
    "symbols_found_in_chunk": 2,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:35.810997",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:35.810997",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Constant-factor_approximation_algorithm_1_1749015222850_2825",
    "text": "Unless P = NP there exist problems that are in APX but without a PTAS, so the class of problems with a PTAS is strictly contained in APX. One example of a problem with a PTAS is the knapsack problem . APX-hardness and APX-completeness [ edit ] A problem is said to be APX-hard if there is a PTAS reduction from every problem in APX to that problem, and to be APX-complete if the problem is APX-hard and also in APX. As a consequence of P ≠ NP ⇒ PTAS ≠ APX, if P ≠ NP is assumed, no APX-hard problem has a PTAS. In practice, reducing one problem to another to demonstrate APX-completeness is often done using other reduction schemes, such as L-reductions , which imply PTAS reductions. Examples [ edit ] One of the simplest APX-complete problems is MAX-3SAT-3 , a variation of the Boolean satisfiability problem .",
    "source_url": "https://en.wikipedia.org/wiki/Constant-factor_approximation_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:42.850131",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:42.850131",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:42.850131",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Constant-factor_approximation_algorithm_1_1749015222873_9553",
    "text": "In this problem, we have a Boolean formula in conjunctive normal form where each variable appears at most 3 times, and we wish to know the maximum number of clauses that can be simultaneously satisfied by a single assignment of true/false values to the variables. Other APX-complete problems include: Max independent set in bounded-degree graphs (here, the approximation ratio depends on the maximum degree of the graph, but is constant if the max degree is fixed). Min vertex cover . The complement of any maximal independent set must be a vertex cover. Min dominating set in bounded-degree graphs. The travelling salesman problem when the distances in the graph satisfy the conditions of a metric . TSP is NPO-complete in the general case. The token reconfiguration problem, via L-reduction from set cover.",
    "source_url": "https://en.wikipedia.org/wiki/Constant-factor_approximation_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:42.873672",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:42.874665",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:42.874665",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoid_method_1_1749015225866_8432",
    "text": "{\\displaystyle f_{i}(x)\\leqslant 0} , where the functions f i {\\displaystyle f_{i}} are convex; these constraints define a convex set Q {\\displaystyle Q} . Linear equality constraints of the form h i ( x ) = 0 {\\displaystyle h_{i}(x)=0} . We are also given an initial ellipsoid E ( 0 ) ⊂ R n {\\displaystyle {\\mathcal {E}}^{(0)}\\subset \\mathbb {R} ^{n}} defined as E ( 0 ) = { z ∈ R n : ( z − x 0 ) T P ( 0 ) − 1 ( z − x 0 ) ⩽ 1 } {\\displaystyle {\\mathcal {E}}^{(0)}=\\left\\{z\\in \\mathbb {R} ^{n}\\ :\\ (z-x_{0})^{T}P_{(0)}^{-1}(z-x_{0})\\leqslant 1\\right\\}} containing a minimizer x ∗ {\\displaystyle x^{*}} , where P ( 0 ) ≻ 0 {\\displaystyle P_{(0)}\\succ 0} and x 0 {\\displaystyle x_{0}} is the center of E {\\displaystyle {\\mathcal {E}}} . Finally, we require the existence of a separation oracle for the convex set Q {\\displaystyle Q} .",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoid_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:45.866159",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:45.867151",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:45.867151",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoid_method_1_1749015225897_8734",
    "text": "Finally, we require the existence of a separation oracle for the convex set Q {\\displaystyle Q} . Given a point x ∈ R n {\\displaystyle x\\in \\mathbb {R} ^{n}} , the oracle should return one of two answers: [ 5 ] \"The point x {\\displaystyle x} is in Q {\\displaystyle Q} \", or - \"The point x {\\displaystyle x} is not in Q {\\displaystyle Q} , and moreover, here is a hyperplane that separates x {\\displaystyle x} from Q {\\displaystyle Q} \", that is, a vector c {\\displaystyle c} such that c ⋅ x < c ⋅ y {\\displaystyle c\\cdot x<c\\cdot y} for all y ∈ Q {\\displaystyle y\\in Q} . The output of the ellipsoid method is either: Any point in the polytope Q {\\displaystyle Q} (i.e., any feasible point), or - A proof that Q {\\displaystyle Q} is empty. Inequality-constrained minimization of a function that is zero everywhere corresponds to the problem of simply identifying any feasible point.",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoid_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:45.897167",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:45.897167",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:45.897167",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoid_method_1_1749015225976_1984",
    "text": "We query the cutting-plane oracle to obtain a vector g ( k + 1 ) ∈ R n {\\displaystyle g^{(k+1)}\\in \\mathbb {R} ^{n}} such that g ( k + 1 ) T ( x ∗ − x ( k ) ) ⩽ 0. {\\displaystyle g^{(k+1)T}\\left(x^{*}-x^{(k)}\\right)\\leqslant 0.} We therefore conclude that x ∗ ∈ E ( k ) ∩ { z : g ( k + 1 ) T ( z − x ( k ) ) ⩽ 0 } . {\\displaystyle x^{*}\\in {\\mathcal {E}}^{(k)}\\cap \\left\\{z\\ :\\ g^{(k+1)T}\\left(z-x^{(k)}\\right)\\leqslant 0\\right\\}.} We set E ( k + 1 ) {\\displaystyle {\\mathcal {E}}^{(k+1)}} to be the ellipsoid of minimal volume containing the half-ellipsoid described above and compute x ( k + 1 ) {\\displaystyle x^{(k+1)}} . The update is given by x ( k + 1 ) = x ( k ) − 1 n + 1 P ( k ) g ~ ( k + 1 ) P ( k + 1 ) = n 2 n 2 − 1 ( P ( k ) − 2 n + 1 P ( k ) g ~ ( k + 1 ) g ~ ( k + 1 ) T P ( k ) )",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoid_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:45.976202",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:45.976202",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:45.976202",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoid_method_1_1749015226048_1068",
    "text": "We also must maintain a list of values f b e s t ( k ) {\\displaystyle f_{\\rm {best}}^{(k)}} recording the smallest objective value of feasible iterates so far. Depending on whether or not the point x ( k ) {\\displaystyle x^{(k)}} is feasible, we perform one of two tasks: If x ( k ) {\\displaystyle x^{(k)}} is feasible, perform essentially the same update as in the unconstrained case, by choosing a subgradient g 0 {\\displaystyle g_{0}} that satisfies g 0 T ( x ∗ − x ( k ) ) + f 0 ( x ( k ) ) − f b e s t ( k ) ⩽ 0 {\\displaystyle g_{0}^{T}(x^{*}-x^{(k)})+f_{0}(x^{(k)})-f_{\\rm {best}}^{(k)}\\leqslant 0} If x ( k ) {\\displaystyle x^{(k)}} is infeasible and violates the j -th constraint, update the ellipsoid with a feasibility cut. Our feasibility cut may be a subgradient g j {\\displaystyle g_{j}} of f j {\\displaystyle f_{j}} which must satisfy g j T ( z − x ( k ) ) + f j ( x ( k ) ) ⩽ 0 {\\displaystyle g_{j}^{T}(z-x^{(k)})+f_{j}(x^{(k)})\\leqslant 0} for all feasible z .",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoid_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:46.048697",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:46.048697",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:46.048697",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoid_method_1_1749015226080_3871",
    "text": "⩽ 0 {\\displaystyle g_{j}^{T}(z-x^{(k)})+f_{j}(x^{(k)})\\leqslant 0} for all feasible z . Performance in convex programs [ edit ] Theoretical run-time complexity guarantee [ edit ] The run-time complexity guarantee of the ellipsoid method in the real RAM model is given by the following theorem. [ 7 ] : Thm.8.3.1 Consider a family of convex optimization problems of the form: minimize f ( x ) s.t. x is in G , where f is a convex function and G is a convex set (a subset of an Euclidean space R n ). Each problem p in the family is represented by a data-vector Data( p ), e.g., the real-valued coefficients in matrices and vectors representing the function f and the feasible region G . The size of a problem p , Size( p ),  is defined as the number of elements (real numbers) in Data( p ). The following assumptions are needed: G (the feasible region) is: Bounded; Has a non-empty interior (so there is a strictly-feasible point); Given Data( p ), one can compute using poly(Size(p))",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoid_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:46.080239",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:46.080239",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:46.080239",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoid_method_1_1749015226114_1054",
    "text": "Given Data( p ), one can compute using poly(Size(p)) arithmetic operations: An ellipsoid that contains G ; A lower bound 'MinVol(p)>0' of the volume G . Given Data( p ) and a point x in R n , one can compute using poly(Size(p)) arithmetic operations: A separation oracle for G (that is: either assert that x is in G , or return a hyperplane separating x from G ). A first-order oracle for f (that is: compute the value of f ( x ) and a subgradient f' ( x )). Under these assumptions, the ellipsoid method is \"R-polynomial\". This means that there exists a polynomial Poly such that, for every problem-instance p and every approximation-ratio ε >0, the method finds a solution x satisfying : f ( x ) − min G f ≤ ε ⋅ [ max G f − min G f ] {\\displaystyle f(x)-\\min _{G}f\\leq \\varepsilon \\cdot [\\max _{G}f-\\min _{G}f]} , using at most the following number of arithmetic operations on real numbers: P o l y ( S i z e ( p ) )",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoid_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:46.114457",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:46.114457",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:46.114457",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Parameterized_approximation_algorithm_1_1749015228545_9482",
    "text": "For example, some problems that are APX-hard and W[1]-hard admit a parameterized approximation scheme (PAS) , i.e., for any ε > 0 {\\displaystyle \\varepsilon >0} a ( 1 + ε ) {\\displaystyle (1+\\varepsilon )} -approximation can be computed in f ( k , ε ) n g ( ε ) {\\displaystyle f(k,\\varepsilon )n^{g(\\varepsilon )}} time for some functions f and g . This then circumvents the lower bounds in terms of polynomial-time approximation and fixed-parameter tractability. A PAS is similar in spirit to a polynomial-time approximation scheme (PTAS) but additionally exploits a given parameter k . Since the degree of the polynomial in the runtime of a PAS depends on a function g ( ε ) {\\displaystyle g(\\varepsilon )} , the value of ε {\\displaystyle \\varepsilon } is assumed to be arbitrary but constant in order for the PAS to run in FPT time.",
    "source_url": "https://en.wikipedia.org/wiki/Parameterized_approximation_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:48.545948",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:48.546947",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:48.546947",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Parameterized_approximation_algorithm_1_1749015228623_5648",
    "text": "O ( 1 ) {\\displaystyle (k/\\varepsilon )^{O(k)}n^{O(1)}} time. [ 5 ] Travelling Salesman [ edit ] The Travelling Salesman problem is APX-hard and paraNP-hard parameterized by the doubling dimension (as it is NP-hard in the Euclidean plane ). However, an EPAS exists parameterized by the doubling dimension , and even for the more general highway dimension parameter. [ 6 ] Steiner Tree [ edit ] The Steiner Tree problem is FPT parameterized by the number of terminals. [ 7 ] However, for the \"dual\" parameter consisting of the number k of non-terminals contained in the optimum solution, the problem is W[2]-hard (due to a folklore reduction from the Dominating Set problem ). Steiner Tree is also known to be APX-hard . [ 8 ] However, there is an EPAS computing a ( 1 + ε ) {\\displaystyle (1+\\varepsilon )} -approximation in 2 O ( k 2 / ε 4 ) n O ( 1 ) { \\displaystyle 2^{O(k^{2}/\\varepsilon ^{4})}n^{O(1)}} time. [ 9 ] The more general Steiner Forest problem is NP-hard on graphs of treewidth 3.",
    "source_url": "https://en.wikipedia.org/wiki/Parameterized_approximation_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:48.623006",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:48.623006",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:48.623006",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Parameterized_approximation_algorithm_1_1749015228655_7291",
    "text": "[ 9 ] The more general Steiner Forest problem is NP-hard on graphs of treewidth 3. However, on graphs of treewidth t an EPAS can compute a ( 1 + ε ) {\\displaystyle (1+\\varepsilon )} -approximation in 2 O ( t 2 ε log ⁡ t ε ) n O ( 1 ) {\\displaystyle 2^{O({\\frac {t^{2}}{\\varepsilon }}\\log {\\frac {t}{\\varepsilon }})}n^{O(1)}} time. [ 10 ] Strongly-Connected Steiner Subgraph [ edit ] It is known that the Strongly Connected Steiner Subgraph problem is W[1]-hard parameterized by the number k of terminals, [ 11 ] and also does not admit an O ( log 2 − ε ⁡ n ) {\\displaystyle O(\\log ^{2-\\varepsilon }n)} -approximation in polynomial time (under standard complexity assumptions ). [ 12 ] However a 2-approximation can be computed in 3 k n O ( 1 ) {\\displaystyle 3^{k}n^{O(1)}} time. [ 13 ] Furthermore, this is best possible, since no ( 2 − ε ) {\\displaystyle (2-\\varepsilon )} -approximation can be computed in f ( k ) n O ( 1 ) {\\displaystyle f(k)n^{O(1)}} time for any function f , under Gap- ETH .",
    "source_url": "https://en.wikipedia.org/wiki/Parameterized_approximation_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:48.655007",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:48.656007",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:48.656007",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Parameterized_approximation_algorithm_1_1749015228761_6945",
    "text": "Furthermore, the k-Center problem is W[1]-hard even on planar graphs when simultaneously parameterizing it by the number k of centers, the doubling dimension , the highway dimension , and the pathwidth . [ 24 ] However, when combining k with the doubling dimension an EPAS exists, [ 24 ] and the same is true when combining k with the highway dimension . [ 25 ] For the more general version with vertex capacities, an EPAS exists for the parameterization by k and the doubling dimension, but not when using k and the highway dimension as the parameter. [ 26 ] Regarding the pathwidth, k-Center admits an EPAS even for the more general treewidth parameter, and also for cliquewidth . [ 27 ] Densest Subgraph [ edit ] An optimization variant of the k -Clique problem is the Densest k -Subgraph problem (which is a 2-ary Constraint Satisfaction problem ), where the task is to find a subgraph on k vertices with maximum number of edges.",
    "source_url": "https://en.wikipedia.org/wiki/Parameterized_approximation_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:48.761680",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:48.761680",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:48.761680",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Parameterized_approximation_algorithm_1_1749015229197_7229",
    "text": "It is not hard to obtain a ( k − 1 ) {\\displaystyle (k-1)} -approximation by just picking a matching of size k / 2 {\\displaystyle k/2} in the given input graph, since the maximum number of edges on k vertices is always at most ( k 2 ) = k ( k − 1 ) / 2 {\\displaystyle {k \\choose 2}=k(k-1)/2} . This is also asymptotically optimal, since under Gap- ETH no k 1 − o ( 1 ) {\\displaystyle k^{1-o(1)}} -approximation can be computed in FPT time parameterized by k . [ 28 ] Dominating Set [ edit ] For the Dominating set problem it is W[1]-hard to compute any g ( k ) {\\displaystyle g(k)} -approximation in f ( k ) n O ( 1 ) {\\displaystyle f(k)n^{O(1)}} time for any functions g and f . [ 29 ] Approximate kernelization [ edit ] Kernelization is a technique used in fixed-parameter tractability to pre-process an instance of an NP-hard problem in order to remove \"easy parts\" and reveal the NP-hard core of the instance.",
    "source_url": "https://en.wikipedia.org/wiki/Parameterized_approximation_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:49.197462",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:49.198462",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:49.198462",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Parameterized_approximation_algorithm&oldid=1293612300_1_1749015230615_6561",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Ira Leviton ( talk | contribs ) at 18:31, 2 June 2025 (Fixed a reference.  Please see Category:CS1 errors: dates .) . The present address (URL) is a permanent link to this version. Revision as of 18:31, 2 June 2025 by Ira Leviton ( talk | contribs ) (Fixed a reference.  Please see Category:CS1 errors: dates .) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Parameterized_approximation_algorithm&oldid=1293612300",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:50.615059",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:50.615059",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:50.615059",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Optimization_algorithm_1_1749015234672_3238",
    "text": "The domain A of f is called the search space or the choice set , while the elements of A are called candidate solutions or feasible solutions . The function f is variously called an objective function , criterion function , loss function , cost function (minimization), [ 6 ] utility function or fitness function (maximization), or, in certain fields, an energy function or energy functional . A feasible solution that minimizes (or maximizes) the objective function is called an optimal solution . In mathematics, conventional optimization problems are usually stated in terms of minimization. A local minimum x * is defined as an element for which there exists some δ > 0 such that ∀ x ∈",
    "source_url": "https://en.wikipedia.org/wiki/Optimization_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:54.672449",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:54.672449",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:54.672449",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Optimization_algorithm_1_1749015234703_1288",
    "text": "A local minimum x * is defined as an element for which there exists some δ > 0 such that ∀ x ∈ A where ‖ x − x ∗ ‖ ≤ δ , {\\displaystyle \\forall \\mathbf {x} \\in A\\;{\\text{where}}\\;\\left\\Vert \\mathbf {x} -\\mathbf {x} ^{\\ast }\\right\\Vert \\leq \\delta ,\\,} the expression f ( x *) ≤ f ( x ) holds; that is to say, on some region around x * all of the function values are greater than or equal to the value at that element. Local maxima are defined similarly. While a local minimum is at least as good as any nearby elements, a global minimum is at least as good as every feasible element. Generally, unless the objective function is convex in a minimization problem, there may be several local minima. In a convex problem , if there is a local minimum that is interior (not on the edge of the set of feasible elements), it is also the global minimum, but a nonconvex problem may have more than one local minimum not all of which need be global minima.",
    "source_url": "https://en.wikipedia.org/wiki/Optimization_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:54.703038",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:54.703038",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:54.703038",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Combinatorial_optimization_1_1749015237469_7393",
    "text": "Jump to content From Wikipedia, the free encyclopedia Subfield of mathematical optimization A minimum spanning tree of a weighted planar graph . Finding a minimum spanning tree is a common problem involving combinatorial optimization. Combinatorial optimization is a subfield of mathematical optimization that consists of finding an optimal object from a finite set of objects, [ 1 ] where the set of feasible solutions is discrete or can be reduced to a discrete set. Typical combinatorial optimizat",
    "source_url": "https://en.wikipedia.org/wiki/Combinatorial_optimization",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:57.469311",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:57.469311",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:57.469311",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Revised_simplex_method_1_1749015239616_6409",
    "text": "[ a ] Since A has full rank, B is nonsingular. Without loss of generality, assume that A = [ B N ] . Then x is given by x = [ x B x N ] = [ B − 1 b 0 ] {\\displaystyle {\\boldsymbol {x}}={\\begin{bmatrix}{\\boldsymbol {x_{B}}}\\\\{\\boldsymbol {x_{N}}}\\end{bmatrix}}={\\begin{bmatrix}{\\boldsymbol {B}}^{-1}{\\boldsymbol {b}}\\\\{\\boldsymbol {0}}\\end{bmatrix}}} where x B ≥ 0 . Partition c and s accordingly into c = [ c B c N ] , s = [ s B s N ] . {\\displaystyle {\\begin{aligned}{\\boldsymbol {c}}&={\\begin{bmatrix}{\\boldsymbol {c_{B}}}\\\\{\\boldsymbol {c_{N}}}\\end{bmatrix}},\\\\{\\boldsymbol {s}}&={\\begin{bmatrix}{\\boldsymbol {s_{B}}}\\\\{\\boldsymbol {s_{N}}}\\end{bmatrix}}.\\end{aligned}}} To satisfy the complementary slackness condition, let s B = 0 .",
    "source_url": "https://en.wikipedia.org/wiki/Revised_simplex_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:59.616319",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:59.616319",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:59.616319",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Revised_simplex_method_1_1749015239646_7872",
    "text": "It follows that B T λ = c B , N T λ + s N = c N , {\\displaystyle {\\begin{aligned}{\\boldsymbol {B}}^{\\mathrm {T} }{\\boldsymbol {\\lambda }}&={\\boldsymbol {c_{B}}},\\\\{\\boldsymbol {N}}^{\\mathrm {T} }{\\boldsymbol {\\lambda }}+{\\boldsymbol {s_{N}}}&={\\boldsymbol {c_{N}}},\\end{aligned}}} which implies that λ = ( B T ) − 1 c B , s N = c N − N T λ . {\\displaystyle {\\begin{aligned}{\\boldsymbol {\\lambda }}&=({\\boldsymbol {B}}^{\\mathrm {T} })^{-1}{\\boldsymbol {c_{B}}},\\\\{\\boldsymbol {s_{N}}}&={\\boldsymbol {c_{N}}}-{\\boldsymbol {N}}^{\\mathrm {T} }{\\boldsymbol {\\lambda }}.\\end{aligned}}} If s N ≥ 0 at this point, the KKT conditions are satisfied, and thus x is optimal. Pivot operation [ edit ] If the KKT conditions are violated, a pivot operation consisting of introducing a column of N into the basis at the expense of an existing column in B is performed. In the absence of degeneracy , a pivot operation always results in a strict decrease in c T x .",
    "source_url": "https://en.wikipedia.org/wiki/Revised_simplex_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:59.646417",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:59.646417",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:59.646417",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Revised_simplex_method_1_1749015239679_7563",
    "text": "In the absence of degeneracy , a pivot operation always results in a strict decrease in c T x . Therefore, if the problem is bounded, the revised simplex method must terminate at an optimal vertex after repeated pivot operations because there are only a finite number of vertices. [ 4 ] Select an index m < q ≤ n such that s q < 0 as the entering index . The corresponding column of A , A q , will be moved into the basis, and x q will be allowed to increase from zero. It can be shown that ∂ ( c T x ) ∂ x q = s q , {\\displaystyle {\\frac {\\partial ({\\boldsymbol {c}}^{\\mathrm {T} }{\\boldsymbol {x}})}{\\partial x_{q}}}=s_{q},} i.e., every unit increase in x q results in a decrease by − s q in c T x . [ 5 ] Since B x B + A q x q = b , {\\displaystyle {\\boldsymbol {Bx_{B}}}+{\\boldsymbol {A}}_{q}x_{q}={\\boldsymbol {b}},} x B must be correspondingly decreased by Δ x B = B −1 A q x q subject to x B − Δ x B ≥ 0 . Let d = B −1 A q .",
    "source_url": "https://en.wikipedia.org/wiki/Revised_simplex_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:59.679430",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:59.679430",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:59.679430",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Revised_simplex_method_1_1749015239705_1863",
    "text": "A q x q subject to x B − Δ x B ≥ 0 . Let d = B −1 A q . If d ≤ 0 , no matter how much x q is increased, x B − Δ x B will stay nonnegative. Hence, c T x can be arbitrarily decreased, and thus the problem is unbounded. Otherwise, select an index p = argmin 1≤ i ≤ m { x i / d i | d i > 0} as the leaving index . This choice effectively increases x q from zero until x p is reduced to zero while maintaining feasibility. The pivot operation concludes with replacing A p with A q in the basis. Numerical example [ edit ] See also: Simplex method § Example Consider a linear program where c = [ − 2 − 3 − 4 0 0 ] T , A = [ 3 2 1 1 0 2 5 3 0 1 ] , b = [ 10 15 ] .",
    "source_url": "https://en.wikipedia.org/wiki/Revised_simplex_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:59.705535",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:59.705535",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:59.705535",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Revised_simplex_method_1_1749015239730_3351",
    "text": "T , A = [ 3 2 1 1 0 2 5 3 0 1 ] , b = [ 10 15 ] . {\\displaystyle {\\begin{aligned}{\\boldsymbol {c}}&={\\begin{bmatrix}-2&-3&-4&0&0\\end{bmatrix}}^{\\mathrm {T} },\\\\{\\boldsymbol {A}}&={\\begin{bmatrix}3&2&1&1&0\\\\2&5&3&0&1\\end{bmatrix}},\\\\{\\boldsymbol {b}}&={\\begin{bmatrix}10\\\\15\\end{bmatrix}}.\\end{aligned}}} Let B = [ A 4 A 5 ] , N = [ A 1 A 2 A 3 ] {\\displaystyle {\\begin{aligned}{\\boldsymbol {B}}&={\\begin{bmatrix}{\\boldsymbol {A}}_{4}&{\\boldsymbol {A}}_{5}\\end{bmatrix}},\\\\{\\boldsymbol {N}}&={\\begin{bmatrix}{\\boldsymbol {A}}_{1}&{\\boldsymbol {A}}_{2}&{\\boldsymbol {A}}_{3}\\end{bmatrix}}\\end{aligned}}} initially, which corresponds to a feasible vertex x = [0 0 0 10 15] T . At this moment, λ = [ 0 0 ] T , s N = [ − 2 − 3 − 4 ] T . {\\displaystyle {\\begin{aligned}{\\boldsymbol {\\lambda }}&={\\begin{bmatrix}0&0\\end{bmatrix}}^{\\mathrm {T} },\\\\{\\boldsymbol {s_{N}}}&={\\begin{bmatrix}-2&-3&-4\\end{bmatrix}}^{\\mathrm {T} }.\\end{aligned}}} Choose q = 3 as the entering index.",
    "source_url": "https://en.wikipedia.org/wiki/Revised_simplex_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:59.730947",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:59.730947",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:59.730947",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Revised_simplex_method_1_1749015239759_7013",
    "text": "Then d = [1 3] T , which means a unit increase in x 3 results in x 4 and x 5 being decreased by 1 and 3 , respectively. Therefore, x 3 is increased to 5 , at which point x 5 is reduced to zero, and p = 5 becomes the leaving index. After the pivot operation, B = [ A 3 A 4 ] , N = [ A 1 A 2 A 5 ] . {\\displaystyle {\\begin{aligned}{\\boldsymbol {B}}&={\\begin{bmatrix}{\\boldsymbol {A}}_{3}&{\\boldsymbol {A}}_{4}\\end{bmatrix}},\\\\{\\boldsymbol {N}}&={\\begin{bmatrix}{\\boldsymbol {A}}_{1}&{\\boldsymbol {A}}_{2}&{\\boldsymbol {A}}_{5}\\end{bmatrix}}.\\end{aligned}}} Correspondingly, x = [ 0 0 5 5 0 ] T , λ = [ 0 − 4 / 3 ] T , s N = [ 2 / 3 11 / 3 4 / 3 ] T . {\\displaystyle {\\begin{aligned}{\\boldsymbol {x}}&={\\begin{bmatrix}0&0&5&5&0\\end{bmatrix}}^{\\mathrm {T} },\\\\{\\boldsymbol {\\lambda }}&={\\begin{bmatrix}0&-4/3\\end{bmatrix}}^{\\mathrm {T} },\\\\{\\boldsymbol {s_{N}}}&={\\begin{bmatrix}2/3&11/3&4/3\\end{bmatrix}}^{\\mathrm {T} }.\\end{aligned}}} A positive s N indicates that x is now optimal.",
    "source_url": "https://en.wikipedia.org/wiki/Revised_simplex_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:33:59.759948",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:33:59.760950",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:33:59.760950",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Evolutionary_algorithm&oldid=1292815838_1_1749015254908_2757",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by EvanBaldonado ( talk | contribs ) at 00:11, 29 May 2025 (Replace curly quotes with straight quotes (see MOS:CURLY ).) . The present address (URL) is a permanent link to this version. Revision as of 00:11, 29 May 2025 by EvanBaldonado ( talk | contribs ) (Replace curly quotes with straight quotes (see MOS:CURLY ).) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Evolutionary_algorithm&oldid=1292815838",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:14.908602",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:14.908602",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:14.908602",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Spiral_optimization_algorithm_1_1749015256508_7011",
    "text": "1) Place the initial search points x i ( 0 ) ∈ R n ( i = 1 , … , m ) {\\displaystyle x_{i}(0)\\in \\mathbb {R} ^{n}~(i=1,\\ldots ,m)} and determine the center x ⋆ ( 0 ) = x i b ( 0 ) {\\displaystyle x^{\\star }(0)=x_{i_{\\text{b}}}(0)} , i b = argmin i = 1 , … , m ⁡ { f ( x i ( 0 ) ) } {\\displaystyle \\displaystyle i_{\\text{b}}=\\mathop {\\text{argmin}} _{i=1,\\ldots ,m}\\{f(x_{i}(0))\\}} ,and then set k = 0 {\\displaystyle k=0} .\n2) Decide the step rate r ( k ) {\\displaystyle r(k)} by a rule. 3) Update the search points: x i ( k + 1 ) = x ⋆ ( k ) + r ( k ) R ( θ ) ( x i ( k ) − x ⋆ ( k ) ) ( i = 1 , … , m ) . {\\displaystyle x_{i}(k+1)=x^{\\star }(k)+r(k)R(\\theta )(x_{i}(k)-x^{\\star }(k))\\quad (i=1,\\ldots ,m).} 4) Update the center: x ⋆ ( k + 1 ) = { x i b ( k + 1 ) ( if f ( x i b ( k + 1 ) )",
    "source_url": "https://en.wikipedia.org/wiki/Spiral_optimization_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:16.508142",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:16.508142",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:16.508142",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Spiral_optimization_algorithm_1_1749015256546_1576",
    "text": "⋆ ( k + 1 ) = { x i b ( k + 1 ) ( if f ( x i b ( k + 1 ) ) < f ( x ⋆ ( k ) ) ) , x ⋆ ( k ) ( otherwise ) , {\\displaystyle x^{\\star }(k+1)={\\begin{cases}x_{i_{\\text{b}}}(k+1)&{\\big (}{\\text{if }}f(x_{i_{\\text{b}}}(k+1))<f(x^{\\star }(k)){\\big )},\\\\x^{\\star }(k)&{\\big (}{\\text{otherwise}}{\\big )},\\end{cases}}} where i b = argmin i = 1 , … , m ⁡ { f ( x i ( k + 1 ) ) } {\\displaystyle \\displaystyle i_{\\text{b}}=\\mathop {\\text{argmin}} _{i=1,\\ldots ,m}\\{f(x_{i}(k+1))\\}} .\n5) Set k : = k + 1 {\\displaystyle k:=k+1} . If k = k max {\\displaystyle k=k_{\\max }} is satisfied then terminate and output x ⋆ ( k ) {\\displaystyle x^{\\star }(k)} . Otherwise, return to Step 2). Setting [ edit ] The search performance depends on setting the composite rotation matrix R ( θ ) {\\displaystyle R(\\theta )} , the step rate r ( k ) {\\displaystyle r(k)} , and the initial points x i ( 0 ) ( i = 1 , … , m ) {\\displaystyle x_{i}(0)~(i=1,\\ldots ,m)} . The following settings are new and effective.",
    "source_url": "https://en.wikipedia.org/wiki/Spiral_optimization_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:16.546262",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:16.546262",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:16.546262",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Spiral_optimization_algorithm_1_1749015256577_1588",
    "text": "The following settings are new and effective. Setting 1 (Periodic Descent Direction Setting) [ edit ] This setting is an effective setting for high dimensional problems under the maximum iteration k max {\\displaystyle k_{\\max }} . The conditions on R ( θ ) {\\displaystyle R(\\theta )} and x i ( 0 ) ( i = 1 , … , m ) {\\displaystyle x_{i}(0)~(i=1,\\ldots ,m)} together ensure that the spiral models generate descent directions periodically. The condition of r ( k ) {\\displaystyle r(k)} works to utilize the periodic descent directions under the search termination k max {\\displaystyle k_{\\max }} . Set R ( θ ) {\\displaystyle R(\\theta )} as follows: R ( θ ) = [ 0 n − 1 ⊤ − 1 I n − 1 0 n − 1 ] {\\displaystyle R(\\theta ) ={\\begin{bmatrix}0_{n-1}^{\\top }&-1\\\\I_{n-1}&0_{n-1}\\\\\\end{bmatrix}}} where I n − 1 {\\displaystyle I_{n-1}} is the ( n − 1 ) × ( n − 1 ) {\\displaystyle (n-1)\\times (n-1)} identity matrix and 0 n − 1 {\\displaystyle 0_{n-1}} is the ( n − 1 )",
    "source_url": "https://en.wikipedia.org/wiki/Spiral_optimization_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:16.577264",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:16.577264",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:16.577264",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Spiral_optimization_algorithm_1_1749015256606_9461",
    "text": "× 1 {\\displaystyle (n-1)\\times 1} zero vector. Place the initial points x i ( 0 ) ∈ R n {\\displaystyle x_{i}(0)\\in \\mathbb {R} ^{n}} ( i = 1 , … , m ) {\\displaystyle (i=1,\\ldots ,m)} at random to satisfy the following condition: min i = 1 , … , m { max j = 1 , … , m { rank [ d j , i ( 0 ) R ( θ ) d j , i ( 0 ) ⋯ R ( θ ) 2 n − 1 d j , i ( 0 ) ] } } = n {\\displaystyle \\min _{i=1,\\ldots ,m}\\{\\max _{j=1,\\ldots ,m}{\\bigl \\{}{\\text{rank}}{\\bigl [}d_{j,i}(0)~R(\\theta )d_{j,i}(0)~~\\cdots ~~R(\\theta )^{2n-1}d_{j,i}(0){\\bigr ]}{\\bigr \\}}{\\bigr \\}}=n} where d j , i ( 0 ) = x j ( 0 ) − x i ( 0 ) {\\displaystyle d_{j,i}(0)=x_{j}(0)-x_{i}(0)} . Note that this condition is almost all satisfied by a random placing and thus no check is actually fine.",
    "source_url": "https://en.wikipedia.org/wiki/Spiral_optimization_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:16.606773",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:16.606773",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:16.606773",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Spiral_optimization_algorithm&oldid=1292688910_1_1749015257713_5279",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 08:21, 28 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 08:21, 28 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Opti",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Spiral_optimization_algorithm&oldid=1292688910",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:17.713543",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:17.713543",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:17.713543",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bisection_algorithm_1_1749015266680_4266",
    "text": "The method [ edit ] The method is applicable for numerically solving the equation f ( x ) = 0 {\\displaystyle f(x)=0} for the real variable x {\\displaystyle x} , where f {\\displaystyle f} is a continuous function defined on an interval [ a , b ] {\\displaystyle [a,b]} and where f ( a ) {\\displaystyle f(a)} and f ( b ) {\\displaystyle f(b)} have opposite signs. In this case a {\\displaystyle a} and b {\\displaystyle b} are said to bracket a root since, by the intermediate value theorem , the continuous function f {\\displaystyle f} must have at least one root in the interval ( a , b ) {\\displaystyle (a,b)} . At each step the method divides the interval in two parts/halves by computing the midpoint c = ( a + b ) / 2 {\\displaystyle c=(a+b)/2} of the interval and the value of the function f ( c ) {\\displaystyle f(c)} at that point. If c {\\displaystyle c} itself is a root then the process has succeeded and stops.",
    "source_url": "https://en.wikipedia.org/wiki/Bisection_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:26.680373",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:26.680373",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:26.680373",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bisection_algorithm_1_1749015266707_3753",
    "text": "If c {\\displaystyle c} itself is a root then the process has succeeded and stops. Otherwise, there are now only two possibilities: either f ( a ) {\\displaystyle f(a)} and f ( c ) {\\displaystyle f(c)} have opposite signs and bracket a root, or f ( c ) {\\displaystyle f(c)} and f ( b ) {\\displaystyle f(b)} have opposite signs and bracket a root. [ 5 ] The method selects the subinterval that is guaranteed to be a bracket as the new interval to be used in the next step. In this way an interval that contains a zero of f {\\displaystyle f} is reduced in width by 50% at each step. The process is continued until the interval is sufficiently small. Explicitly, if f ( c ) = 0 {\\displaystyle f(c)=0} then c {\\displaystyle c} may be taken as the solution and the process stops.",
    "source_url": "https://en.wikipedia.org/wiki/Bisection_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:26.707970",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:26.707970",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:26.707970",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bisection_algorithm_1_1749015266736_5342",
    "text": "Otherwise, if f ( a ) {\\displaystyle f(a)} and f ( c ) {\\displaystyle f(c)} have opposite signs, then the method sets c {\\displaystyle c} as the new value for b {\\displaystyle b} , and if f ( b ) {\\displaystyle f(b)} and f ( c ) {\\displaystyle f(c)} have opposite signs then the method sets c {\\displaystyle c} as the new a {\\displaystyle a} . In both cases, the new f ( a ) {\\displaystyle f(a)} and f ( b ) {\\displaystyle f(b)} have opposite signs, so the method is applicable to this smaller interval. [ 6 ] Stopping condition [ edit ] The input for the method is a continuous function f {\\displaystyle f} , an interval [ a , b ] {\\displaystyle [a,b]} , and the function values f ( a ) {\\displaystyle f(a)} and f ( b ) {\\displaystyle f(b)} . The function values are of opposite sign (there is at least one zero crossing within the interval).",
    "source_url": "https://en.wikipedia.org/wiki/Bisection_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:26.736946",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:26.736946",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:26.736946",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bisection_algorithm_1_1749015266769_4318",
    "text": "The function values are of opposite sign (there is at least one zero crossing within the interval). Each iteration performs these steps: Calculate c {\\displaystyle c} , the midpoint of the interval, : c = { a + b 2 , if a × b ≤ 0 a + b − a 2 , if a × b > 0 {\\displaystyle \\qquad c={\\begin{cases}{\\tfrac {a+b}{2}},&{\\text{if }}a\\times b\\leq 0\\\\\\,a+{\\tfrac {b-a}{2}},&{\\text{if }}a\\times b>0\\end{cases}}} Calculate the function value at the midpoint, f ( c ) {\\displaystyle f(c)} . If convergence is satisfactory (see below), return c {\\displaystyle c} and stop iterating. Examine the sign of f ( c ) {\\displaystyle f(c)} and replace either ( a , f ( a ) ) {\\displaystyle (a,f(a))} or ( b , f ( b ) ) {\\displaystyle (b,f(b))} with ( c , f ( c ) ) {\\displaystyle (c,f(c))} so that there is a zero crossing within the new interval. In order to determine when the iteration should stop, it is necessary to consider what is meant by the concept of 'tolerance' ( ϵ {\\displaystyle \\epsilon } ).",
    "source_url": "https://en.wikipedia.org/wiki/Bisection_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:26.769946",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:26.769946",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:26.769946",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bisection_algorithm_1_1749015266802_4854",
    "text": "Burden & Faires [ 7 ] state: \"we can select a tolerance ϵ > 0 { \\displaystyle \\epsilon >0} and generate c 1 , ..., c N until one of the following conditions is met: | c N − c N − 1 | < ϵ , {\\displaystyle |c_{N}-c_{N-1}|<\\epsilon ,} (2.1) | c N − c N − 1 c N | < ϵ , {\\displaystyle \\left|{\\frac {c_{N}-c_{N-1}}{c_{N}}}\\right|<\\epsilon ,} c N ≠ 0 , {\\displaystyle c_{N}\\neq 0,} or (2.2) | f ( c N ) | < ϵ . {\\displaystyle |f(c_{N})|<\\epsilon .} (2.3) Unfortunately, difficulties can arise using any of these stopping criteria ... Without additional knowledge about f {\\displaystyle f} or c {\\displaystyle c} , inequality (2.2) is the best stopping criterion to apply because it comes closest to  testing relative  error. \"\n(Note: c {\\displaystyle c} has been used here as it is more common than Burden and Faire's ′ p ′ {\\displaystyle 'p'} .) The objective is to find an approximation, within the tolerance, to the root. It can be seen that (2.3) | f ( c N )",
    "source_url": "https://en.wikipedia.org/wiki/Bisection_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:26.802990",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:26.802990",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:26.802990",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bisection_algorithm_1_1749015266840_6634",
    "text": "It can be seen that (2.3) | f ( c N ) | < ϵ {\\displaystyle |f(c_{N})|<\\epsilon } does not give such an approximation unless the slope of the function at c N {\\displaystyle c_{N}} is in the neighborhood of ± 1 {\\displaystyle \\pm 1} . Suppose, for the purpose of illustration,  the tolerance ϵ = 5 × 10 − 7 {\\displaystyle \\epsilon =5\\times 10^{-7}} . Then, for a function such as f ( x ) = 10 − m ∗ ( x − 1 ) {\\displaystyle f(x)=10^{-m}*(x-1)} , | f ( c ) | = 10 − m | x − 1 | < 5 × 10 − 7 {\\displaystyle |f(c)|=10^{-m}|x-1|<5\\times 10^{-7}} so | x − 1 | < 5 × 10 m − 7 {\\displaystyle |x-1|<5\\times 10^{m-7}} This means that any number x in [ 1 − 5 × 10 m − 7 , 1 + 5 × 10 m − 7 ] {\\displaystyle [1-5\\times 10^{m-7},1+5\\times 10^{m-7}]} would be a 'good' approximation to the root. If m = 10 {\\displaystyle m=10} ,\nthe approximation to the root 1 would be in [ 1 − 5000 , 1 + 5000 ] = [ − 4999 , 5001 ] {\\displaystyle [1-5000,1+5000]=[-4999,5001]} . -- a very poor result.",
    "source_url": "https://en.wikipedia.org/wiki/Bisection_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:26.840018",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:26.840018",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:26.840018",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bisection_algorithm_1_1749015266857_9694",
    "text": "-- a very poor result. As (2.3) does not appear to give acceptable results, (2.1) and (2.2) need to be evaluated. The following Python script compares the behavior for those two stopping conditions. def bisect(f, a, b, tolerance):\n    fa = f(a)\n    fb = f(b)\n    i = 0\n    stop_a = []\n    stop_r = []\n    while True:\n        i += 1\n        c = a + (b - a) / 2\n        fc = f(c)",
    "source_url": "https://en.wikipedia.org/wiki/Bisection_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:26.857018",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:26.857018",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:26.857018",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bisection_algorithm_1_1749015266896_3111",
    "text": "if c < 10:  # For small root\n            if not stop_a:\n                print('{:3d} {:18.16f} {:18.16f} {:18.16e} | {:5.2e} {:5.2e}'\n                      .format(i, a, b, c, b - a, (b - a) / c))\n            else:  # large root\n                print('{:3d} {:18.16f} {:18.16f} {:18.16e} |  -----   {:5.2e}'\n                      .format(i, a, b, c, b - a))\n        else:\n            if not stop_r:\n                print('{:3d} {:18.7f} {:18.7f} {:18.7e} | {:5.2e} {:5.2e}'\n                      .format(i, a, b, c, b - a, (b - a) / c))\n            else:\n                print('{:3d} {:18.7f} {:18.7f} {:18.7e} | {:5.2e}  ----- '\n                      .format(i, a, b, c, b - a)) if fc == 0:\n            return [c, i]\n        if (b - a <= abs(c) * tolerance) & (stop_r == []):\n            stop_r = [c, i]\n        if (b - a <= tolerance) & (stop_a == []):\n            stop_a = [c, i]\n        if np.sign(fa)",
    "source_url": "https://en.wikipedia.org/wiki/Bisection_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:26.896030",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:26.896030",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:26.896030",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bisection_algorithm_1_1749015266921_7586",
    "text": "== np.sign(fc):\n            a = c\n            fa = fc\n        else:\n            b = c\n            fb = fc\n        if (stop_r ! = []) & (stop_a ! = []):\n            return [stop_a, stop_r] The first function to be tested is one with a small root i.e. f ( x ) = x − 0.00000000123456789 {\\displaystyle f(x)=x-0.00000000123456789} print(' i          a                   b                  c               b - a    (b - a)/c') f = lambda x: x - 0.00000000123456789\nres = bisect(f, 0, 1, 5e-7)\nprint('In {:2d} steps the absolute error case gives {:20.18F}'.format(res[0][1], res[0][0]))\nprint('In {:2d} steps the relative error case gives {:20.18F}'.format(res[1][1], res[1][0]))\nprint('                 as the approximation to  0.00000000123456789')",
    "source_url": "https://en.wikipedia.org/wiki/Bisection_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:26.921664",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:26.921664",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:26.921664",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Graph_exploration_algorithm&oldid=186156294_1_1749015280865_4788",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Ott2 ( talk | contribs ) at 18:07, 22 January 2008 (redirect to equivalent page) . The present address (URL) is a permanent link to this version. Revision as of 18:07, 22 January 2008 by Ott2 ( talk | contribs ) (redirect to equivalent page) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Redirect to: Graph traversal Retrieved from \" https://en.wikipedia.o",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Graph_exploration_algorithm&oldid=186156294",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:40.865837",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:40.865837",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:40.865837",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Cheney%27s_algorithm_1_1749015281925_8003",
    "text": "Object references on the stack are checked. One of the two following actions is taken for each object reference that points to an object in from-space: If the object has not yet been moved to the to-space, this is done by creating an identical copy in the to-space, and then replacing the from-space version with a forwarding pointer to the to-space copy. Then update the object reference to refer to the new version in to-space. If the object has already been moved to the to-space, simply update the reference from the forwarding pointer in from-space. Objects in the to-space. The garbage collector examines all object references in the objects that have been migrated to the to-space , and performs one of the above two actions on the referenced objects. Once all to-space references have been examined and updated, garbage collection is complete.",
    "source_url": "https://en.wikipedia.org/wiki/Cheney%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:41.925047",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:41.925047",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:41.925047",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Cuthill%E2%80%93McKee_algorithm_1_1749015284139_8242",
    "text": "i {\\displaystyle R_{i}} (with R i {\\displaystyle R_{i}} the i -th component of R {\\displaystyle R} ) and exclude the vertices we already have in R {\\displaystyle R} A i := Adj ⁡ ( R i ) ∖ R {\\displaystyle A_{i}:=\\operatorname {Adj} (R_{i})\\setminus R} Sort A i {\\displaystyle A_{i}} ascending by minimum predecessor (the already-visited neighbor with the earliest position in R), and as a tiebreak ascending by vertex degree . [ 4 ] Append A i {\\displaystyle A_{i}} to the Result set R {\\displaystyle R} . In other words, number the vertices according to a particular level structure (computed by breadth-first search ) where the vertices in each level are visited in order of their predecessor's numbering from lowest to highest. Where the predecessors are the same, vertices are distinguished by degree (again ordered from lowest to highest). See also [ edit ] Graph bandwidth Sparse matrix References [ edit ] ^ E. Cuthill and J. McKee. Reducing the bandwidth of sparse symmetric matrices In Proc.",
    "source_url": "https://en.wikipedia.org/wiki/Cuthill%E2%80%93McKee_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:44.139573",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:44.139573",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:44.139573",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Maze_generation_algorithm_1_1749015286379_9311",
    "text": "This can be described with a following recursive routine: Given a current cell as a parameter Mark the current cell as visited While the current cell has any unvisited neighbour cells Choose one of the unvisited neighbours Remove the wall between the current cell and the chosen cell Invoke the routine recursively for the chosen cell which is invoked once for any initial cell in the area. Iterative implementation (with stack) [ edit ] A disadvantage of the first approach is a large depth of recursion – in the worst case, the routine may need to recur on every cell of the area being processed, which may exceed the maximum recursion stack depth in many environments. As a solution, the same backtracking method can be implemented with an explicit stack , which is usually allowed to grow much bigger with no harm.",
    "source_url": "https://en.wikipedia.org/wiki/Maze_generation_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:46.379514",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:46.380514",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:46.380514",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Disparity_filter_algorithm_of_weighted_network_1_1749015291141_3319",
    "text": "Jump to content From Wikipedia, the free encyclopedia Part of a series on Network science Theory Graph Complex network Contagion Small-world Scale-free Community structure Percolation Evolution Controllability Graph drawing Social capital Link analysis Optimization Reciprocity Closure Homophily Transitivity Preferential attachment Balance theory Network effect Social influence Network types Informational (computing) Telecommunication Transport Social Scientific collaboration Biological Artificia",
    "source_url": "https://en.wikipedia.org/wiki/Disparity_filter_algorithm_of_weighted_network",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:51.141788",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:51.141788",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:51.141788",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Tree_traversal_1_1749015296524_1814",
    "text": "However, pre-order with post-order leaves some ambiguity in the tree structure. [ 6 ] There are three methods at which position of the traversal relative to the node (in the figure: red, green, or blue) the visit of the node shall take place. The choice of exactly one color determines exactly one visit of a node as described below. Visit at all three colors results in a threefold visit of the same node yielding the “all-order” sequentialisation: F - B - A - A - A - B - D - C - C - C - D - E - E - E - D - B - F - G - G - I - H - H - H - I - I - G - F Pre-order, NLR [ edit ] Visit the current node (in the figure: position red). Recursively traverse the current node's left subtree. Recursively traverse the current node's right subtree. The pre-order traversal is a topologically sorted one, because a parent node is processed before any of its child nodes is done. Post-order, LRN [ edit ] Recursively traverse the current node's left subtree.",
    "source_url": "https://en.wikipedia.org/wiki/Tree_traversal",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:56.524666",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:56.524666",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:56.524666",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Tree_traversal_1_1749015296714_2293",
    "text": "Several alternative implementations are also mentioned. Pre-order implementation [ edit ] procedure preorder(node) if node = null return visit(node)\n    preorder(node.left)\n    preorder(node.right) procedure iterativePreorder(node) if node = null return stack ← empty stack stack.push(node) while not stack.isEmpty()\n        node ← stack.pop()\n        visit(node)\n        // right child is pushed first so that left is processed first if node.right ≠ null stack.push(node.right) if node.left ≠ null stack.push(node.left) Post-order implementation [ edit ] procedure postorder(node)",
    "source_url": "https://en.wikipedia.org/wiki/Tree_traversal",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:56.714083",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:56.714083",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:56.714083",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimax_1_1749015299441_8189",
    "text": "Jump to content From Wikipedia, the free encyclopedia Decision rule used for minimizing the possible loss for a worst case scenario This article is about the decision theory concept. For other uses, see Minimax (disambiguation) . For company, see MiniMax (company) . Minimax (sometimes Minmax , MM [ 1 ] or saddle point [ 2 ] ) is a decision rule used in artificial intelligence , decision theory , combinatorial game theory , statistics , and philosophy for minimizing the possible loss for a worst case ( max imum loss) scenario . When dealing with gains, it is referred to as \"maximin\" – to maximize the minimum gain. Originally formulated for several-player zero-sum game theory , covering both the cases where players take alternate moves and those where they make simultaneous moves, it has also been extended to more complex games and to general decision-making in the presence of uncertainty.",
    "source_url": "https://en.wikipedia.org/wiki/Minimax",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:59.441916",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:59.441916",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:59.441916",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimax_1_1749015299466_4304",
    "text": "Game theory [ edit ] In general games [ edit ] The maximin value is the highest value that the player can be sure to get without knowing the actions of the other players; equivalently, it is the lowest value the other players can force the player to receive when they know the player's action. Its formal definition is: [ 3 ] v i _ = max a i min a − i v i ( a i , a − i ) {\\displaystyle {\\underline {v_{i}}}=\\max _{a_{i}}\\min _{a_{-i}}{v_{i}(a_{i},a_{-i})}} Where: i is the index of the player of interest. − i {\\displaystyle -i} denotes all other players except player i . a i {\\displaystyle a_{i}} is the action taken by player i . a − i {\\displaystyle a_{-i}} denotes the actions taken by all other players. v i {\\displaystyle v_{i}} is the value function of player i .",
    "source_url": "https://en.wikipedia.org/wiki/Minimax",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:59.467916",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:59.467916",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:59.467916",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimax_1_1749015299490_9253",
    "text": "v i {\\displaystyle v_{i}} is the value function of player i . Calculating the maximin value of a player is done in a worst-case approach: for each possible action of the player, we check all possible actions of the other players and determine the worst possible combination of actions – the one that gives player i the smallest value. Then, we determine which action player i can take in order to make sure that this smallest value is the highest possible. For example, consider the following game for two players, where the first player (\"row player\") may choose any of three moves, labelled T , M , or B , and the second player (\"column player\") may choose either of two moves, L or R .",
    "source_url": "https://en.wikipedia.org/wiki/Minimax",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:59.490921",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:59.490921",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:59.490921",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimax_1_1749015299521_2606",
    "text": "The result of the combination of both moves is expressed in a payoff table: L R T 3 , 1 2 , − 20 M 5 , 0 − 10 , 1 B − 100 , 2 4 , 4 {\\displaystyle {\\begin{array}{c|cc}\\hline &L&R\\\\\\hline T&3,1&2,-20\\\\M&5,0&-10,1\\\\B&-100,2&4,4\\\\\\hline \\end{array}}} (where the first number in each of the cell is the pay-out of the row player and the second number is the pay-out of the column player). For the sake of example, we consider only pure strategies . Check each player in turn: The row player can play T , which guarantees them a payoff of at least 2 (playing B is risky since it can lead to payoff −100 , and playing M can result in a payoff of −10 ). Hence: v r o w _ = 2 {\\displaystyle {\\underline {v_{row}}}=2} . The column player can play L and secure a payoff of at least 0 (playing R puts them in the risk of getting − 20 {\\displaystyle -20} ). Hence: v c o l _ = 0 {\\displaystyle {\\underline {v_{col}}}=0} .",
    "source_url": "https://en.wikipedia.org/wiki/Minimax",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:59.521647",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:59.521647",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:59.521647",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimax_1_1749015299554_1634",
    "text": "Hence: v c o l _ = 0 {\\displaystyle {\\underline {v_{col}}}=0} . If both players play their respective maximin strategies ( T , L ) {\\displaystyle (T,L)} , the payoff vector is ( 3 , 1 ) {\\displaystyle (3,1)} . The minimax value of a player is the smallest value that the other players can force the player to receive, without knowing the player's actions; equivalently, it is the largest value the player can be sure to get when they know the actions of the other players. Its formal definition is: [ 3 ] v i ¯ = min a − i max a i v i ( a i , a − i ) {\\displaystyle {\\overline {v_{i}}}=\\min _{a_{-i}}\\max _{a_{i}}{v_{i}(a_{i},a_{-i})}} The definition is very similar to that of the maximin value – only the order of the maximum and minimum operators is inverse. In the above example: The row player can get a maximum value of 4 (if the other player plays R ) or 5 (if the other player plays L ), so: v r o w ¯ = 4 . {\\displaystyle {\\overline {v_{row}}}=4\\ .}",
    "source_url": "https://en.wikipedia.org/wiki/Minimax",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:59.554153",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:59.554153",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:59.554153",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimax_1_1749015299582_3664",
    "text": "{\\displaystyle {\\overline {v_{row}}}=4\\ .} The column player can get a maximum value of 1 (if the other player plays T ), 1 (if M ) or 4 (if B ). Hence: v c o l ¯ = 1 . {\\displaystyle {\\overline {v_{col}}}=1\\ .} For every player i , the maximin is at most the minimax: v i _ ≤ v i ¯ {\\displaystyle {\\underline {v_{i}}}\\leq {\\overline {v_{i}}}} Intuitively, in maximin the maximization comes after the minimization, so player i tries to maximize their value before knowing what the others will do; in minimax the maximization comes before the minimization, so player i is in a much better position – they maximize their value knowing what the others did. Another way to understand the notation is by reading from right to left: When we write v i ¯ = min a − i max a i v i ( a i , a − i ) = min a −",
    "source_url": "https://en.wikipedia.org/wiki/Minimax",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:59.582152",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:59.582152",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:59.582152",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimax_1_1749015299614_4132",
    "text": "i ¯ = min a − i max a i v i ( a i , a − i ) = min a − i ( max a i v i ( a i , a − i ) ) {\\displaystyle {\\overline {v_{i}}}=\\min _{a_{-i}}\\max _{a_{i}}{v_{i}(a_{i},a_{-i})}=\\min _{a_{-i}}{\\Big (}\\max _{a_{i}}{v_{i}(a_{i},a_{-i})}{\\Big )}} the initial set of outcomes v i ( a i , a − i ) {\\displaystyle \\ v_{i}(a_{i},a_{-i})\\ } depends on both a i {\\displaystyle \\ {a_{i}}\\ } and a − i . {\\displaystyle \\ {a_{-i}}\\ .} We first marginalize away a i {\\displaystyle {a_{i}}} from v i ( a i , a − i ) {\\displaystyle v_{i}(a_{i},a_{-i})} , by maximizing over a i {\\displaystyle \\ {a_{i}}\\ } (for every possible value of a − i {\\displaystyle {a_{-i}}} ) to yield a set of marginal outcomes v i ′ ( a − i ) , {\\displaystyle \\ v'_{i}(a_{-i})\\,,} which depends only on a − i . {\\displaystyle \\ {a_{-i}}\\ .} We then minimize over a − i {\\displaystyle \\ {a_{-i}}\\ } over these outcomes. (Conversely for maximin.)",
    "source_url": "https://en.wikipedia.org/wiki/Minimax",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:59.614155",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:59.615603",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:59.615603",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimax_1_1749015299645_6607",
    "text": "(Conversely for maximin.) Although it is always the case that v r o w _ ≤ v r o w ¯ {\\displaystyle \\ {\\underline {v_{row}}}\\leq {\\overline {v_{row}}}\\ } and v c o l _ ≤ v c o l ¯ , {\\displaystyle \\ {\\underline {v_{col}}}\\leq {\\overline {v_{col}}}\\,,} the payoff vector resulting from both players playing their minimax strategies, ( 2 , − 20 ) {\\displaystyle \\ (2,-20)\\ } in the case of ( T , R ) {\\displaystyle \\ (T,R)\\ } or ( − 10 , 1 ) {\\displaystyle (-10,1)} in the case of ( M , R ) , {\\displaystyle \\ (M,R)\\,,} cannot similarly be ranked against the payoff vector ( 3 , 1 ) {\\displaystyle \\ (3,1)\\ } resulting from both players playing their maximin strategy. In zero-sum games [ edit ] In two-player zero-sum games , the minimax solution is the same as the Nash equilibrium . In the context of zero-sum games, the minimax theorem is equivalent to: [ 4 ] [ failed verification ]",
    "source_url": "https://en.wikipedia.org/wiki/Minimax",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:59.645532",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:59.646533",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:59.646533",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimax_1_1749015299676_5294",
    "text": "For every two-person zero-sum game with finitely many strategies, there exists a value V and a mixed strategy for each player, such that (a) Given Player 2's strategy, the best payoff possible for Player 1 is V , and (b) Given Player 1's strategy, the best payoff possible for Player 2 is − V . Equivalently, Player 1's strategy guarantees them a payoff of V regardless of Player 2's strategy, and similarly Player 2 can guarantee themselves a payoff of − V . The name minimax arises because each player minimizes the maximum payoff possible for the other – since the game is zero-sum, they also minimize their own maximum loss (i.e., maximize their minimum payoff). See also example of a game without a value . Example [ edit ] Payoff matrix for player A B chooses B1 B chooses B2 B chooses B3 A chooses A1 +3 −2 +2 A chooses A2 −1 + 0 +4 A chooses A3 −4 −3 +1 The following example of a zero-sum game, where A and B make simultaneous moves, illustrates maximin solutions.",
    "source_url": "https://en.wikipedia.org/wiki/Minimax",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:34:59.676536",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:34:59.676536",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:34:59.676536",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimax_1_1749015300107_4318",
    "text": "Suppose each player has three choices and consider the payoff matrix for A displayed on the table (\"Payoff matrix for player A\"). Assume the payoff matrix for B is the same matrix with the signs reversed (i.e., if the choices are A1 and B1 then B pays 3 to A ). Then, the maximin choice for A is A2 since the worst possible result is then having to pay 1, while the simple maximin choice for B is B2 since the worst possible result is then no payment. However, this solution is not stable, since if B believes A will choose A2 then B will choose B1 to gain 1; then if A believes B will choose B1 then A will choose A1 to gain 3; and then B will choose B2; and eventually both players will realize the difficulty of making a choice. So a more stable strategy is needed.",
    "source_url": "https://en.wikipedia.org/wiki/Minimax",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:00.107789",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:00.108789",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:00.108789",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimax_1_1749015300144_1833",
    "text": "So a more stable strategy is needed. Some choices are dominated by others and can be eliminated: A will not choose A3 since either A1 or A2 will produce a better result, no matter what B chooses; B will not choose B3 since some mixtures of B1 and B2 will produce a better result, no matter what A chooses. Player A can avoid having to make an expected payment of more than ⁠ 1 / 3 ⁠ by choosing A1 with probability ⁠ 1 / 6 ⁠ and A2 with probability ⁠ 5 / 6 ⁠ : The expected payoff for A would be 3 × ⁠ 1 / 6 ⁠ − 1 × ⁠ 5 / 6 ⁠ = ⁠− + 1 / 3 ⁠ in case B chose B1 and −2 × ⁠ 1 / 6 ⁠ + 0 × ⁠ 5 / 6 ⁠ = ⁠− + 1 / 3 ⁠ in case B chose B2. Similarly, B can ensure an expected gain of at least ⁠ 1 / 3 ⁠ , no matter what A chooses, by using a randomized strategy of choosing B1 with probability ⁠ 1 / 3 ⁠ and B2 with probability ⁠ 2 / 3 ⁠ . These mixed minimax strategies cannot be improved and are now stable. Maximin [ edit ] Frequently, in game theory, maximin is distinct from minimax.",
    "source_url": "https://en.wikipedia.org/wiki/Minimax",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:00.144005",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:00.144005",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:00.144005",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=String-searching_algorithm&oldid=1287073283_1_1749015306725_8252",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OatPowered ( talk | contribs ) at 20:41, 23 April 2025 ( → Classification by the use of preprocessing programs : Fix VLDB cite, update URL, add all authors and wikilink) . The present address (URL) is a permanent link to this version. Revision as of 20:41, 23 April 2025 by OatPowered ( talk | contribs ) ( → Classification by the use of preprocessing programs : Fix VLDB cite, update URL, ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=String-searching_algorithm&oldid=1287073283",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:06.725020",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:06.726260",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:06.726260",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schreier%E2%80%93Sims_algorithm_1_1749015314006_1842",
    "text": "Its goal is not to compile. struct Group { uint stabPoint ; // An index into the base for the point stabilized by this group's subgroup. OrbitTree orbitTree ; // A tree to keep track of the orbit in our group of the point stabilized by our subgroup. TransversalSet transversalSet ; // A set of coset representatives of this group's subgroup. GeneratorSet generatorSet ; // A set of permutations generating this group. Group * subGroup ; // A pointer to this group's subgroup, or null to mean the trivial group. Group ( uint stabPoint ) { this -> stabPoint = stabPoint ; subGroup = nullptr ; } }; // The given set of generators need not be a strong generating set. It just needs to generate the group at the root of the chain.",
    "source_url": "https://en.wikipedia.org/wiki/Schreier%E2%80%93Sims_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:14.006286",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:14.006286",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:14.006286",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schreier%E2%80%93Sims_algorithm_1_1749015314033_8964",
    "text": "It just needs to generate the group at the root of the chain. Group * MakeStabChain ( const GeneratorSet & generatorSet , uint * base ) { Group * group = new Group ( 0 ); for ( generator in generatorSet ) group -> Extend ( generator , base ); return group ; } // Extend the stabilizer chain rooted at this group with the given generator. void Group::Extend ( const Permutation & generator , uint * base ) { // This is the major optimization of Schreier-Sims. Weed out redundant Schreier generators. if ( IsMember ( generator )) return ; // Our group just got bigger, but the stabilizer chain rooted at our subgroup is still the same. generatorSet . Add ( generator ); // Explore all new orbits we can reach with the addition of the new generator. // Note that if the tree was empty to begin with, the identity must be returned // in the set to satisfy a condition of Schreier's lemma. newTerritorySet = orbitTree .",
    "source_url": "https://en.wikipedia.org/wiki/Schreier%E2%80%93Sims_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:14.033477",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:14.033477",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:14.033477",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schreier%E2%80%93Sims_algorithm_1_1749015314060_2988",
    "text": "newTerritorySet = orbitTree . Grow ( generator , base ); // By the orbit-stabilizer theorem, the permutations in the returned set are // coset representatives of the cosets of our subgroup. for ( permutation in newTerritorySet ) transversalSet . Add ( permutation ); // We now apply Schreier's lemma to find new generators for our subgroup. // Some iterations of this loop are redundant, but we ignore that for simplicity. for ( cosetRepresentative in transversalSet ) { for ( generator in generatorSet ) { schreierGenerator = CalcSchreierGenerator ( cosetRepresentative , generator ); if ( schreierGenerator . IsIdentity ()) continue ; if ( ! subGroup ) subGroup = new Group ( stabPoint + 1 ); subGroup -> Extend ( schreierGenerator , base ); } } } Notable details left out here include the growing of the orbit tree and the calculation of each new Schreier generator. In place of the orbit tree, a Schreier vector can be used, but the idea is essentially the same.",
    "source_url": "https://en.wikipedia.org/wiki/Schreier%E2%80%93Sims_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:14.060986",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:14.060986",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:14.060986",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schreier%E2%80%93Sims_algorithm_1_1749015314086_8666",
    "text": "In place of the orbit tree, a Schreier vector can be used, but the idea is essentially the same. The tree is rooted at the identity element, which fixes the point stabilized by the subgroup. Each node of the tree can represent a permutation that, when combined with all permutations in the path from the root to it, takes that point to some new point not visited by any other node of the tree. By the orbit-stabilizer theorem , these form a transversal of the subgroup of our group that stabilizes the point whose entire orbit is maintained by the tree. Calculating a Schreier generator is a simple application of the Schreier's subgroup lemma . Another detail left out is the membership test. This test is based upon the sifting process. A permutation is sifted down the chain at each step by finding the containing coset, then using that coset's representative to find a permutation in the subgroup, and the process is repeated in the subgroup with that found permutation.",
    "source_url": "https://en.wikipedia.org/wiki/Schreier%E2%80%93Sims_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:14.086996",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:14.086996",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:14.086996",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Las_Vegas_algorithm&oldid=1279352417_1_1749015318809_1731",
    "text": "Execute Quicksort on A[1 to i-1] and A[i+1 to n]. Combine the responses in order to obtain a sorted array.\" \"\" A simple example is randomized quicksort , where the pivot is chosen randomly, and divides the elements into three partitions: elements less than pivot, elements equal to pivot, and elements greater than pivot. QuickSort always generates the solution, which in this case the sorted array. Unfortunately, the time complexity is not that obvious. It turns out that the runtime depends on which element we pick as a pivot. The worst case Θ( n 2 ) when the pivot is the smallest or the largest element. T ( n ) = T ( 0 ) + T ( n − 1 ) + Θ ( n ) {\\displaystyle T(n)=T(0)+T(n-1)+\\Theta (n)} T ( n ) = Θ ( 1 ) + T ( n − 1 ) + Θ ( n ) {\\displaystyle T(n)=\\Theta (1)+T(n-1)+\\Theta (n)} T ( n ) = T ( n − 1 ) + Θ ( n ) {\\displaystyle T(n)=T(n-1)+\\Theta (n)} T ( n ) = Θ ( n 2 ) {\\displaystyle T(n)=\\Theta (n^{2})}",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Las_Vegas_algorithm&oldid=1279352417",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:18.809043",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:18.809043",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:18.809043",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Selection_(genetic_algorithm)_1_1749015321358_9050",
    "text": "Methods of selection [ edit ] The listed methods differ mainly in the selection pressure, [ 2 ] [ 3 ] which can be set by a strategy parameter in the rank selection described below. The higher the selection pressure, the faster a population converges against a certain solution and the search space may not be explored sufficiently. This premature convergence [ 4 ] can be counteracted by structuring the population appropriately. [ 5 ] [ 6 ] There is a close correlation between the population model used and a suitable selection pressure. [ 5 ] If the pressure is too low, it must be expected that the population will not converge even after a long computing time. For more selection methods and further detail see. [ 7 ] [ 8 ] Roulette wheel selection [ edit ] In the roulette wheel selection , the probability of choosing an individual for breeding of the next generation is proportional to its fitness, the better the fitness is, the higher chance for that individual to be chosen.",
    "source_url": "https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:21.358665",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:21.359666",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:21.359666",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Selection_(genetic_algorithm)_1_1749015321387_3414",
    "text": "Choosing individuals can be depicted as spinning a roulette that has as many pockets as there are individuals in the current generation, with sizes depending on their probability. Probability of choosing individual i {\\displaystyle i} is equal to p i = f i Σ j = 1 N f j {\\displaystyle p_{i}={\\frac {f_{i}}{\\Sigma _{j=1}^{N}f_{j}}}} , where f i {\\displaystyle f_{i}} is the fitness of i {\\displaystyle i} and N {\\displaystyle N} is the size of current generation (note that in this method one individual can be drawn multiple times). Stochastic universal sampling [ edit ] Stochastic universal sampling is a development of roulette wheel selection with minimal spread and no bias. Rank selection [ edit ] In rank selection, the probability for selection does not depend directly on the fitness, but on the fitness rank of an individual within the population. [ 9 ] The exact fitness values themselves do not have to be available, but only a sorting of the individuals according to quality.",
    "source_url": "https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:21.387665",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:21.387665",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:21.387665",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Selection_(genetic_algorithm)_1_1749015321419_8129",
    "text": "In addition to the adjustable selection pressure, an advantage of rank-based selection can be seen in the fact that it also gives worse individuals a chance to reproduce and thus to improve. [ 10 ] This can be particularly helpful in applications with restrictions, since it facilitates the overcoming of a restriction in several intermediate steps, i.e. via a sequence of several individuals rated poorly due to restriction violations. Linear rank selection [ edit ] Linear ranking, which goes back to Baker, [ 11 ] [ 12 ] is often used. [ 5 ] [ 10 ] [ 13 ] It allows the selection pressure to be set by the parameter s p {\\displaystyle sp} , which can take values between 1.0 (no selection pressure) and 2.0 (high selection pressure). The probability P {\\displaystyle P} for n {\\displaystyle n} rank positions R i {\\displaystyle R_{i}} is obtained as follows: P ( R i ) = 1 n ( s p − ( 2 s p − 2 ) i − 1 n − 1 ) 1 ≤ i ≤ n , 1 ≤ s p ≤ 2 w i t h P ( R i ) ≥ 0 , ∑ i = 1 n P ( R i )",
    "source_url": "https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:21.419664",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:21.419664",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:21.419664",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Selection_(genetic_algorithm)_1_1749015321452_2492",
    "text": "i − 1 n − 1 ) 1 ≤ i ≤ n , 1 ≤ s p ≤ 2 w i t h P ( R i ) ≥ 0 , ∑ i = 1 n P ( R i ) = 1 {\\displaystyle P(R_{i})={\\frac {1}{n}}{\\Bigl (}sp-(2sp-2){\\frac {i-1}{n-1}}{\\Bigr )}\\quad \\quad 1\\leq i\\leq n,\\quad 1\\leq sp\\leq 2\\quad {\\mathsf {with}}\\quad P(R_{i})\\geq 0,\\quad \\sum _{i=1}^{n}P(R_{i})=1} Another definition for the probability P {\\displaystyle P} for rank positions i {\\displaystyle i} is: [ 9 ] P ( i ) = 2 ∗ ( n − i + 1 ) n ∗ ( n + 1 ) {\\displaystyle P(i)={\\frac {2*(n-i+1)}{n*(n+1)}}} Exponential rank selection [ edit ] Exponential rank selection is defined as follows: [ 9 ] P ( i ) = w n − i ∑ k = 1 n w n − k , 0 ≤ w ≤ 1 {\\displaystyle P(i)={\\frac {w^{n-i}}{\\sum _{k=1}^{n}{w^{n-k}}}},0\\leq w\\leq 1} Steady state selection [ edit ] In every generation few chromosomes are selected (good - with high fitness) for creating a new offspring. Then some (bad - with low fitness) chromosomes are removed and the new offspring is placed in their place.",
    "source_url": "https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:21.452677",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:21.452677",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:21.452677",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Selection_(genetic_algorithm)_1_1749015321476_2041",
    "text": "The rest of population survives to new generation. Tournament selection [ edit ] Tournament selection is a method of choosing the individual from the set of individuals. The winner of each tournament is selected to perform crossover. Truncation selection [ edit ] For truncation selection , individuals are sorted according to their fitness and a portion (10% to 50%) of the top individuals is selected for next generation. [ 9 ] Elitist selection [ edit ] Often to get better results, strategies with partial reproduction are used. One of them is elitism, in which a small portion of the best individuals from the last generation is carried over (without any changes) to the next one. Boltzmann selection [ edit ] In Boltzmann selection, a continuously varying temperature controls the rate of selection according to a preset schedule. The temperature starts out high, which means that the selection pressure is low.",
    "source_url": "https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:21.476736",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:21.476736",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:21.477736",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Selection_(evolutionary_algorithm)&oldid=1292073722_1_1749015322717_4971",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 02:09, 25 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 02:09, 25 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Part",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Selection_(evolutionary_algorithm)&oldid=1292073722",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:22.717104",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:22.717104",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:22.717104",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Floyd%E2%80%93Rivest_algorithm_1_1749015324156_8087",
    "text": "Pseudocode version [ edit ] The following pseudocode rearranges the elements between left and right , such that for some value k , where left ≤ k ≤ right , the k th element in the list will contain the ( k − left + 1)th smallest value, with the ith element being less than or equal to the k th for all left ≤ i ≤ k and the jth element being larger or equal to for k ≤ j ≤ right : // left is the left index for the interval // right is the right index for the interval // k is the desired index value, where array[k] is the (k+1)th smallest element when left = 0 function select(array, left, right, k) is while right > left do // Use select recursively to sample a smaller set of size s // the arbitrary constants 600 and 0.5 are used in the original // version to minimize execution time. if right − left > 600 then n := right − left + 1\n            i := k − left + 1\n            z := ln (n)\n            s := 0.5 × exp (2 × z/3)\n            sd := 0.5 × sqrt (z × s × (n − s)/n)",
    "source_url": "https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:24.156236",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:24.156236",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:24.156236",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Floyd%E2%80%93Rivest_algorithm_1_1749015324194_2011",
    "text": "× sign (i − n/2)\n            newLeft := max (left, k − i × s/n + sd)\n            newRight := min (right, k + (n − i) × s/n + sd) select (array, newLeft, newRight, k)\n        // partition the elements between left and right around t t := array[k] i := left\n        j := right swap array[left] and array[k] if array[right] > t then swap array[right] and array[left] while i < j do swap array[i] and array[j]\n            i := i + 1\n            j := j − 1 while array[i] < t do i := i + 1 while array[j] > t do j := j − 1 if array[left] = t then swap array[left] and array[j] else j := j + 1 swap array[j] and array[right]\n        // Adjust left and right towards the boundaries of the subset // containing the (k − left + 1)th smallest element. if j ≤ k then left := j + 1 if k ≤ j then right := j − 1 See also [ edit ] Quickselect Introselect Median of medians References [ edit ] ^ Floyd, Robert W. ; Rivest, Ronald L. (1975).",
    "source_url": "https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:24.194553",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:24.194553",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:24.194553",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Floyd–Rivest_algorithm&oldid=1166993755_1_1749015324943_4491",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Citation bot ( talk | contribs ) at 01:58, 25 July 2023 (Add: doi, s2cid. | Use this bot . Report bugs . | #UCB_CommandLine) . The present address (URL) is a permanent link to this version. Revision as of 01:58, 25 July 2023 by Citation bot ( talk | contribs ) (Add: doi, s2cid. | Use this bot . Report bugs . | #UCB_CommandLine) ( diff ) ← Previous revision | Latest revision (diff) | Newe",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Floyd–Rivest_algorithm&oldid=1166993755",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:24.943460",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:24.943460",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:24.943460",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Streaming_algorithms_1_1749015326724_4328",
    "text": "In the turnstile model, each update is of the form ⟨ i , c ⟩ {\\displaystyle \\langle i,c\\rangle } , so that a i {\\displaystyle a_{i}} is incremented by some (possibly negative) integer c {\\displaystyle c} . In the \"strict turnstile\" model, no a i {\\displaystyle a_{i}} at any time may be less than zero. Sliding window model [ edit ] Several papers also consider the \"sliding window\" model. [ citation needed ] In this model,\nthe function of interest is computing over a fixed-size window in the\nstream. As the stream progresses, items from the end of the window are\nremoved from consideration while new items from the stream take their\nplace. Besides the above frequency-based problems, some other types of problems\nhave also been studied. Many graph problems are solved in the setting\nwhere the adjacency matrix or the adjacency list of the graph is streamed in\nsome unknown order.",
    "source_url": "https://en.wikipedia.org/wiki/Streaming_algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:26.724990",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:26.725990",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:26.725990",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Streaming_algorithms_1_1749015326827_7970",
    "text": "Some streaming problems [ edit ] Frequency moments [ edit ] The k th frequency moment of a set of frequencies a {\\displaystyle \\mathbf {a} } is defined as F k ( a ) = ∑ i = 1 n a i k {\\displaystyle F_{k}(\\mathbf {a} ) =\\sum _{i=1}^{n}a_{i}^{k}} . The first moment F 1 {\\displaystyle F_{1}} is simply the sum of the frequencies (i.e., the total count). The second moment F 2 {\\displaystyle F_{2}} is useful for computing statistical properties of the data, such as the Gini coefficient of variation. F ∞ {\\displaystyle F_{\\infty }} is defined as the frequency of the most frequent items. The seminal paper of Alon, Matias, and Szegedy dealt with the problem of estimating the frequency moments. [ citation needed ] Calculating frequency moments [ edit ] A direct approach to find the frequency moments requires to maintain a register m i for all distinct elements a i ∈ (1,2,3,4,..., N ) which requires at least memory\nof order Ω ( N ) {\\displaystyle \\Omega (N)} .",
    "source_url": "https://en.wikipedia.org/wiki/Streaming_algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:26.827700",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:26.828700",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:26.828700",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Streaming_algorithm&oldid=1292564081_1_1749015329431_6211",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by AnomieBOT ( talk | contribs ) at 17:21, 27 May 2025 ( Substing templates : {{Format ISBN}}. See User:AnomieBOT/docs/TemplateSubster for info.) . The present address (URL) is a permanent link to this version. Revision as of 17:21, 27 May 2025 by AnomieBOT ( talk | contribs ) ( Substing templates : {{Format ISBN}}. See User:AnomieBOT/docs/TemplateSubster for info.) ( diff ) ← Previous revi",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Streaming_algorithm&oldid=1292564081",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:29.431400",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:29.431400",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:29.431400",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_ACM_Transactions_on_Algorithms_1_1749015330874_7992",
    "text": "Interactions ACM Queue ACM XRDS Conferences ACM-MM AIES ASPLOS CHI CIKM DAC DEBS FAccT FCRC GECCO GHC HOPL Hot Chips Hypertext SenSys ICFP",
    "source_url": "https://en.wikipedia.org/wiki/ACM_Transactions_on_Algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:30.874367",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:30.874367",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:30.874367",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Journal_of_Algorithms_1_1749015334124_2368",
    "text": "Adjusted operating profits (with constant currency) rose by 2% from 2018 to 2019. [ 37 ] In 2019, researchers submitted over two million research papers to Elsevier-based publications. Over 22,000 editors managed the peer review and selection of these papers, resulting in the publication of about 500,000 articles in over 2,500 journals. [ 37 ] In 2020 Elsevier was the largest academic publisher, with approximately 16% of the academic publishing market and more than 3000 journals. [ 44 ] Market model [ edit ] Products and services [ edit ] Products and services include electronic and print versions of journals, textbooks and reference works , and cover the health , life, physical, and social sciences .",
    "source_url": "https://en.wikipedia.org/wiki/Journal_of_Algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:34.124903",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:34.125902",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:34.125902",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Journal_of_Algorithms_1_1749015334146_4858",
    "text": "ScienceDirect is Elsevier's platform for online electronic access to its journals and over 40,000 e-books, reference works, book series, and handbooks. The articles are grouped in four main sections: Physical Sciences and Engineering , Life Sciences , Health Sciences , and Social Sciences and Humanities . For most articles on the website, abstracts are freely available; access to the full text of the article (in PDF, and also HTML for newer publications) often requires a subscription or pay-per-view purchase. [ 37 ] In 2019, Elsevier published 49,000 free open access articles and 370 full open access journals. Moreover, 1,900 of its journals sold hybrid open access options.",
    "source_url": "https://en.wikipedia.org/wiki/Journal_of_Algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:34.146903",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:34.146903",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:34.146903",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Journal_of_Algorithms_1_1749015334173_2982",
    "text": "[ 48 ] Similar guidelines and criticism of Elsevier's pricing policies have been passed by the University of California , Harvard University , and Duke University . [ 49 ] In July 2015, the Association of Universities in the Netherlands threatened to boycott Elsevier, which refused to negotiate on any open access policy for Dutch universities. [ 50 ] After a year of negotiation, Elsevier pledged to make 30% of research published by Dutch researchers in Elsevier journals open access by 2018. [ 51 ] In October 2018, a complaint against Elsevier was filed with the European Commission, alleging anticompetitive practices stemming from Elsevier's confidential subscription agreements and market dominance. The European Commission decided not to investigate. [ 52 ] [ 53 ] The elevated pricing of field journals in economics, most of which are published by Elsevier, was one of the motivations that moved the American Economic Association to launch the American Economic Journal in 2009.",
    "source_url": "https://en.wikipedia.org/wiki/Journal_of_Algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:34.173413",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:34.173413",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:34.173413",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Journal_of_Algorithms_1_1749015334253_4627",
    "text": "[ 80 ] [ 81 ] [ 82 ] [ 83 ] [ 84 ] [ 85 ] [ 86 ] Horst Hippler, spokesperson for the DEAL consortium states that \"taxpayers have a right to read what they are paying for\" and that \"publishers must understand that the route to open-access publishing at an affordable price is irreversible\". [ 82 ] In July 2017, another 13 institutions announced that they would also be cancelling their subscriptions to Elsevier journals. [ 87 ] In August 2017, at least 185 German institutions had cancelled their contracts with Elsevier. [ 88 ] In 2018, whilst negotiations were ongoing, around 200 German universities that cancelled their subscriptions to Elsevier journals were granted complimentary open access to them until this ended in July of the year. [ 89 ] [ 90 ] [ 91 ] On 19 December 2018, the Max Planck Society (MPS) announced that the existing subscription agreement with Elsevier would not be renewed after the expiration date of 31 December 2018.",
    "source_url": "https://en.wikipedia.org/wiki/Journal_of_Algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:34.253111",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:34.253111",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:34.253111",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Selection_algorithm&oldid=1272480370_1_1749015337879_8151",
    "text": "Another variation in the problem definition concerns the numbering of the ordered values: is the smallest value obtained by setting k = 0 {\\displaystyle k=0} , as in zero-based numbering of arrays, or is it obtained by setting k = 1 {\\displaystyle k=1} , following the usual English-language conventions for the smallest, second-smallest, etc.? This article follows the conventions used by Cormen et al., according to which all values are distinct and the minimum value is obtained from k = 1 {\\displaystyle k=1} . [ 2 ] With these conventions, the maximum value, among a collection of n {\\displaystyle n} values, is obtained by setting k = n {\\displaystyle k=n} . When n {\\displaystyle n} is an odd number , the median of the collection is obtained by setting k = ( n + 1 ) / 2 {\\displaystyle k=(n+1)/2} .",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Selection_algorithm&oldid=1272480370",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:37.879113",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:37.879113",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:37.879113",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Devex_algorithm&oldid=927881807_1_1749015344200_2331",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Frap ( talk | contribs ) at 10:56, 25 November 2019 (Full name) . The present address (URL) is a permanent link to this version. Revision as of 10:56, 25 November 2019 by Frap ( talk | contribs ) (Full name) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) This article needs additional citations for verification . Please help improve this article by adding ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Devex_algorithm&oldid=927881807",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:44.200587",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:44.200587",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:44.200587",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Revised_simplex_algorithm_1_1749015345998_1924",
    "text": "[ a ] Since A has full rank, B is nonsingular. Without loss of generality, assume that A = [ B N ] . Then x is given by x = [ x B x N ] = [ B − 1 b 0 ] {\\displaystyle {\\boldsymbol {x}}={\\begin{bmatrix}{\\boldsymbol {x_{B}}}\\\\{\\boldsymbol {x_{N}}}\\end{bmatrix}}={\\begin{bmatrix}{\\boldsymbol {B}}^{-1}{\\boldsymbol {b}}\\\\{\\boldsymbol {0}}\\end{bmatrix}}} where x B ≥ 0 . Partition c and s accordingly into c = [ c B c N ] , s = [ s B s N ] . {\\displaystyle {\\begin{aligned}{\\boldsymbol {c}}&={\\begin{bmatrix}{\\boldsymbol {c_{B}}}\\\\{\\boldsymbol {c_{N}}}\\end{bmatrix}},\\\\{\\boldsymbol {s}}&={\\begin{bmatrix}{\\boldsymbol {s_{B}}}\\\\{\\boldsymbol {s_{N}}}\\end{bmatrix}}.\\end{aligned}}} To satisfy the complementary slackness condition, let s B = 0 .",
    "source_url": "https://en.wikipedia.org/wiki/Revised_simplex_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:45.998149",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:45.998149",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:45.998149",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Revised_simplex_algorithm_1_1749015346028_6226",
    "text": "It follows that B T λ = c B , N T λ + s N = c N , {\\displaystyle {\\begin{aligned}{\\boldsymbol {B}}^{\\mathrm {T} }{\\boldsymbol {\\lambda }}&={\\boldsymbol {c_{B}}},\\\\{\\boldsymbol {N}}^{\\mathrm {T} }{\\boldsymbol {\\lambda }}+{\\boldsymbol {s_{N}}}&={\\boldsymbol {c_{N}}},\\end{aligned}}} which implies that λ = ( B T ) − 1 c B , s N = c N − N T λ . {\\displaystyle {\\begin{aligned}{\\boldsymbol {\\lambda }}&=({\\boldsymbol {B}}^{\\mathrm {T} })^{-1}{\\boldsymbol {c_{B}}},\\\\{\\boldsymbol {s_{N}}}&={\\boldsymbol {c_{N}}}-{\\boldsymbol {N}}^{\\mathrm {T} }{\\boldsymbol {\\lambda }}.\\end{aligned}}} If s N ≥ 0 at this point, the KKT conditions are satisfied, and thus x is optimal. Pivot operation [ edit ] If the KKT conditions are violated, a pivot operation consisting of introducing a column of N into the basis at the expense of an existing column in B is performed. In the absence of degeneracy , a pivot operation always results in a strict decrease in c T x .",
    "source_url": "https://en.wikipedia.org/wiki/Revised_simplex_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:46.028352",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:46.028352",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:46.028352",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Revised_simplex_algorithm_1_1749015346061_4303",
    "text": "In the absence of degeneracy , a pivot operation always results in a strict decrease in c T x . Therefore, if the problem is bounded, the revised simplex method must terminate at an optimal vertex after repeated pivot operations because there are only a finite number of vertices. [ 4 ] Select an index m < q ≤ n such that s q < 0 as the entering index . The corresponding column of A , A q , will be moved into the basis, and x q will be allowed to increase from zero. It can be shown that ∂ ( c T x ) ∂ x q = s q , {\\displaystyle {\\frac {\\partial ({\\boldsymbol {c}}^{\\mathrm {T} }{\\boldsymbol {x}})}{\\partial x_{q}}}=s_{q},} i.e., every unit increase in x q results in a decrease by − s q in c T x . [ 5 ] Since B x B + A q x q = b , {\\displaystyle {\\boldsymbol {Bx_{B}}}+{\\boldsymbol {A}}_{q}x_{q}={\\boldsymbol {b}},} x B must be correspondingly decreased by Δ x B = B −1 A q x q subject to x B − Δ x B ≥ 0 . Let d = B −1 A q .",
    "source_url": "https://en.wikipedia.org/wiki/Revised_simplex_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:46.061360",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:46.062365",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:46.062365",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Revised_simplex_algorithm_1_1749015346087_1882",
    "text": "A q x q subject to x B − Δ x B ≥ 0 . Let d = B −1 A q . If d ≤ 0 , no matter how much x q is increased, x B − Δ x B will stay nonnegative. Hence, c T x can be arbitrarily decreased, and thus the problem is unbounded. Otherwise, select an index p = argmin 1≤ i ≤ m { x i / d i | d i > 0} as the leaving index . This choice effectively increases x q from zero until x p is reduced to zero while maintaining feasibility. The pivot operation concludes with replacing A p with A q in the basis. Numerical example [ edit ] See also: Simplex method § Example Consider a linear program where c = [ − 2 − 3 − 4 0 0 ] T , A = [ 3 2 1 1 0 2 5 3 0 1 ] , b = [ 10 15 ] .",
    "source_url": "https://en.wikipedia.org/wiki/Revised_simplex_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:46.087871",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:46.088871",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:46.088871",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Revised_simplex_algorithm_1_1749015346114_9826",
    "text": "T , A = [ 3 2 1 1 0 2 5 3 0 1 ] , b = [ 10 15 ] . {\\displaystyle {\\begin{aligned}{\\boldsymbol {c}}&={\\begin{bmatrix}-2&-3&-4&0&0\\end{bmatrix}}^{\\mathrm {T} },\\\\{\\boldsymbol {A}}&={\\begin{bmatrix}3&2&1&1&0\\\\2&5&3&0&1\\end{bmatrix}},\\\\{\\boldsymbol {b}}&={\\begin{bmatrix}10\\\\15\\end{bmatrix}}.\\end{aligned}}} Let B = [ A 4 A 5 ] , N = [ A 1 A 2 A 3 ] {\\displaystyle {\\begin{aligned}{\\boldsymbol {B}}&={\\begin{bmatrix}{\\boldsymbol {A}}_{4}&{\\boldsymbol {A}}_{5}\\end{bmatrix}},\\\\{\\boldsymbol {N}}&={\\begin{bmatrix}{\\boldsymbol {A}}_{1}&{\\boldsymbol {A}}_{2}&{\\boldsymbol {A}}_{3}\\end{bmatrix}}\\end{aligned}}} initially, which corresponds to a feasible vertex x = [0 0 0 10 15] T . At this moment, λ = [ 0 0 ] T , s N = [ − 2 − 3 − 4 ] T . {\\displaystyle {\\begin{aligned}{\\boldsymbol {\\lambda }}&={\\begin{bmatrix}0&0\\end{bmatrix}}^{\\mathrm {T} },\\\\{\\boldsymbol {s_{N}}}&={\\begin{bmatrix}-2&-3&-4\\end{bmatrix}}^{\\mathrm {T} }.\\end{aligned}}} Choose q = 3 as the entering index.",
    "source_url": "https://en.wikipedia.org/wiki/Revised_simplex_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:46.114122",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:46.114122",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:46.114122",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Revised_simplex_algorithm_1_1749015346142_9263",
    "text": "Then d = [1 3] T , which means a unit increase in x 3 results in x 4 and x 5 being decreased by 1 and 3 , respectively. Therefore, x 3 is increased to 5 , at which point x 5 is reduced to zero, and p = 5 becomes the leaving index. After the pivot operation, B = [ A 3 A 4 ] , N = [ A 1 A 2 A 5 ] . {\\displaystyle {\\begin{aligned}{\\boldsymbol {B}}&={\\begin{bmatrix}{\\boldsymbol {A}}_{3}&{\\boldsymbol {A}}_{4}\\end{bmatrix}},\\\\{\\boldsymbol {N}}&={\\begin{bmatrix}{\\boldsymbol {A}}_{1}&{\\boldsymbol {A}}_{2}&{\\boldsymbol {A}}_{5}\\end{bmatrix}}.\\end{aligned}}} Correspondingly, x = [ 0 0 5 5 0 ] T , λ = [ 0 − 4 / 3 ] T , s N = [ 2 / 3 11 / 3 4 / 3 ] T . {\\displaystyle {\\begin{aligned}{\\boldsymbol {x}}&={\\begin{bmatrix}0&0&5&5&0\\end{bmatrix}}^{\\mathrm {T} },\\\\{\\boldsymbol {\\lambda }}&={\\begin{bmatrix}0&-4/3\\end{bmatrix}}^{\\mathrm {T} },\\\\{\\boldsymbol {s_{N}}}&={\\begin{bmatrix}2/3&11/3&4/3\\end{bmatrix}}^{\\mathrm {T} }.\\end{aligned}}} A positive s N indicates that x is now optimal.",
    "source_url": "https://en.wikipedia.org/wiki/Revised_simplex_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:46.142992",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:46.142992",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:46.142992",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoidal_algorithm_1_1749015349146_1333",
    "text": "{\\displaystyle f_{i}(x)\\leqslant 0} , where the functions f i {\\displaystyle f_{i}} are convex; these constraints define a convex set Q {\\displaystyle Q} . Linear equality constraints of the form h i ( x ) = 0 {\\displaystyle h_{i}(x)=0} . We are also given an initial ellipsoid E ( 0 ) ⊂ R n {\\displaystyle {\\mathcal {E}}^{(0)}\\subset \\mathbb {R} ^{n}} defined as E ( 0 ) = { z ∈ R n : ( z − x 0 ) T P ( 0 ) − 1 ( z − x 0 ) ⩽ 1 } {\\displaystyle {\\mathcal {E}}^{(0)}=\\left\\{z\\in \\mathbb {R} ^{n}\\ :\\ (z-x_{0})^{T}P_{(0)}^{-1}(z-x_{0})\\leqslant 1\\right\\}} containing a minimizer x ∗ {\\displaystyle x^{*}} , where P ( 0 ) ≻ 0 {\\displaystyle P_{(0)}\\succ 0} and x 0 {\\displaystyle x_{0}} is the center of E {\\displaystyle {\\mathcal {E}}} . Finally, we require the existence of a separation oracle for the convex set Q {\\displaystyle Q} .",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoidal_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:49.146597",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:49.146597",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:49.146597",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoidal_algorithm_1_1749015349176_4093",
    "text": "Finally, we require the existence of a separation oracle for the convex set Q {\\displaystyle Q} . Given a point x ∈ R n {\\displaystyle x\\in \\mathbb {R} ^{n}} , the oracle should return one of two answers: [ 5 ] \"The point x {\\displaystyle x} is in Q {\\displaystyle Q} \", or - \"The point x {\\displaystyle x} is not in Q {\\displaystyle Q} , and moreover, here is a hyperplane that separates x {\\displaystyle x} from Q {\\displaystyle Q} \", that is, a vector c {\\displaystyle c} such that c ⋅ x < c ⋅ y {\\displaystyle c\\cdot x<c\\cdot y} for all y ∈ Q {\\displaystyle y\\in Q} . The output of the ellipsoid method is either: Any point in the polytope Q {\\displaystyle Q} (i.e., any feasible point), or - A proof that Q {\\displaystyle Q} is empty. Inequality-constrained minimization of a function that is zero everywhere corresponds to the problem of simply identifying any feasible point.",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoidal_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:49.176609",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:49.176609",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:49.176609",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoidal_algorithm_1_1749015349255_4377",
    "text": "We query the cutting-plane oracle to obtain a vector g ( k + 1 ) ∈ R n {\\displaystyle g^{(k+1)}\\in \\mathbb {R} ^{n}} such that g ( k + 1 ) T ( x ∗ − x ( k ) ) ⩽ 0. {\\displaystyle g^{(k+1)T}\\left(x^{*}-x^{(k)}\\right)\\leqslant 0.} We therefore conclude that x ∗ ∈ E ( k ) ∩ { z : g ( k + 1 ) T ( z − x ( k ) ) ⩽ 0 } . {\\displaystyle x^{*}\\in {\\mathcal {E}}^{(k)}\\cap \\left\\{z\\ :\\ g^{(k+1)T}\\left(z-x^{(k)}\\right)\\leqslant 0\\right\\}.} We set E ( k + 1 ) {\\displaystyle {\\mathcal {E}}^{(k+1)}} to be the ellipsoid of minimal volume containing the half-ellipsoid described above and compute x ( k + 1 ) {\\displaystyle x^{(k+1)}} . The update is given by x ( k + 1 ) = x ( k ) − 1 n + 1 P ( k ) g ~ ( k + 1 ) P ( k + 1 ) = n 2 n 2 − 1 ( P ( k ) − 2 n + 1 P ( k ) g ~ ( k + 1 ) g ~ ( k + 1 ) T P ( k ) )",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoidal_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:49.255706",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:49.255706",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:49.255706",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoidal_algorithm_1_1749015349328_3502",
    "text": "We also must maintain a list of values f b e s t ( k ) {\\displaystyle f_{\\rm {best}}^{(k)}} recording the smallest objective value of feasible iterates so far. Depending on whether or not the point x ( k ) {\\displaystyle x^{(k)}} is feasible, we perform one of two tasks: If x ( k ) {\\displaystyle x^{(k)}} is feasible, perform essentially the same update as in the unconstrained case, by choosing a subgradient g 0 {\\displaystyle g_{0}} that satisfies g 0 T ( x ∗ − x ( k ) ) + f 0 ( x ( k ) ) − f b e s t ( k ) ⩽ 0 {\\displaystyle g_{0}^{T}(x^{*}-x^{(k)})+f_{0}(x^{(k)})-f_{\\rm {best}}^{(k)}\\leqslant 0} If x ( k ) {\\displaystyle x^{(k)}} is infeasible and violates the j -th constraint, update the ellipsoid with a feasibility cut. Our feasibility cut may be a subgradient g j {\\displaystyle g_{j}} of f j {\\displaystyle f_{j}} which must satisfy g j T ( z − x ( k ) ) + f j ( x ( k ) ) ⩽ 0 {\\displaystyle g_{j}^{T}(z-x^{(k)})+f_{j}(x^{(k)})\\leqslant 0} for all feasible z .",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoidal_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:49.328652",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:49.328652",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:49.328652",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoidal_algorithm_1_1749015349358_9939",
    "text": "⩽ 0 {\\displaystyle g_{j}^{T}(z-x^{(k)})+f_{j}(x^{(k)})\\leqslant 0} for all feasible z . Performance in convex programs [ edit ] Theoretical run-time complexity guarantee [ edit ] The run-time complexity guarantee of the ellipsoid method in the real RAM model is given by the following theorem. [ 7 ] : Thm.8.3.1 Consider a family of convex optimization problems of the form: minimize f ( x ) s.t. x is in G , where f is a convex function and G is a convex set (a subset of an Euclidean space R n ). Each problem p in the family is represented by a data-vector Data( p ), e.g., the real-valued coefficients in matrices and vectors representing the function f and the feasible region G . The size of a problem p , Size( p ),  is defined as the number of elements (real numbers) in Data( p ). The following assumptions are needed: G (the feasible region) is: Bounded; Has a non-empty interior (so there is a strictly-feasible point); Given Data( p ), one can compute using poly(Size(p))",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoidal_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:49.358652",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:49.358652",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:49.358652",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ellipsoidal_algorithm_1_1749015349391_6699",
    "text": "Given Data( p ), one can compute using poly(Size(p)) arithmetic operations: An ellipsoid that contains G ; A lower bound 'MinVol(p)>0' of the volume G . Given Data( p ) and a point x in R n , one can compute using poly(Size(p)) arithmetic operations: A separation oracle for G (that is: either assert that x is in G , or return a hyperplane separating x from G ). A first-order oracle for f (that is: compute the value of f ( x ) and a subgradient f' ( x )). Under these assumptions, the ellipsoid method is \"R-polynomial\". This means that there exists a polynomial Poly such that, for every problem-instance p and every approximation-ratio ε >0, the method finds a solution x satisfying : f ( x ) − min G f ≤ ε ⋅ [ max G f − min G f ] {\\displaystyle f(x)-\\min _{G}f\\leq \\varepsilon \\cdot [\\max _{G}f-\\min _{G}f]} , using at most the following number of arithmetic operations on real numbers: P o l y ( S i z e ( p ) )",
    "source_url": "https://en.wikipedia.org/wiki/Ellipsoidal_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:49.391173",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:49.391173",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:49.391173",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Interior_point_method_1_1749015352780_4157",
    "text": "Technically the program is restricted, since b is defined only in the interior of G . But practically, it is possible to solve it as an unconstrained program, since any solver trying to minimize the function will not approach the boundary, where b approaches infinity. Therefore, ( P t ) has a unique solution - denote it by x *( t ). The function x * is a continuous function of t , which is called the central path . All limit points of x *, as t approaches infinity, are optimal solutions of the original program (P). A path-following method is a method of tracking the function x * along a certain increasing sequence t 1 ,t 2 ,..., that is: computing a good-enough approximation x i to the point x *( t i ), such that the difference x i - x *( t i ) approaches 0 as i approaches infinity; then the sequence x i approaches the optimal solution of (P). This requires to specify three things: The barrier function b(x). A policy for determining the penalty parameters t i .",
    "source_url": "https://en.wikipedia.org/wiki/Interior_point_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:52.780938",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:52.780938",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:52.780938",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Interior_point_method_1_1749015352807_5758",
    "text": "A policy for determining the penalty parameters t i . The unconstrained-optimization solver used to solve ( P i ) and find x i , such as Newton's method . Note that we can use each x i as a starting-point for solving the next problem ( P i+1 ). The main challenge in proving that the method is polytime is that, as the penalty parameter grows, the solution gets near the boundary, and the function becomes steeper. The run-time of solvers such as Newton's method becomes longer, and it is hard to prove that the total runtime is polynomial. Renegar [ 7 ] and Gonzaga [ 8 ] proved that a specific instance of a path-following method is polytime: The constraints (and the objective) are linear functions; The barrier function is logarithmic :   b(x) := - sum j log( -g j ( x )).",
    "source_url": "https://en.wikipedia.org/wiki/Interior_point_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:52.807454",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:52.808446",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:52.808446",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Interior_point_method_1_1749015352839_7416",
    "text": "The penalty parameter t is updated geometrically, that is, t i + 1 := μ ⋅ t i {\\displaystyle t_{i+1}:=\\mu \\cdot t_{i}} , where μ is a constant (they took μ = 1 + 0.001 ⋅ m {\\displaystyle \\mu =1+0.001\\cdot {\\sqrt {m}}} , where m is the number of inequality constraints); The solver is Newton's method, and a single step of Newton is done for each single step in t . They proved that, in this case, the difference x i - x *( t i ) remains at most 0.01, and f( x i ) - f* is at most 2* m / t i . Thus, the solution accuracy is proportional to 1/ t i , so to add a single accuracy-digit, it is sufficient to multiply t i by 2 (or any other constant factor), which requires O(sqrt( m )) Newton steps. Since each Newton step takes O( m n 2 ) operations, the total complexity is O( m 3/2 n 2 )  operations for accuracy digit. Yuri Nesterov extended the idea from linear to non-linear programs.",
    "source_url": "https://en.wikipedia.org/wiki/Interior_point_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:52.839643",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:52.839643",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:52.839643",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Interior_point_method_1_1749015352869_3498",
    "text": "Yuri Nesterov extended the idea from linear to non-linear programs. He noted that the main property of the logarithmic barrier, used in the above proofs, is that it is self-concordant with a finite barrier parameter. Therefore, many other classes of convex programs can be solved in polytime using a path-following method, if we can find a suitable self-concordant barrier function for their feasible region. [ 3 ] : Sec.1 Details [ edit ] We are given a convex optimization problem (P) in \"standard form\": minimize c T x s.t. x in G , where G is convex and closed. We can also assume that G is bounded (we can easily make it bounded by adding a constraint | x |≤ R for some sufficiently large R ). [ 3 ] : Sec.4 To use the interior-point method, we need a self-concordant barrier for G . Let b be an M -self-concordant barrier for G , where M ≥1 is the self-concordance parameter.",
    "source_url": "https://en.wikipedia.org/wiki/Interior_point_method",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:52.869646",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:52.869646",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:52.869646",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Optimization_(mathematics)_1_1749015355593_9175",
    "text": "Optimization problems [ edit ] Main article: Optimization problem Optimization problems can be divided into two categories, depending on whether the variables are continuous or discrete : An optimization problem with discrete variables is known as a discrete optimization , in which an object such as an integer , permutation or graph must be found from a countable set . A problem with continuous variables is known as a continuous optimization , in which optimal arguments from a continuous set must be found. They can include constrained problems and multimodal problems. An optimization problem can be represented in the following way: Given: a function f : A → R {\\displaystyle \\mathbb {R} } from some set A to the real numbers Sought: an element x 0 ∈ A such that f ( x 0 ) ≤ f ( x ) for all x ∈ A (\"minimization\") or such that f ( x 0 ) ≥ f ( x ) for all x ∈ A (\"maximization\").",
    "source_url": "https://en.wikipedia.org/wiki/Optimization_(mathematics)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:55.593974",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:55.593974",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:55.593974",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Optimization_(mathematics)_1_1749015355645_8238",
    "text": "In machine learning , it is always necessary to continuously evaluate the quality of a data model by using a cost function where a minimum implies a set of possibly optimal parameters with an optimal (lowest) error. Typically, A is some subset of the Euclidean space R n {\\displaystyle \\mathbb {R} ^{n}} , often specified by a set of constraints , equalities or inequalities that the members of A have to satisfy. The domain A of f is called the search space or the choice set , while the elements of A are called candidate solutions or feasible solutions . The function f is variously called an objective function , criterion function , loss function , cost function (minimization), [ 6 ] utility function or fitness function (maximization), or, in certain fields, an energy function or energy functional . A feasible solution that minimizes (or maximizes) the objective function is called an optimal solution .",
    "source_url": "https://en.wikipedia.org/wiki/Optimization_(mathematics)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:55.645865",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:55.645865",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:55.645865",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Optimization_(mathematics)_1_1749015355673_1906",
    "text": "the objective function is called an optimal solution . In mathematics, conventional optimization problems are usually stated in terms of minimization. A local minimum x * is defined as an element for which there exists some δ > 0 such that ∀ x ∈ A where ‖ x − x ∗ ‖ ≤ δ , {\\displaystyle \\forall \\mathbf {x} \\in A\\;{\\text{where}}\\;\\left\\Vert \\mathbf {x} -\\mathbf {x} ^{\\ast }\\right\\Vert \\leq \\delta ,\\,} the expression f ( x *) ≤ f ( x ) holds; that is to say, on some region around x * all of the function values are greater than or equal to the value at that element. Local maxima are defined similarly. While a local minimum is at least as good as any nearby elements, a global minimum is at least as good as every feasible element. Generally, unless the objective function is convex in a minimization problem, there may be several local minima.",
    "source_url": "https://en.wikipedia.org/wiki/Optimization_(mathematics)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:55.673877",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:55.673877",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:55.673877",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Optimization_(mathematics)_1_1749015355733_7839",
    "text": "Notation [ edit ] Optimization problems are often expressed with special notation. Here are some examples: Minimum and maximum value of a function [ edit ] Consider the following notation: min x ∈ R ( x 2 + 1 ) { \\displaystyle \\min _{x\\in \\mathbb {R} }\\;\\left(x^{2}+1\\right)} This denotes the minimum value of the objective function x 2 + 1 , when choosing x from the set of real numbers R {\\displaystyle \\mathbb {R} } . The minimum value in this case is 1, occurring at x = 0 . Similarly, the notation max x ∈ R 2 x {\\displaystyle \\max _{x\\in \\mathbb {R} }\\;2x} asks for the maximum value of the objective function 2 x , where x may be any real number. In this case, there is no such maximum as the objective function is unbounded, so the answer is \" infinity \" or \" undefined \".",
    "source_url": "https://en.wikipedia.org/wiki/Optimization_(mathematics)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:35:55.733447",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:35:55.733447",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:35:55.733447",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Simplex_algorithm&oldid=1290942242_1_1749015362824_7771",
    "text": "{\\displaystyle \\mathbf {x} =(x_{1},\\,\\dots ,\\,x_{n})} are the variables of the problem, A {\\displaystyle A} is a p × n matrix, and b = ( b 1 , … , b p ) {\\displaystyle \\mathbf {b} =(b_{1},\\,\\dots ,\\,b_{p})} . There is a straightforward process to convert any linear program into one in standard form, so using this form of linear programs results in no loss of generality. In geometric terms, the feasible region defined by all values of x {\\displaystyle \\mathbf {x} } such that A x ≤ b {\\textstyle A\\mathbf {x} \\leq \\mathbf {b} } and ∀ i , x i ≥ 0 {\\displaystyle \\forall i,x_{i}\\geq 0} is a (possibly unbounded) convex polytope . An extreme point or vertex of this polytope is known as basic feasible solution (BFS). It can be shown that for a linear program in standard form, if the objective function has a maximum value on the feasible region, then it has this value on (at least) one of the extreme points.",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Simplex_algorithm&oldid=1290942242",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:02.824287",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:02.825287",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:02.825287",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Simplex_algorithm&oldid=1290942242_1_1749015362929_4204",
    "text": "The possible results from Phase II are either an optimum basic feasible solution or an infinite edge on which the objective function is unbounded above. [ 13 ] [ 14 ] [ 15 ] Standard form [ edit ] The transformation of a linear program to one in standard form may be accomplished as follows. [ 16 ] First, for each variable with a lower bound other than 0, a new variable is introduced representing the difference between the variable and bound. The original variable can then be eliminated by substitution. For example, given the constraint x 1 ≥ 5 {\\displaystyle x_{1}\\geq 5} a new variable, y 1 {\\displaystyle y_{1}} , is introduced with y 1 = x 1 − 5 x 1 = y 1 + 5 {\\displaystyle {\\begin{aligned}y_{1}=x_{1}-5\\\\x_{1}=y_{1}+5\\end{aligned}}} The second equation may be used to eliminate x 1 {\\displaystyle x_{1}} from the linear program. In this way, all lower bound constraints may be changed to non-negativity restrictions.",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Simplex_algorithm&oldid=1290942242",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:02.929922",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:02.929922",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:02.929922",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Simplex_algorithm&oldid=1290942242_1_1749015362985_1822",
    "text": "Third, each unrestricted variable is eliminated from the linear program. This can be done in two ways, one is by solving for the variable in one of the equations in which it appears and then eliminating the variable by substitution. The other is to replace the variable with the difference of two restricted variables. For example, if z 1 {\\displaystyle z_{1}} is unrestricted then write z 1 = z 1 + − z 1 − z 1 + , z 1 − ≥ 0 {\\displaystyle {\\begin{aligned}&z_{1}=z_{1}^{+}-z_{1}^{-}\\\\&z_{1}^{+},\\,z_{1}^{-}\\geq 0\\end{aligned}}} The equation may be used to eliminate z 1 {\\displaystyle z_{1}} from the linear program. When this process is complete the feasible region will be in the form A x = b , ∀ x i ≥ 0 {\\displaystyle \\mathbf {A} \\mathbf {x} =\\mathbf {b} ,\\,\\forall \\ x_{i}\\geq 0} It is also useful to assume that the rank of A {\\displaystyle \\mathbf {A} } is the number of rows.",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Simplex_algorithm&oldid=1290942242",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:02.985168",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:02.985168",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:02.985168",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Kleene%27s_algorithm_1_1749015373491_7004",
    "text": "( a | ε) | a | ε = a * R 0 01 = R −1 00 ( R −1 00 ) * R −1 01 | R −1 01 = ( a | ε) ( a | ε) * b | b = a * b R 0 02 = R −1 00 ( R −1 00 ) * R −1 02 | R −1 02 = ( a | ε) ( a | ε) * ∅ | ∅ = ∅ R 0 10 = R −1 10 ( R −1 00 ) * R −1 00 | R −1 10 = ∅ ( a | ε) * ( a | ε) | ∅ = ∅ R 0 11 = R −1 10 ( R −1 00 ) * R −1 01 | R −1 11 = ∅ ( a | ε) * b | b | ε = b | ε R 0 12 = R −1 10 ( R −1 00 ) * R −1 02 | R −1 12 = ∅ ( a | ε) * ∅ | a = a R 0 20 = R −1 20 ( R −1 00 ) * R −1 00 | R −1 20 = ∅ ( a | ε) * ( a | ε) | ∅ = ∅ R 0 21 = R −1 20 ( R −1 00 ) * R −1 01 | R −1 21 = ∅ ( a | ε) * b | a | b = a | b R 0 22 = R −1 20 ( R −1 00 ) * R −1 02 | R −1 22 = ∅ ( a | ε) * ∅ | ε = ε Step 1 R 1 00 = R 0 01 ( R 0 11 ) * R 0 10 | R 0 00 = a * b ( b | ε) * ∅ | a * = a * R 1 01 = R 0 01 ( R 0 11 ) * R 0 11 | R 0 01 = a * b ( b | ε) * ( b | ε) | a * b = a * b * b R 1 02 = R 0 01 ( R 0 11 ) * R 0 12 | R 0 02 = a * b ( b | ε) * a | ∅ = a * b * ba R 1 10 = R 0 11 ( R 0 11 ) * R 0 10 | R 0 10 = ( b | ε) ( b | ε) *",
    "source_url": "https://en.wikipedia.org/wiki/Kleene%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:13.491241",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:13.491241",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:13.491241",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Kleene%27s_algorithm_1_1749015373551_3359",
    "text": "a | ∅ = a * b * ba R 1 10 = R 0 11 ( R 0 11 ) * R 0 10 | R 0 10 = ( b | ε) ( b | ε) * ∅ | ∅ = ∅ R 1 11 = R 0 11 ( R 0 11 ) * R 0 11 | R 0 11 = ( b | ε) ( b | ε) * ( b | ε) | b | ε = b * R 1 12 = R 0 11 ( R 0 11 ) * R 0 12 | R 0 12 = ( b | ε) ( b | ε) * a | a = b * a R 1 20 = R 0 21 ( R 0 11 ) * R 0 10 | R 0 20 = ( a | b ) ( b | ε) * ∅ | ∅ = ∅ R 1 21 = R 0 21 ( R 0 11 ) * R 0 11 | R 0 21 = ( a | b ) ( b | ε) * ( b | ε) | a | b = ( a | b ) b * R 1 22 = R 0 21 ( R 0 11 ) * R 0 12 | R 0 22 = ( a | b ) ( b | ε) * a | ε = ( a | b ) b * a | ε Step 2 R 2 00 = R 1 02 ( R 1 22 ) * R 1 20 | R 1 00 = a * b * ba (( a | b ) b * a | ε) * ∅ | a * = a * R 2 01 = R 1 02 ( R 1 22 ) * R 1 21 | R 1 01 = a * b * ba (( a | b ) b * a | ε) * ( a | b ) b * | a * b * b = a * b ( a ( a | b ) | b ) * R 2 02 = R 1 02 ( R 1 22 ) * R 1 22 | R 1 02 = a * b * ba (( a | b ) b * a | ε) * (( a | b ) b * a | ε) | a * b * ba = a * b * b ( a ( a | b ) b * ) * a R 2 10 = R 1 12 ( R 1 22 ) *",
    "source_url": "https://en.wikipedia.org/wiki/Kleene%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:13.551999",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:13.551999",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:13.551999",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Kleene%27s_algorithm_1_1749015373610_8820",
    "text": "(( a | b ) b * a | ε) | a * b * ba = a * b * b ( a ( a | b ) b * ) * a R 2 10 = R 1 12 ( R 1 22 ) * R 1 20 | R 1 10 = b * a (( a | b ) b * a | ε) * ∅ | ∅ = ∅ R 2 11 = R 1 12 ( R 1 22 ) * R 1 21 | R 1 11 = b * a (( a | b ) b * a | ε) * ( a | b ) b * | b * =  ( a ( a | b ) | b ) * R 2 12 = R 1 12 ( R 1 22 ) * R 1 22 | R 1 12 = b * a (( a | b ) b * a | ε) * (( a | b ) b * a | ε) | b * a =  ( a ( a | b ) | b ) * a R 2 20 = R 1 22 ( R 1 22 ) * R 1 20 | R 1 20 = (( a | b ) b * a | ε) (( a | b ) b * a | ε) * ∅ | ∅ = ∅ R 2 21 = R 1 22 ( R 1 22 ) * R 1 21 | R 1 21 = (( a | b ) b * a | ε) (( a | b ) b * a | ε) * ( a | b ) b * | ( a | b ) b * = ( a | b ) ( a ( a | b ) | b ) * R 2 22 = R 1 22 ( R 1 22 ) * R 1 22 | R 1 22 = (( a | b ) b * a | ε) (( a | b ) b * a | ε) * (( a | b ) b * a | ε) | ( a | b ) b * a | ε = (( a | b ) b * a ) * Since q 0 is the start state and q 1 is the only accept state, the regular expression R 2 01 denotes the set of all strings accepted by the automaton.",
    "source_url": "https://en.wikipedia.org/wiki/Kleene%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:13.610073",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:13.610073",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:13.610073",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Kleene%27s_algorithm&oldid=1285525439_1_1749015374720_1205",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by JJMC89 bot III ( talk | contribs ) at 06:30, 14 April 2025 (Moving Category:Finite automata to Category:Finite-state machines per Wikipedia:Categories for discussion/Speedy ) . The present address (URL) is a permanent link to this version. Revision as of 06:30, 14 April 2025 by JJMC89 bot III ( talk | contribs ) (Moving Category:Finite automata to Category:Finite-state machines per Wikip",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Kleene%27s_algorithm&oldid=1285525439",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:14.720821",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:14.721821",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:14.721821",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Gauss%E2%80%93Jordan_elimination_1_1749015376387_8014",
    "text": "There are three types of elementary row operations: Swapping two rows, Multiplying a row by a nonzero number, Adding a multiple of one row to another row. Using these operations, a matrix can always be transformed into an upper triangular matrix (possibly bordered by rows or columns of zeros), and in fact one that is in row echelon form . Once all of the leading coefficients (the leftmost nonzero entry in each row) are 1, and every column containing a leading coefficient has zeros elsewhere, the matrix is said to be in reduced row echelon form . This final form is unique; in other words, it is independent of the sequence of row operations used. For example, in the following sequence of row operations (where two elementary operations on different rows are done at the first and third steps), the third and fourth matrices are the ones in row echelon form, and the final matrix is the unique reduced row echelon form.",
    "source_url": "https://en.wikipedia.org/wiki/Gauss%E2%80%93Jordan_elimination",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:16.387793",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:16.387793",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:16.387793",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Gauss%E2%80%93Jordan_elimination_1_1749015376529_2119",
    "text": "So if two leading coefficients are in the same column, then a row operation of type 3 could be used to make one of those coefficients zero. Then by using the row swapping operation, one can always order the rows so that for every non-zero row, the leading coefficient is to the right of the leading coefficient of the row above. If this is the case, then matrix is said to be in row echelon form. So the lower left part of the matrix contains only zeros, and all of the zero rows are below the non-zero rows. The word \"echelon\" is used here because one can roughly think of the rows being ranked by their size, with the largest being at the top and the smallest being at the bottom. For example, the following matrix is in row echelon form, and its leading coefficients are shown in red: [ 0 2 1 − 1 0 0 3 1 0 0 0 0 ] . {\\displaystyle {\\begin{bmatrix}0&\\color {red}{\\mathbf {2} }&1&-1\\\\0&0&\\color {red}{\\mathbf {3} }&1\\\\0&0&0&0\\end{bmatrix}}.}",
    "source_url": "https://en.wikipedia.org/wiki/Gauss%E2%80%93Jordan_elimination",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:16.529369",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:16.529369",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:16.529369",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Gauss%E2%80%93Jordan_elimination_1_1749015376636_1363",
    "text": "{\\displaystyle {\\begin{alignedat}{4}2x&{}+{}&y&{}-{}&z&{}={}&8&\\\\&&{\\tfrac {1}{2}}y&{}+{}&{\\tfrac {1}{2}}z&{}={}&1&\\\\&&2y&{}+{}&z&{}={}&5&\\end{alignedat}}} L 2 + 3 2 L 1 → L 2 L 3 + L 1 → L 3 {\\displaystyle {\\begin{aligned}L_{2}+{\\tfrac {3}{2}}L_{1}&\\to L_{2}\\\\L_{3}+L_{1}&\\to L_{3}\\end{aligned}}} [ 2 1 − 1 8 0 1 2 1 2 1 0 2 1 5 ] {\\displaystyle \\left[{\\begin{array}{rrr|r}2&1&-1&8\\\\0&{\\frac {1}{2}}&{\\frac {1}{2}}&1\\\\0&2&1&5\\end{array}}\\right]} 2 x + y − z = 8 1 2 y + 1 2 z = 1 − z = 1 {\\displaystyle {\\begin{alignedat}{4}2x&{}+{}&y&{}-{}&z&{}={}&8&\\\\&&{\\tfrac {1}{2}}y&{}+{}&{\\tfrac {1}{2}}z&{}={}&1&\\\\&&&&-z&{}={}&1&\\end{alignedat}}} L 3 + − 4 L 2 → L 3 {\\displaystyle L_{3}+-4L_{2}\\to L_{3}} [ 2 1 − 1 8 0 1 2 1 2 1 0 0 − 1 1 ] {\\displaystyle \\left[{\\begin{array}{rrr|r}2&1&-1&8\\\\0&{\\frac {1}{2}}&{\\frac {1}{2}}&1\\\\0&0&-1&1\\end{array}}\\right]} The matrix is now in echelon form (also called triangular form) 2 x + y = 7 1 2 y = 3 2 − z = 1 {\\displaystyle",
    "source_url": "https://en.wikipedia.org/wiki/Gauss%E2%80%93Jordan_elimination",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:16.636145",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:16.636145",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:16.636145",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Gauss%E2%80%93Jordan_elimination_1_1749015376668_8098",
    "text": "{\\begin{alignedat}{4}2x&{}+{}&y&&&{}={}7&\\\\&&{\\tfrac {1}{2}}y&&&{}={}{\\tfrac {3}{2}}&\\\\&&&{}-{}&z&{}={}1&\\end{alignedat}}} L 1 − L 3 → L 1 L 2 + 1 2 L 3 → L 2 {\\displaystyle {\\begin{aligned}L_{1}-L_{3}&\\to L_{1}\\\\L_{2}+{\\tfrac {1}{2}}L_{3}&\\to L_{2}\\end{aligned}}} [ 2 1 0 7 0 1 2 0 3 2 0 0 − 1 1 ] {\\displaystyle \\left[{\\begin{array}{rrr|r}2&1&0&7\\\\0&{\\frac {1}{2}}&0&{\\frac {3}{2}}\\\\0&0&-1&1\\end{array}}\\right]} 2 x + y = 7 y = 3 z = − 1 {\\displaystyle {\\begin{alignedat}{4}2x&{}+{}&y&\\quad &&{}={}&7&\\\\&&y&\\quad &&{}={}&3&\\\\&&&\\quad &z&{}={}&-1&\\end{alignedat}}} 2 L 2 → L 2 − L 3 → L 3 {\\displaystyle {\\begin{aligned}2L_{2}&\\to L_{2}\\\\-L_{3}&\\to L_{3}\\end{aligned}}} [ 2 1 0 7 0 1 0 3 0 0 1 − 1 ] {\\displaystyle \\left[{\\begin{array}{rrr|r}2&1&0&7\\\\0&1&0&3\\\\0&0&1&-1\\end{array}}\\right]} x = 2 y = 3 z = − 1 {\\displaystyle {\\begin{alignedat}{4}x&\\quad &&\\quad &&{}={}&2&\\\\&\\quad &y&\\quad &&{}={}&3&\\\\&\\quad &&\\quad &z&{}={}&-1&\\end{alignedat}}} L 1 − L 2 → L 1 1 2 L 1 → L 1 {\\displaystyle",
    "source_url": "https://en.wikipedia.org/wiki/Gauss%E2%80%93Jordan_elimination",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:16.668139",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:16.669137",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:16.669137",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Floyd–Warshall_algorithm&oldid=1291762042_1_1749015380024_1737",
    "text": "Further consider a function s h o r t e s t P a t h ( i , j , k ) {\\displaystyle \\mathrm {shortestPath} (i,j,k)} that returns the length of the shortest possible path (if one exists) from i {\\displaystyle i} to j {\\displaystyle j} using vertices only from the set { 1 , 2 , … , k } {\\displaystyle \\{1,2,\\ldots ,k\\}} as intermediate points along the way. Now, given this function, our goal is to find the length of the shortest path from each i {\\displaystyle i} to each j {\\displaystyle j} using any vertex in { 1 , 2 , … , N } {\\displaystyle \\{1,2,\\ldots ,N\\}} . By definition, this is the value s h o r t e s t P a t h ( i , j , N ) {\\displaystyle \\mathrm {shortestPath} (i,j,N)} , which we will find recursively .",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Floyd–Warshall_algorithm&oldid=1291762042",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:20.024766",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:20.024766",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:20.024766",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Floyd–Warshall_algorithm&oldid=1291762042_1_1749015380058_7175",
    "text": "{\\displaystyle \\mathrm {shortestPath} (i,j,N)} , which we will find recursively . Observe that s h o r t e s t P a t h ( i , j , k ) {\\displaystyle \\mathrm {shortestPath} (i,j,k)} must be less than or equal to s h o r t e s t P a t h ( i , j , k − 1 ) {\\displaystyle \\mathrm {shortestPath} (i,j,k-1)} : we have more flexibility if we are allowed to use the vertex k {\\displaystyle k} . If s h o r t e s t P a t h ( i , j , k ) {\\displaystyle \\mathrm {shortestPath} (i,j,k)} is in fact less than s h o r t e s t P a t h ( i , j , k − 1 ) {\\displaystyle \\mathrm {shortestPath} (i,j,k-1)} , then there must be a path from i {\\displaystyle i} to j {\\displaystyle j} using the vertices { 1 , 2 , … , k } {\\displaystyle \\{1,2,\\ldots ,k\\}} that is shorter than any such path that does not use the vertex k {\\displaystyle k} .",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Floyd–Warshall_algorithm&oldid=1291762042",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:20.058768",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:20.058768",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:20.058768",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Floyd–Warshall_algorithm&oldid=1291762042_1_1749015380099_1201",
    "text": "Since there are no negative cycles this path can be decomposed as: (1) a path from i {\\displaystyle i} to k {\\displaystyle k} that uses the vertices { 1 , 2 , … , k − 1 } {\\displaystyle \\{1,2,\\ldots ,k-1\\}} , followed by (2) a path from k {\\displaystyle k} to j {\\displaystyle j} that uses the vertices { 1 , 2 , … , k − 1 } {\\displaystyle \\{1,2,\\ldots ,k-1\\}} . And of course, these must be a shortest such path (or several of them), otherwise we could further decrease the length. In other words, we have arrived at the recursive formula: s h o r t e s t P a t h ( i , j , k ) = {\\displaystyle \\mathrm {shortestPath} (i,j,k)=} m i n ( s h o r t e s t P a t h ( i , j , k − 1 ) , {\\displaystyle \\mathrm {min} {\\Big (}\\mathrm {shortestPath} (i,j,k-1),} s h o r t e s t P a t h ( i , k , k − 1 ) + s h o r t e s t P a t h ( k , j , k − 1 ) ) {\\displaystyle \\mathrm {shortestPath} (i,k,k-1)+\\mathrm {shortestPath} (k,j,k-1){\\Big )}} . The base case is given by s h o r t e s t P a t h ( i , j , 0 )",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Floyd–Warshall_algorithm&oldid=1291762042",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:20.099076",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:20.099076",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:20.099076",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Floyd–Warshall_algorithm&oldid=1291762042_1_1749015380678_4369",
    "text": "At k = 2 , paths going through the vertices {1,2} are found. The red and blue boxes show how the path [4,2,1,3] is assembled from the two known paths [4,2] and [2,1,3] encountered in previous iterations, with 2 in the intersection. The path [4,2,3] is not considered, because [2,1,3] is the shortest path encountered so far from 2 to 3. At k = 3 , paths going through the vertices {1,2,3} are found. Finally, at k = 4 , all shortest paths are found. The distance matrix at each iteration of k , with the updated distances in bold , will be: k = 0 j 1 2 3 4 i 1 0 ∞ −2 ∞ 2 4 0 3 ∞ 3 ∞ ∞ 0 2 4 ∞ −1 ∞ 0 k = 1 j 1 2 3 4 i 1 0 ∞ −2 ∞ 2 4 0 2 ∞ 3 ∞ ∞ 0 2 4 ∞ −1 ∞ 0 k = 2 j 1 2 3 4 i 1 0 ∞ −2 ∞ 2 4 0 2 ∞ 3 ∞ ∞ 0 2 4 3 −1 1 0 k = 3 j 1 2 3 4 i 1 0 ∞ −2 0 2 4 0 2 4 3 ∞ ∞ 0 2 4 3 −1 1 0 k = 4 j 1 2 3 4 i 1 0 −1 −2 0 2 4 0 2 4 3 5 1 0 2 4 3 −1 1 0 Behavior with negative cycles [ edit ] A negative cycle is a cycle whose edges sum to a negative value.",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Floyd–Warshall_algorithm&oldid=1291762042",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:20.678154",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:20.678154",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:20.678154",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_ID3_algorithm_1_1749015385949_1379",
    "text": "Entropy in information theory measures how much information is expected to be gained upon measuring a random variable ; as such, it can also be used to quantify the amount to which the distribution of the quantity's values is unknown. A constant quantity has zero entropy, as its distribution is perfectly known . In contrast, a uniformly distributed random variable ( discretely or continuously uniform) maximizes entropy. Therefore, the greater the entropy at a node, the less information is known about the classification of data at this stage of the tree; and therefore, the greater the potential to improve the classification here. As such, ID3 is a greedy heuristic performing a best-first search for locally optimal entropy values. Its accuracy can be improved by preprocessing the data.",
    "source_url": "https://en.wikipedia.org/wiki/ID3_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:25.949531",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:25.949531",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:25.949531",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_ID3_algorithm_1_1749015385973_6267",
    "text": "Its accuracy can be improved by preprocessing the data. Information gain [ edit ] Information gain I G ( A ) {\\displaystyle IG(A)} is the measure of the difference in entropy from before to after the set S {\\displaystyle S} is split on an attribute A {\\displaystyle A} . In other words, how much uncertainty in S {\\displaystyle S} was reduced after splitting set S {\\displaystyle S} on attribute A {\\displaystyle A} . I G ( S , A ) = H ( S ) − ∑ t ∈ T p ( t ) H ( t ) = H ( S ) − H ( S | A ) . {\\displaystyle IG(S,A)=\\mathrm {H} {(S)}-\\sum _{t\\in T}p(t)\\mathrm {H} {(t)}=\\mathrm {H} {(S)}-\\mathrm {H} {(S|A)}.}",
    "source_url": "https://en.wikipedia.org/wiki/ID3_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:25.973524",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:25.973524",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:25.973524",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Greedy_algorithm_for_Egyptian_fractions_1_1749015389049_6433",
    "text": "[ 2 ] He includes the greedy method as a last resort for situations when several simpler methods fail; see Egyptian fraction for a more detailed listing of these methods. The greedy method, and extensions of it for the approximation of irrational numbers, have been rediscovered several times by modern mathematicians, [ 3 ] earliest and most notably by J. J. Sylvester ( 1880 ) [ 4 ] A closely related expansion method that produces closer approximations at each step by allowing some unit fractions in the sum to be negative dates back to Lambert (1770) . The expansion produced by this method for a number x {\\displaystyle x} is called the greedy Egyptian expansion , Sylvester expansion , or Fibonacci–Sylvester expansion of x {\\displaystyle x} . However, the term Fibonacci expansion usually refers, not to this method, but to representation of integers as sums of Fibonacci numbers .",
    "source_url": "https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:29.049309",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:29.049309",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:29.049309",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Greedy_algorithm_for_Egyptian_fractions_1_1749015389120_6913",
    "text": "−15 mod 7 / 15 × 3 ⁠ = ⁠ 6 / 45 ⁠ . The denominator of the second unit fraction, 8, is the result of rounding ⁠ 15 / 2 ⁠ up to the next larger integer, and the remaining fraction ⁠ 1 / 120 ⁠ is what is left from ⁠ 7 / 15 ⁠ after subtracting both ⁠ 1 / 3 ⁠ and ⁠ 1 / 8 ⁠ . As each expansion step reduces the numerator of the remaining fraction to be expanded, this method always terminates with a finite expansion; however, compared to ancient Egyptian expansions or to more modern methods, this method may produce expansions that are quite long, with large denominators. For instance, this method expands 5 121 = 1 25 + 1 757 + 1 763 309 + 1 873 960 180 913 + 1 1 527 612 795 642 093 418 846 225 , {\\displaystyle {\\frac {5}{121}}={\\frac {1}{25}}+{\\frac {1}{757}}+{\\frac {1}{763\\,309}}+{\\frac {1}{873\\,960\\,180\\,913}}+{\\frac {1}{1\\,527\\,612\\,795\\,642\\,093\\,418\\,846\\,225}},} while other methods lead to the much better expansion 5 121 = 1 33 + 1 121 + 1 363 .",
    "source_url": "https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:29.120934",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:29.121934",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:29.121934",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Greedy_algorithm_for_Egyptian_fractions_1_1749015389145_4541",
    "text": "{\\displaystyle {\\frac {5}{121}}={\\frac {1}{33}}+{\\frac {1}{121}}+{\\frac {1}{363}}.} Wagon (1991) suggests an even more badly-behaved example, ⁠ 31 / 311 ⁠ . The greedy method leads to an expansion with ten terms, the last of which has over 500 digits in its denominator; however, ⁠ 31 / 311 ⁠ has a much shorter non-greedy representation, ⁠ 1 / 12 ⁠ + ⁠ 1 / 63 ⁠ + ⁠ 1 / 2799 ⁠ + ⁠ 1 / 8708 ⁠ . Sylvester's sequence and closest approximation [ edit ] Sylvester's sequence 2, 3, 7, 43, 1807, ... ( OEIS : A000058 ) can be viewed as generated by an infinite greedy expansion of this type for the number 1, where at each step we choose the denominator ⌊ ⁠ y / x ⁠ ⌋ + 1 instead of ⌈ ⁠ y / x ⁠ ⌉ .",
    "source_url": "https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:29.145942",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:29.145942",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:29.145942",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Greedy_algorithm_for_Egyptian_fractions_1_1749015389174_8506",
    "text": "y / x ⁠ ⌋ + 1 instead of ⌈ ⁠ y / x ⁠ ⌉ . Truncating this sequence to k terms and forming the corresponding Egyptian fraction, e.g. (for k = 4) 1 2 + 1 3 + 1 7 + 1 43 = 1805 1806 {\\displaystyle {\\frac {1}{2}}+{\\frac {1}{3}}+{\\frac {1}{7}}+{\\frac {1}{43}}={\\frac {1805}{1806}}} results in the closest possible underestimate of 1 by any k -term Egyptian fraction. [ 5 ] That is, for example, any Egyptian fraction for a number in the open interval ( ⁠ 1805 / 1806 ⁠ , 1) requires at least five terms. Curtiss (1922) describes an application of these closest-approximation results in lower-bounding the number of divisors of a perfect number , while Stong (1983) describes applications in group theory . Maximum-length expansions and congruence conditions [ edit ] Any fraction ⁠ x / y ⁠ requires at most x terms in its greedy expansion.",
    "source_url": "https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:29.174956",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:29.175948",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:29.175948",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Greedy_algorithm_for_Egyptian_fractions_1_1749015389208_5689",
    "text": "Any fraction ⁠ x / y ⁠ requires at most x terms in its greedy expansion. Mays (1987) and Freitag & Phillips (1999) examine the conditions under which the greedy method produces an expansion of ⁠ x / y ⁠ with exactly x terms; these can be described in terms of congruence conditions on y . Every fraction ⁠ 1 / y ⁠ requires one term in its greedy expansion; the simplest such fraction is ⁠ 1 / 1 ⁠ . Every fraction ⁠ 2 / y ⁠ requires two terms in its greedy expansion if and only if y ≡ 1 (mod 2) ; the simplest such fraction is ⁠ 2 / 3 ⁠ . A fraction ⁠ 3 / y ⁠ requires three terms in its greedy expansion if and only if y ≡ 1 (mod 6) , for then − y mod x = 2 and ⁠ y ( y + 2) / 3 ⁠ is odd, so the  fraction remaining after a single step of the greedy expansion, ( − y ) mod x y ⌈ y x ⌉ = 2 y ( y + 2 ) 3 {\\displaystyle {\\frac {(-y){\\bmod {x}}}{y\\left\\lceil {\\frac {y}{x}}\\right\\rceil }}={\\frac {2}{\\,{\\frac {y(y+2)}{3}}\\,}}} is in simplest terms.",
    "source_url": "https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:29.208985",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:29.208985",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:29.208985",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Greedy_algorithm_for_Egyptian_fractions_1_1749015389375_4318",
    "text": "= 0 , which can be expanded as P 2 ( x 2 ) = 4 x 2 2 + 8 x 2 − 1 = 0 . Since P 2 ( x ) < 0 for x = ⁠ 1 / 9 ⁠ , and P 2 ( x ) > 0 for all x > ⁠ 1 / 8 ⁠ , the next term in the greedy expansion is ⁠ 1 / 9 ⁠ . If x 3 is the remaining fraction after this step of the greedy expansion, it satisfies the equation P 2 ( x 3 + ⁠ 1 / 9 ⁠ ) = 0 , which can again be expanded as a polynomial equation with integer coefficients, P 3 ( x 3 ) = 324 x 2 3 + 720 x 3 − 5 = 0 . Continuing this approximation process eventually produces the greedy expansion for the golden ratio, φ = 1 1 + 1 2 + 1 9 + 1 145 + 1 37986 + ⋯ {\\displaystyle \\varphi ={\\frac {1}{1}}+{\\frac {1}{2}}+{\\frac {1}{9}}+{\\frac {1}{145}}+{\\frac {1}{37986}}+\\cdots } (sequence A117116 in the OEIS ).",
    "source_url": "https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:29.375912",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:29.375912",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:29.375912",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Greedy_algorithm_for_Egyptian_fractions&oldid=1262148275_1_1749015390313_6508",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by David Eppstein ( talk | contribs ) at 21:40, 9 December 2024 (Undid revision 1262126925 by 178.202.191.116 ( talk ) the method for constructing these does not depend on your representation) . The present address (URL) is a permanent link to this version. Revision as of 21:40, 9 December 2024 by David Eppstein ( talk | contribs ) (Undid revision 1262126925 by 178.202.191.116 ( talk ) the ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Greedy_algorithm_for_Egyptian_fractions&oldid=1262148275",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:30.313953",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:30.313953",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:30.313953",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Combinatorial_algorithms&oldid=975668794_1_1749015396153_1079",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Mike Peel ( talk | contribs ) at 19:38, 29 August 2020 (Change {{Commons}} to {{Commons category}}) . The present address (URL) is a permanent link to this version. Revision as of 19:38, 29 August 2020 by Mike Peel ( talk | contribs ) (Change {{Commons}} to {{Commons category}}) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Wikimedia Commons has med",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Combinatorial_algorithms&oldid=975668794",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:36.153890",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:36.153890",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:36.153890",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Clonal_selection_algorithm&oldid=1292509306_1_1749015404161_5868",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by GreenC bot ( talk | contribs ) at 09:43, 27 May 2025 (Move 1 url. Wayback Medic 2.5 per WP:URLREQ#citeftp ) . The present address (URL) is a permanent link to this version. Revision as of 09:43, 27 May 2025 by GreenC bot ( talk | contribs ) (Move 1 url. Wayback Medic 2.5 per WP:URLREQ#citeftp ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Part of a seri",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Clonal_selection_algorithm&oldid=1292509306",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:44.161180",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:44.162180",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:44.162180",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Fly_algorithm_1_1749015405974_3868",
    "text": "Jump to content From Wikipedia, the free encyclopedia A major contributor to this article appears to have a close connection with its subject. It may require cleanup to comply with Wikipedia's content policies, particularly neutral point of view . Please discuss further on the talk page . ( July 2018 )",
    "source_url": "https://en.wikipedia.org/wiki/Fly_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:45.974923",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:45.974923",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:45.974923",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Fly_algorithm_1_1749015406186_7431",
    "text": "Here, the fitness of one individual is calculated as its (positive or negative) contribution to the quality of the global population. It is based on the leave-one-out cross-validation principle. A global fitness function evaluates the quality of the population as a whole; only then the fitness of an individual (a fly) is calculated as the difference between the global fitness values of the population with and without the particular fly whose individual fitness function has to be evaluated. [ 13 ] [ 14 ] In [ 15 ] the fitness of each fly is considered as a `level of confidence'. It is used during the voxelisation process to tweak the fly's individual footprint using implicit modelling (such as metaballs ). It produces smooth results that are more accurate. More recently it has been used in digital art to generate mosaic-like images or spray paint.",
    "source_url": "https://en.wikipedia.org/wiki/Fly_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:46.186017",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:46.186017",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:46.186017",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Fly_algorithm&oldid=1257060134_1_1749015408511_9819",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Fieari ( talk | contribs ) at 01:15, 13 November 2024 (adding lead, removing \"lead missing\" tag.) . The present address (URL) is a permanent link to this version. Revision as of 01:15, 13 November 2024 by Fieari ( talk | contribs ) (adding lead, removing \"lead missing\" tag.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) A major contributor to this articl",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Fly_algorithm&oldid=1257060134",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:48.511536",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:48.512538",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:48.512538",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Memetic_algorithm_1_1749015412132_4328",
    "text": "Compute the fitness f ( p ) ∀ p ∈ P ( t ) {\\displaystyle f(p)\\ \\ \\forall p\\in P(t)} ; while Stopping conditions are not satisfied do Selection: Accordingly to f ( p ) {\\displaystyle f(p)} choose a subset of P ( t ) {\\displaystyle P(t)} and store it in M ( t ) {\\displaystyle M(t)} ;",
    "source_url": "https://en.wikipedia.org/wiki/Memetic_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:52.132662",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:52.133655",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:52.133655",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Memetic_algorithm_1_1749015412165_7835",
    "text": "Offspring: Recombine and mutate individuals p ∈ M ( t ) {\\displaystyle p\\in M(t)} and store them in M ′ ( t ) {\\displaystyle M'(t)} ; Learning: Improve p ′ {\\displaystyle p'} by local search or heuristic ∀ p ′ ∈ M ′ ( t ) {\\displaystyle \\forall p'\\in M'(t)} ; Evaluation: Compute the fitness f ( p ′ ) ∀ p ′ ∈ M ′ ( t ) {\\displaystyle f(p')\\ \\ \\forall p'\\in M'(t)} ; if Lamarckian learning then Update chromosome of p ′ {\\displaystyle p'} according to improvement ∀ p ′ ∈ M ′ ( t ) {\\displaystyle \\forall p'\\in M'(t)} ; fi New generation: Generate P ( t + 1 ) {\\displaystyle P(t+1)} by selecting some individuals from P ( t ) {\\displaystyle P(t)} and M ′ ( t ) {\\displaystyle M'(t)} ; t = t + 1 {\\displaystyle t=t+1} ;  // Increment the generation counter end while Return best individual p ∈ P ( t − 1 ) {\\displaystyle p\\in P(t-1)} as result; There are some alternatives for this MA scheme. For example: All or some of the initial individuals may be improved by the meme(s).",
    "source_url": "https://en.wikipedia.org/wiki/Memetic_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:52.165656",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:52.165656",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:52.165656",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Memetic_algorithm_1_1749015412191_1739",
    "text": "For example: All or some of the initial individuals may be improved by the meme(s). The parents may be locally improved instead of the offspring. Instead of all offspring, only a randomly selected or fitness-dependent fraction may undergo local improvement. The latter requires the evaluation of the offspring in M ′ ( t ) {\\displaystyle M'(t)} prior to the Learning step. 2nd generation [ edit ] Multi-meme, [ 10 ] hyper-heuristic [ 11 ] [ 12 ] and meta-Lamarckian MA [ 13 ] [ 14 ] are referred to as second generation MA exhibiting the principles of memetic transmission and selection in their design. In Multi-meme MA, the memetic material is encoded as part of the genotype . Subsequently, the decoded meme of each respective individual/ chromosome is then used to perform a local refinement. The memetic material is then transmitted through a simple inheritance mechanism from parent to offspring(s).",
    "source_url": "https://en.wikipedia.org/wiki/Memetic_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:52.191165",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:52.191165",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:52.191165",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Memetic_algorithm&oldid=1291714861_1_1749015414337_5725",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 23:01, 22 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 23:01, 22 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Algo",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Memetic_algorithm&oldid=1291714861",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:54.337635",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:54.337635",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:54.337635",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Crossover_(genetic_algorithm)_1_1749015418474_1794",
    "text": "This strategy can be generalized to k-point crossover for any positive integer k, picking k crossover points. Uniform crossover [ edit ] In uniform crossover, typically, each bit is chosen from either parent with equal probability. [ 6 ] Other mixing ratios are sometimes used, resulting in offspring which inherit more genetic information from one parent than the other. In a uniform crossover, we don’t divide the chromosome into segments, rather we treat each gene separately. In this, we essentially flip a coin for each chromosome to decide whether or not it will be included in the off-spring. Crossover for integer or real-valued genomes [ edit ] Example of a discrete recombination in the three-dimensional case. The two possible offspring lie on the corners of the cuboid marked in blue.",
    "source_url": "https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:58.474422",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:58.474422",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:58.474422",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Crossover_(genetic_algorithm)_1_1749015418499_1307",
    "text": "The two possible offspring lie on the corners of the cuboid marked in blue. For the crossover operators presented above and for most other crossover operators for bit strings, it holds that they can also be applied accordingly to integer or real-valued genomes whose genes each consist of an integer or real-valued number. Instead of individual bits, integer or real-valued numbers are then simply copied into the child genome. The offspring lie on the remaining corners of the hyperbody spanned by the two parents P 1 = ( 1.5 , 6 , 8 ) {\\displaystyle P_{1}=(1.5,6,8)} and P 2 = ( 7 , 2 , 1 ) {\\displaystyle P_{2}=(7,2,1)} , as exemplified in the accompanying image for the three-dimensional case. Discrete recombination [ edit ] If the rules of the uniform crossover for bit strings are applied during the generation of the offspring, this is also called discrete recombination .",
    "source_url": "https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:58.499434",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:58.499434",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:58.499434",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Crossover_(genetic_algorithm)_1_1749015418578_7041",
    "text": "= ( 9 , 2 ) {\\displaystyle P_{2}=(9,2)} in intermediate recombination. The offspring of discrete recombination C 1 {\\displaystyle C_{1}} and C 2 {\\displaystyle C_{2}} are also plotted. Intermediate recombination satisfies the arithmetic calculation of the allele values of the child genome required by virtual alphabet theory. [ 10 ] [ 11 ] Discrete and intermediate recombination are used as a standard in the evolution strategy . [ 12 ] Crossover for permutations [ edit ] For combinatorial tasks , permutations are usually used that are specifically designed for genomes that are themselves permutations of a set . The underlying set is usually a subset of N {\\displaystyle \\mathbb {N} } or N 0 {\\displaystyle \\mathbb {N} _{0}} . If 1- or n-point or uniform crossover for integer genomes is used for such genomes, a child genome may contain some values twice and others may be missing.",
    "source_url": "https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:58.578303",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:58.578303",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:58.578303",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Crossover_(genetic_algorithm)_1_1749015418602_9147",
    "text": "This can be remedied by genetic repair , e.g. by replacing the redundant genes in positional fidelity for missing ones from the other child genome. In order to avoid the generation of invalid offspring, special crossover operators for permutations have been developed [ 13 ] which fulfill the basic requirements of such operators for permutations, namely that all elements of the initial permutation are also present in the new one and only the order is changed. It can be distinguished between combinatorial tasks, where all sequences are admissible, and those where there are constraints in the form of inadmissible partial sequences. A well-known representative of the first task type is the traveling salesman problem (TSP), where the goal is to visit a set of cities exactly once on the shortest tour. An example of the constrained task type is the scheduling of multiple workflows . Workflows involve sequence constraints on some of the individual work steps.",
    "source_url": "https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:58.602315",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:58.602315",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:58.602315",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Crossover_(genetic_algorithm)_1_1749015418629_1885",
    "text": "Workflows involve sequence constraints on some of the individual work steps. For example, a thread cannot be cut until the corresponding hole has been drilled in a workpiece. Such problems are also called order-based permutations . In the following, two crossover operators are presented as examples, the partially mapped crossover (PMX) motivated by the TSP and the order crossover (OX1) designed for order-based permutations. A second offspring can be produced in each case by exchanging the parent chromosomes. Partially mapped crossover (PMX) [ edit ] The PMX operator was designed as a recombination operator for TSP like Problems. [ 14 ] [ 15 ] The explanation of the procedure is illustrated by an example: Procedure Example Example Chromosome Let be given two permutations of the same set. P 0 = ( A , B , C , D , E , F , G , H ) {\\displaystyle P_{0}=\\left(A,B,C,D,E,F,G,H\\right)} and P 1",
    "source_url": "https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:36:58.629629",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:36:58.629629",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:36:58.629629",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Crossover_(evolutionary_algorithm)&oldid=1291490454_1_1749015420164_7378",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 15:29, 21 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 15:29, 21 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Oper",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Crossover_(evolutionary_algorithm)&oldid=1291490454",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:00.164721",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:00.164721",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:00.164721",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mutation_(genetic_algorithm)_1_1749015422381_2756",
    "text": "This reasoning also leads most EAs to avoid only taking the fittest of the population in generating the next generation, but rather selecting a random (or semi-random) set with a weighting toward those that are fitter. [ 1 ] The following requirements apply to all mutation operators used in an EA: [ 2 ] [ 3 ] every point in the search space must be reachable by one or more mutations. there must be no preference for parts or directions in the search space (no drift). small mutations should be more probable than large ones. For different genome types, different mutation types are suitable. Some mutations are Gaussian, Uniform, Zigzag, Scramble, Insertion, Inversion, Swap, and so on. [ 4 ] [ 5 ] [ 6 ] An overview and more operators than those presented below can be found in the introductory book by Eiben and Smith [ 7 ] or in. [ 3 ] [ 8 ] Bit string mutation [ edit ] The mutation of bit strings ensue through bit flips at random positions. Example: 1 0 1 0 0 1 0 ↓ 1 0 1 0 1 1 0",
    "source_url": "https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:02.381557",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:02.382558",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:02.382558",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mutation_(genetic_algorithm)_1_1749015422451_1145",
    "text": "In practical applications, the respective value range of the decision variables to be changed of the optimisation problem to be solved is usually limited. Accordingly, the values of the associated genes are each restricted to an interval [ x min , x max ] {\\displaystyle [x_{\\min },x_{\\max }]} . Mutations may or may not take these restrictions into account. In the latter case, suitable post-treatment is then required as described below. Mutation without consideration of restrictions [ edit ] Example of a normally distributed random variable. Note that the given proportions of the subranges add up to 99.8 % and not 100 % due to rounding. A real number x {\\displaystyle x} can be mutated using normal distribution N ( 0 , σ ) {\\displaystyle {\\mathcal {N}}(0,\\sigma )} by adding the generated random value to the old value of the gene, resulting in the mutated value x ′ {\\displaystyle x'} : x ′ = x + N ( 0 , σ ) {\\displaystyle x'=x+{\\mathcal {N}}(0,\\sigma )}",
    "source_url": "https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:02.451236",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:02.451236",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:02.451236",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mutation_(genetic_algorithm)_1_1749015422481_5078",
    "text": "x ′ = x + N ( 0 , σ ) {\\displaystyle x'=x+{\\mathcal {N}}(0,\\sigma )} In the case of genes with a restricted range of values, it is a good idea to choose the step size of the mutation σ {\\displaystyle \\sigma } so that it reasonably fits the range [ x min , x max ] {\\displaystyle [x_{\\min },x_{\\max }]} of the gene to be changed, e.g.: σ = x max − x min 6 {\\displaystyle \\sigma ={\\frac {x_{\\text{max}}-x_{\\text{min}}}{6}}} The step size can also be adjusted to the smaller permissible change range depending on the current value. In any case, however, it is likely that the new value x ′ {\\displaystyle x'} of the gene will be outside the permissible range of values. Such a case must be considered a lethal mutation, since the obvious repair by using the respective violated limit as the new value of the gene would lead to a drift. This is because the limit value would then be selected with the entire probability of the values beyond the limit of the value range.",
    "source_url": "https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:02.481229",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:02.481229",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:02.481229",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mutation_(genetic_algorithm)_1_1749015422532_2382",
    "text": "The sub-areas each cover 1/k of the width of the total change interval. First, an equally distributed decision is made as to whether the current value x {\\displaystyle x} should be increased or decreased and then the corresponding total change interval is determined. Without loss of generality , an increase is assumed for the explanation and the total change interval is then [ x , x max ] {\\displaystyle [x,x_{\\max }]} .",
    "source_url": "https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:02.532249",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:02.532249",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:02.532249",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mutation_(genetic_algorithm)_1_1749015422562_1674",
    "text": "It is divided into k {\\displaystyle k} sub-areas of equal size with the width δ {\\displaystyle \\delta } , from which k {\\displaystyle k} sub-change intervals of different size are formed: i {\\displaystyle i} -th sub-change interval: [ x , x + δ ⋅ i ] {\\displaystyle [x,x+\\delta \\cdot i]} with δ = ( x max − x ) k {\\displaystyle \\delta ={\\frac {(x_{\\text{max}}-x)}{k}}} and i = 1 , … , k {\\displaystyle i=1,\\dots ,k} Subsequently, one of the k {\\displaystyle k} sub-change intervals is selected in equal distribution and a random number, also equally distributed, is drawn from it as the new value x ′ {\\displaystyle x'} of the gene. The resulting summed probabilities of the sub-change intervals result in the probability distribution of the k {\\displaystyle k} sub-areas shown in the adjacent figure for the exemplary case of k = 10 {\\displaystyle k=10} . This is not a normal distribution as before, but this distribution also clearly favours small changes over larger ones.",
    "source_url": "https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:02.562762",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:02.563756",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:02.563756",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Mutation_(genetic_algorithm)_1_1749015422588_5350",
    "text": "This mutation for larger values of k {\\displaystyle k} , such as 10, is less well suited for tasks where the optimum lies on one of the value range boundaries. This can be remedied by significantly reducing k {\\displaystyle k} when a gene value approaches its limits very closely. Common properties [ edit ] For both mutation operators for real-valued numbers, the probability of an increase and decrease is independent of the current value and is 50% in each case. In addition, small changes are considerably more likely than large ones. For mixed-integer optimization problems, rounding is usually used. Mutation of permutations [ edit ] Mutations of permutations are specially designed for genomes that are themselves permutations of a set . These are often used to solve combinatorial tasks. [ 8 ] [ 18 ] [ 19 ] In the two mutations presented, parts of the genome are rotated or inverted. Rotation to the right [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:02.588762",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:02.588762",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:02.588762",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Mutation_(evolutionary_algorithm)&oldid=1291758895_1_1749015424445_5836",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by OAbot ( talk | contribs ) at 06:32, 23 May 2025 ( Open access bot : url-access updated in citation with #oabot.) . The present address (URL) is a permanent link to this version. Revision as of 06:32, 23 May 2025 by OAbot ( talk | contribs ) ( Open access bot : url-access updated in citation with #oabot.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Gene",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Mutation_(evolutionary_algorithm)&oldid=1291758895",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:04.445829",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:04.445829",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:04.445829",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Estimation_of_distribution_algorithm_1_1749015426000_9545",
    "text": "= β 2 ( D ( t ) ) {\\displaystyle P(t)=\\beta _{2}(D(t))} . The population P ( t ) {\\displaystyle P(t)} is then sorted in decreasing order of fitness, S Sort ( f ) ( P ( t ) ) {\\displaystyle S_{{\\text{Sort}}(f)}(P(t))} , with u {\\displaystyle u} being the best and v {\\displaystyle v} being the worst solution. The CGA estimates univariate probabilities as follows p t + 1 ( X i ) = p t ( X i ) + γ ( u i − v i ) , ∀ i ∈ 1 , 2 , … , N , {\\displaystyle p_{t+1}(X_{i})=p_{t}(X_{i})+\\gamma (u_{i}-v_{i}),\\quad \\forall i\\in 1,2,\\dots ,N,} where, γ ∈ ( 0 , 1 ] {\\displaystyle \\gamma \\in (0,1]} is a constant defining the learning rate , usually set to γ = 1 / N {\\displaystyle \\gamma =1/N} . The CGA can be defined as D ( t + 1 ) = α CGA ∘ S Sort ( f ) ∘ β 2 ( D ( t ) ) {\\displaystyle D(t+1)=\\alpha _{\\text{CGA}}\\circ S_{{\\text{Sort}}(f)}\\circ \\beta _{2}(D(t))} Bivariate factorizations [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Estimation_of_distribution_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:06.000236",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:06.000236",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:06.000236",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Estimation_of_distribution_algorithm_1_1749015426027_7573",
    "text": "Bivariate factorizations [ edit ] Although univariate models can be computed efficiently, in many cases they are not representative enough to provide better performance than GAs. In order to overcome such a drawback, the use of bivariate factorizations was proposed in the EDA community, in which dependencies between pairs of variables could be modeled. A bivariate factorization can be defined as follows, where π i {\\displaystyle \\pi _{i}} contains a possible variable dependent to X i {\\displaystyle X_{i}} , i.e. | π i | = 1 {\\displaystyle |\\pi _{i}|=1} . D Bivariate := p ( X 1 , … , X N ) = ∏ i = 1 N p ( X i | π i ) . {\\displaystyle D_{\\text{Bivariate}}:=p(X_{1},\\dots ,X_{N})=\\prod _{i=1}^{N}p(X_{i}|\\pi _{i}).} Bivariate and multivariate distributions are usually represented as probabilistic graphical models (graphs), in which edges denote statistical dependencies (or conditional probabilities) and vertices denote variables.",
    "source_url": "https://en.wikipedia.org/wiki/Estimation_of_distribution_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:06.027974",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:06.027974",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:06.027974",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Estimation_of_distribution_algorithm_1_1749015426057_3926",
    "text": "To learn the structure of a PGM from data linkage-learning is employed. Mutual information maximizing input clustering (MIMIC) [ edit ] The MIMIC [ 8 ] factorizes the joint probability distribution in a chain-like model representing successive dependencies between variables. It finds a permutation of the decision variables, r : i ↦ j {\\displaystyle r:i\\mapsto j} , such that x r ( 1 ) x r ( 2 ) , … , x r ( N ) {\\displaystyle x_{r(1)}x_{r(2)},\\dots ,x_{r(N)}} minimizes the Kullback-Leibler divergence in relation to the true probability distribution, i.e. π r ( i + 1 ) = { X r ( i ) } {\\displaystyle \\pi _{r(i+1)}=\\{X_{r(i)}\\}} . MIMIC models a distribution p t + 1 ( X 1 , … , X N ) = p t ( X r ( N ) ) ∏ i = 1 N − 1 p t ( X r ( i ) | X r ( i + 1 ) ) . {\\displaystyle p_{t+1}(X_{1},\\dots ,X_{N})=p_{t}(X_{r(N)})\\prod _{i=1}^{N-1}p_{t}(X_{r(i)}|X_{r(i+1)}).}",
    "source_url": "https://en.wikipedia.org/wiki/Estimation_of_distribution_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:06.057995",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:06.057995",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:06.057995",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Estimation_of_distribution_algorithm&oldid=1252649421_1_1749015427604_6094",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by DancingOwl ( talk | contribs ) at 10:01, 22 October 2024 (Added ACO to the \"Related\" list) . The present address (URL) is a permanent link to this version. Revision as of 10:01, 22 October 2024 by DancingOwl ( talk | contribs ) (Added ACO to the \"Related\" list) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Family of stochastic optimization methods Estima",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Estimation_of_distribution_algorithm&oldid=1252649421",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:07.604513",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:07.604513",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:07.604513",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=List_of_genetic_algorithm_applications&oldid=1285987126_1_1749015431207_6566",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Citation bot ( talk | contribs ) at 00:43, 17 April 2025 (Added bibcode. Removed URL that duplicated identifier. | Use this bot . Report bugs . | Suggested by Dominic3203 | Linked from User:LinguisticMystic/cs/outline | #UCB_webform_linked 1186/2277) . The present address (URL) is a permanent link to this version. Revision as of 00:43, 17 April 2025 by Citation bot ( talk | contribs ) (A",
    "source_url": "https://en.wikipedia.org/w/index.php?title=List_of_genetic_algorithm_applications&oldid=1285987126",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:11.207351",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:11.207351",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:11.208351",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Estimation_of_Distribution_Algorithm_1_1749015438074_3679",
    "text": "= β 2 ( D ( t ) ) {\\displaystyle P(t)=\\beta _{2}(D(t))} . The population P ( t ) {\\displaystyle P(t)} is then sorted in decreasing order of fitness, S Sort ( f ) ( P ( t ) ) {\\displaystyle S_{{\\text{Sort}}(f)}(P(t))} , with u {\\displaystyle u} being the best and v {\\displaystyle v} being the worst solution. The CGA estimates univariate probabilities as follows p t + 1 ( X i ) = p t ( X i ) + γ ( u i − v i ) , ∀ i ∈ 1 , 2 , … , N , {\\displaystyle p_{t+1}(X_{i})=p_{t}(X_{i})+\\gamma (u_{i}-v_{i}),\\quad \\forall i\\in 1,2,\\dots ,N,} where, γ ∈ ( 0 , 1 ] {\\displaystyle \\gamma \\in (0,1]} is a constant defining the learning rate , usually set to γ = 1 / N {\\displaystyle \\gamma =1/N} . The CGA can be defined as D ( t + 1 ) = α CGA ∘ S Sort ( f ) ∘ β 2 ( D ( t ) ) {\\displaystyle D(t+1)=\\alpha _{\\text{CGA}}\\circ S_{{\\text{Sort}}(f)}\\circ \\beta _{2}(D(t))} Bivariate factorizations [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Estimation_of_Distribution_Algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:18.074535",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:18.074535",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:18.074535",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Estimation_of_Distribution_Algorithm_1_1749015438101_9876",
    "text": "Bivariate factorizations [ edit ] Although univariate models can be computed efficiently, in many cases they are not representative enough to provide better performance than GAs. In order to overcome such a drawback, the use of bivariate factorizations was proposed in the EDA community, in which dependencies between pairs of variables could be modeled. A bivariate factorization can be defined as follows, where π i {\\displaystyle \\pi _{i}} contains a possible variable dependent to X i {\\displaystyle X_{i}} , i.e. | π i | = 1 {\\displaystyle |\\pi _{i}|=1} . D Bivariate := p ( X 1 , … , X N ) = ∏ i = 1 N p ( X i | π i ) . {\\displaystyle D_{\\text{Bivariate}}:=p(X_{1},\\dots ,X_{N})=\\prod _{i=1}^{N}p(X_{i}|\\pi _{i}).} Bivariate and multivariate distributions are usually represented as probabilistic graphical models (graphs), in which edges denote statistical dependencies (or conditional probabilities) and vertices denote variables.",
    "source_url": "https://en.wikipedia.org/wiki/Estimation_of_Distribution_Algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:18.101692",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:18.101692",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:18.101692",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Estimation_of_Distribution_Algorithm_1_1749015438130_5517",
    "text": "To learn the structure of a PGM from data linkage-learning is employed. Mutual information maximizing input clustering (MIMIC) [ edit ] The MIMIC [ 8 ] factorizes the joint probability distribution in a chain-like model representing successive dependencies between variables. It finds a permutation of the decision variables, r : i ↦ j {\\displaystyle r:i\\mapsto j} , such that x r ( 1 ) x r ( 2 ) , … , x r ( N ) {\\displaystyle x_{r(1)}x_{r(2)},\\dots ,x_{r(N)}} minimizes the Kullback-Leibler divergence in relation to the true probability distribution, i.e. π r ( i + 1 ) = { X r ( i ) } {\\displaystyle \\pi _{r(i+1)}=\\{X_{r(i)}\\}} . MIMIC models a distribution p t + 1 ( X 1 , … , X N ) = p t ( X r ( N ) ) ∏ i = 1 N − 1 p t ( X r ( i ) | X r ( i + 1 ) ) . {\\displaystyle p_{t+1}(X_{1},\\dots ,X_{N})=p_{t}(X_{r(N)})\\prod _{i=1}^{N-1}p_{t}(X_{r(i)}|X_{r(i+1)}).}",
    "source_url": "https://en.wikipedia.org/wiki/Estimation_of_Distribution_Algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:18.130839",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:18.130839",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:18.130839",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Particle_filter_1_1749015450091_4575",
    "text": "In contrast, the Markov Chain Monte Carlo or importance sampling approach would model the full posterior p ( x 0 , x 1 , . . . , x k | y 0 , y 1 , . . . , y k ) {\\displaystyle p(x_{0},x_{1},...,x_{k}|y_{0},y_{1},...,y_{k})} . The Signal-Observation model [ edit ] Particle methods often assume X k {\\displaystyle X_{k}} and the observations Y k {\\displaystyle Y_{k}} can be modeled in this form: X 0 , X 1 , ⋯ {\\displaystyle X_{0},X_{1},\\cdots } is a Markov process on R d x {\\displaystyle \\mathbb {R} ^{d_{x}}} (for some d x ⩾ 1 {\\displaystyle d_{x}\\geqslant 1} ) that evolves according to the transition probability density p ( x k | x k − 1 ) {\\displaystyle p(x_{k}|x_{k-1})} . This model is also often written in a synthetic way as X k | X k − 1 = x k ∼ p ( x k | x k − 1 ) {\\displaystyle X_{k}|X_{k-1}=x_{k}\\sim p(x_{k}|x_{k-1})} with an initial probability density p ( x 0 ) {\\displaystyle p(x_{0})} .",
    "source_url": "https://en.wikipedia.org/wiki/Particle_filter",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:30.091971",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:30.091971",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:30.091971",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Particle_filter_1_1749015450119_4833",
    "text": "W k − 1 {\\displaystyle X_{k}=g(X_{k-1})+W_{k-1}} Y k = h ( X k ) + V k {\\displaystyle Y_{k}=h(X_{k})+V_{k}} where both W k {\\displaystyle W_{k}} and V k {\\displaystyle V_{k}} are mutually independent sequences with known probability density functions and g and h are known functions. These two equations can be viewed as state space equations and look similar to the state space equations for the Kalman filter. If the functions g and h in the above example are linear, and if both W k {\\displaystyle W_{k}} and V k {\\displaystyle V_{k}} are Gaussian , the Kalman filter finds the exact Bayesian filtering distribution. If not, Kalman filter-based methods are a first-order approximation ( EKF ) or a second-order approximation ( UKF in general, but if the probability distribution is Gaussian a third-order approximation is possible). The assumption that the initial distribution and the transitions of the Markov chain are continuous for the Lebesgue measure can be relaxed.",
    "source_url": "https://en.wikipedia.org/wiki/Particle_filter",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:30.119338",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:30.119675",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:30.119675",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Particle_filter_1_1749015450144_4131",
    "text": "[ 19 ] In this situation, an additional level of approximation is necessitated. One strategy is to replace the signal X k {\\displaystyle X_{k}} by the Markov chain X k = ( X k , Y k ) {\\displaystyle {\\mathcal {X}}_{k}=\\left(X_{k},Y_{k}\\right)} and to introduce a virtual observation of the form Y k = Y k + ϵ V k for some parameter ϵ ∈ [ 0 , 1 ] {\\displaystyle {\\mathcal {Y}}_{k}=Y_{k}+\\epsilon {\\mathcal {V}}_{k}\\quad {\\mbox{for some parameter}}\\quad \\epsilon \\in [0,1]} for some sequence of independent random variables V k {\\displaystyle {\\mathcal {V}}_{k}} with known probability density functions . The central idea is to observe that Law ( X k | Y 0 = y 0 , ⋯ , Y k = y k ) ≈ ϵ ↓ 0 Law ( X k | Y 0",
    "source_url": "https://en.wikipedia.org/wiki/Particle_filter",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:30.144179",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:30.144179",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:30.144179",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Cellular_evolutionary_algorithm_1_1749015453476_1178",
    "text": "The overlap of the neighborhoods provides an implicit mechanism of solution migration\nto the cEA. Since the best solutions spread smoothly through the\nwhole population, genetic diversity in the population is preserved longer than\nin non structured EAs. This soft dispersion of the best solutions through the\npopulation is one of the main issues of the good tradeoff between exploration and exploitation that cEAs perform during the search. This tradeoff can be tuned (and by extension the genetic diversity level along\nthe evolution) by modifying (for instance) the size of the neighborhood used, as\nthe overlap degree between the neighborhoods grows according to the size of\nthe neighborhood. A cEA can be seen as a cellular automaton (CA) with probabilistic\nrewritable rules, where the alphabet of the CA is equivalent to the potential\nnumber of solutions of the problem. Hence, knowledge from research in CAs can be applied to cEAs.",
    "source_url": "https://en.wikipedia.org/wiki/Cellular_evolutionary_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:33.476702",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:33.476702",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:33.476702",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Cellular_evolutionary_algorithm&oldid=1286739290_1_1749015454341_6589",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Ourobosch ( talk | contribs ) at 18:04, 21 April 2025 (Some rewriting to increase formality and clarity.) . The present address (URL) is a permanent link to this version. Revision as of 18:04, 21 April 2025 by Ourobosch ( talk | contribs ) (Some rewriting to increase formality and clarity.) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Kind of evolutiona",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Cellular_evolutionary_algorithm&oldid=1286739290",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:34.341319",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:34.341319",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:34.341319",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bees_algorithm_1_1749015455572_6474",
    "text": "In the initialisation routine ns scout bees are randomly placed in the search space, and evaluate the fitness of the solutions where they land. For each solution, a neighbourhood (called flower patch) is delimited. In the recruitment procedure, the scouts that visited the nb ≤ ns fittest solutions (best sites) perform the waggle dance. That is, they recruit foragers to search further the neighbourhoods of the most promising solutions. The scouts that located the very best ne ≤ nb solutions (elite sites) recruit nre foragers each, whilst the remaining nb - ne scouts recruit nrb ≤ nre foragers each. Thus, the number of foragers recruited depends on the profitability of the food source. In the local search procedure, the recruited foragers are randomly scattered within the flower patches enclosing the solutions visited by the scouts (local exploitation).",
    "source_url": "https://en.wikipedia.org/wiki/Bees_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:35.572191",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:35.572191",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:35.572191",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bees_algorithm_1_1749015455598_7728",
    "text": "If any of the foragers in a flower patch lands on a solution of higher fitness than the solution visited by the scout, that forager becomes the new scout. If no forager finds a solution of higher fitness, the size of the flower patch is shrunk (neighbourhood shrinking procedure). Usually, flower patches are initially defined over a large area, and their size is gradually shrunk by the neighbourhood shrinking procedure. As a result, the scope of the local exploration is progressively focused on the area immediately close to the local fitness best. If no improvement in fitness is recorded in a given flower patch for a pre-set number of search cycles, the local maximum of fitness is considered found, the patch is abandoned (site abandonment), and a new scout is randomly generated. As in biological bee colonies, [ 7 ] a small number of scouts keeps exploring the solution space looking for new regions of high fitness (global search).",
    "source_url": "https://en.wikipedia.org/wiki/Bees_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:35.598190",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:35.598190",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:35.598190",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bees_algorithm_1_1749015455711_8140",
    "text": "%% GBA's automatic parameter settings k = 3 * n / (( nGroups + 1 ) ^ 3 - 1 ); % GBA's parameter to set the number of scout bees in each group groups = zeros ( 1 , nGroups ); % An array to keep the number of scout bees for each group recruited_bees = zeros ( 1 , nGroups ); % An array to keep the number of recruited bees for each group a = ((( max - min ) ./ 2 ) - R_ngh ) ./ ( nGroups ^ 2 - 1 ); % GBA's parameter for setting neighborhood radiuses b = R_ngh - a ; % GBA's parameter for setting neighborhood radiuses for i = 1 : nGroups % For each group groups ( i ) = floor ( k * i ^ 2 ); % determine the number of scout bees in each group if groups ( i ) == 0 groups ( i ) = 1 ; % there has to be at least one scout bee per each group end recruited_bees = ( nGroups + 1 - i ) ^ 2 ; % set the number of recruited bees for each group ngh ( i ) = a * i *",
    "source_url": "https://en.wikipedia.org/wiki/Bees_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:35.711696",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:35.712695",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:35.712695",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bees_algorithm_1_1749015455732_9753",
    "text": "= a * i * i + b ; % set the radius patch for each group end group_random = n - sum ( groups ); % assign the remainder bees (if any) to random search group_random = max ( group_random , 0 ); % make sure it is not a negative number %% initialize the population matrix population = zeros ( n , maxParameters + 1 ); % A population of n bees including all input variables and their fitness for i = 1 : n population ( i , 1 : maxParameters )= generate_random_solution ( maxParameters , min , max ); % random initialization of maxParameters variables between max and min population ( i , maxParameters + 1 )",
    "source_url": "https://en.wikipedia.org/wiki/Bees_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:35.732674",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:35.732674",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:35.732674",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Firefly_algorithm_1_1749015458123_6419",
    "text": "if ( I j > I i {\\displaystyle I_{j}>I_{i}} ), Vary attractiveness with distance r via exp ⁡ ( − γ r ) { \\displaystyle \\exp(-\\gamma \\;r)} ; move firefly i towards j;                \n                    Evaluate new solutions and update light intensity; end if end for j end for i\n        Rank fireflies and find the current best; end while end Note that the number of objective function evaluations per loop is one evaluation per firefly, even though the above pseudocode suggests it is n × n . (Based on Yang's MATLAB code.) Thus the total number of objective function evaluations is (number of generations) × (number of fireflies). The main update formula for any pair of two fireflies x i {\\displaystyle \\mathbf {x} _{i}} and x j {\\displaystyle \\mathbf {x} _{j}} is x i t + 1 = x i t + β exp ⁡ [ − γ r i j 2 ] ( x j t − x i t ) +",
    "source_url": "https://en.wikipedia.org/wiki/Firefly_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:38.123822",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:38.123822",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:38.123822",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Genetic_algorithm&oldid=1292039994_1_1749015461001_9070",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by PeterGrant07 ( talk | contribs ) at 21:33, 24 May 2025 ( → Chromosome representation : adding early innovations in variable-length representations) . The present address (URL) is a permanent link to this version. Revision as of 21:33, 24 May 2025 by PeterGrant07 ( talk | contribs ) ( → Chromosome representation : adding early innovations in variable-length representations) ( diff )",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Genetic_algorithm&oldid=1292039994",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:41.001573",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:41.001573",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:41.001573",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Genetic_algorithms&oldid=1266474108_1_1749015466241_3061",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Geysirhead ( talk | contribs ) at 20:18, 31 December 2024 . The present address (URL) is a permanent link to this version. Revision as of 20:18, 31 December 2024 by Geysirhead ( talk | contribs ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) This is a topic category . Pages in this category should be moved to subcategories where applicable. This cat",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Genetic_algorithms&oldid=1266474108",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:46.241869",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:46.241869",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:46.242870",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_algorithms_for_automated_planning_1_1749015467966_3395",
    "text": "The difficulty of planning is dependent on the simplifying assumptions employed. Several classes of planning problems can be identified depending on the properties the problems have in several dimensions. Are the actions deterministic or non-deterministic? For nondeterministic actions, are the associated probabilities available? Are the state variables discrete or continuous? If they are discrete, do they have only a finite number of possible values? Can the current state be observed unambiguously? There can be full observability and partial observability. How many initial states are there, finite or arbitrarily many? Do actions have a duration? Can several actions be taken concurrently, or is only one action possible at a time? Is the objective of a plan to reach a designated goal state, or to maximize a reward function ? Is there only one agent or are there several agents? Are the agents cooperative or selfish?",
    "source_url": "https://en.wikipedia.org/wiki/List_of_algorithms_for_automated_planning",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:47.966076",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:47.966076",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:47.966076",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_algorithms_for_automated_planning_1_1749015468462_2778",
    "text": "Discrete-time Markov decision processes (MDP) are planning problems with: durationless actions, nondeterministic actions with probabilities, full observability, maximization of a reward function, and a single agent. When full observability is replaced by partial observability, planning corresponds to a partially observable Markov decision process (POMDP). If there are more than one agent, we have multi-agent planning , which is closely related to game theory . Domain independent planning [ edit ] This section needs additional citations for verification . Please help improve this article by adding citations to reliable sources in this section. Unsourced material may be challenged and removed. ( February 2021 ) ( Learn how and when to remove this message )",
    "source_url": "https://en.wikipedia.org/wiki/List_of_algorithms_for_automated_planning",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:48.462078",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:48.462078",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:48.462078",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_algorithms_for_automated_planning_1_1749015468487_1141",
    "text": "( February 2021 ) ( Learn how and when to remove this message ) In AI planning, planners typically input a domain model (a description of a set of possible actions which model the domain) as well as the specific problem to be solved specified by the initial state and goal, in contrast to those in which there is no input domain specified. Such planners are called \"domain independent\" to emphasize the fact that they can solve planning problems from a wide range of domains. Typical examples of domains are block-stacking, logistics, workflow management, and robot task planning. Hence a single domain-independent planner can be used to solve planning problems in all these various domains. On the other hand, a route planner is typical of a domain-specific planner. Planning domain modelling languages [ edit ] This section needs additional citations for verification . Please help improve this article by adding citations to reliable sources in this section.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_algorithms_for_automated_planning",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:48.487598",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:48.487598",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:48.487598",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_List_of_algorithms_for_automated_planning_1_1749015468565_3298",
    "text": "Temporal planning [ edit ] Temporal planning can be solved with methods similar to classical planning. The main difference is, because of the possibility of several, temporally overlapping actions with a duration being taken concurrently, that the definition of a state has to include information about the current absolute time and how far the execution of each active action has proceeded. Further, in planning with rational or real time, the state space may be infinite, unlike in classical planning or planning with integer time. Temporal planning is closely related to scheduling problems when uncertainty is involved and can also be understood in terms of timed automata . The Simple Temporal Network with Uncertainty (STNU) is a scheduling problem which involves controllable actions, uncertain events and temporal constraints.",
    "source_url": "https://en.wikipedia.org/wiki/List_of_algorithms_for_automated_planning",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:48.565995",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:48.565995",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:48.565995",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Gale%E2%80%93Shapley_algorithm_1_1749015471100_9495",
    "text": "For more, see Stable marriage problem § Applications . Background [ edit ] Main article: Stable matching problem The stable matching problem, in its most basic form, takes as input equal numbers of two types of participants ( n job applicants and n employers, for example), and an ordering for each participant giving their preference for whom to be matched to among the participants of the other type. A matching pairs each participant of one type with a participant of the other type. A matching is not stable if: There is an element A of the first matched set which prefers some given element B of the second matched set over the element to which A is already matched, and B also prefers A over the element to which B is already matched. In other words, a matching is stable when there is no pair ( A , B ) where both participants prefer each other to their matched partners.",
    "source_url": "https://en.wikipedia.org/wiki/Gale%E2%80%93Shapley_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:51.100144",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:51.100144",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:51.100144",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Gale–Shapley_algorithm&oldid=1269013667_1_1749015472546_5158",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Unani2000 ( talk | contribs ) at 16:25, 12 January 2025 (Further logical clarity) . The present address (URL) is a permanent link to this version. Revision as of 16:25, 12 January 2025 by Unani2000 ( talk | contribs ) (Further logical clarity) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Procedure for finding a stable matching In mathematics , economics",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Gale–Shapley_algorithm&oldid=1269013667",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:52.546175",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:52.546175",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:52.546175",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Coloring_algorithm_1_1749015474509_6559",
    "text": "Main article: Chromatic polynomial The chromatic polynomial counts the number of ways a graph can be colored using some of a given number of colors. For example, using three colors, the graph in the adjacent image can be colored in 12 ways. With only two colors, it cannot be colored at all. With four colors, it can be colored in 24 + 4 × 12 = 72 ways: using all four colors, there are 4! = 24 valid colorings ( every assignment of four colors to any 4-vertex graph is a proper coloring); and for every choice of three of the four colors, there are 12 valid 3-colorings. So, for the graph in the example, a table of the number of valid colorings would start like this: Available colors 1 2 3 4 ... Number of colorings 0 0 12 72 ... The chromatic polynomial is a function P ( G , t ) that counts the number of t -colorings of G . As the name indicates, for a given G the function is indeed a polynomial in t . For the example graph, P ( G , t ) = t ( t − 1) 2 ( t − 2) , and indeed P ( G , 4) = 72 .",
    "source_url": "https://en.wikipedia.org/wiki/Coloring_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:54.509914",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:54.509914",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:54.509914",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Coloring_algorithm_1_1749015474574_2087",
    "text": "The smallest number of colors needed for an edge coloring of a graph G is the chromatic index , or edge chromatic number , χ ′ ( G ) . A Tait coloring is a 3-edge coloring of a cubic graph . The four color theorem is equivalent to the assertion that every planar cubic bridgeless graph admits a Tait coloring. Total coloring [ edit ] Main article: Total coloring Total coloring is a type of coloring on the vertices and edges of a graph. When used without any qualification, a total coloring is always assumed to be proper in the sense that no adjacent vertices, no adjacent edges, and no edge and its end-vertices are assigned the same color. The total chromatic number χ ″( G ) of a graph G is the fewest colors needed in any total coloring of G . Face coloring [ edit ] For a graph with a strong embedding on a surface, the face coloring is the dual of the vertex coloring problem.",
    "source_url": "https://en.wikipedia.org/wiki/Coloring_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:54.574149",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:54.574149",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:54.574149",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Hopcroft%E2%80%93Karp_algorithm_1_1749015478430_6767",
    "text": "M ⊕ M ∗ {\\displaystyle M\\oplus M^{*}} where M ∗ {\\displaystyle M^{*}} is an optimal matching. Because M {\\displaystyle M} and M ∗ {\\displaystyle M^{*}} are both matchings, every vertex has degree at most 2 in P {\\displaystyle P} . So P {\\displaystyle P} must form a collection of disjoint cycles, of paths with an equal number of matched and unmatched edges in M {\\displaystyle M} , of augmenting paths for M {\\displaystyle M} , and of augmenting paths for M ∗ {\\displaystyle M^{*}} ; but the latter is impossible because M ∗ {\\displaystyle M^{*}} is optimal. Now, the cycles and the paths with equal numbers of matched and unmatched vertices do not contribute to the  difference in size between M {\\displaystyle M} and M ∗ {\\displaystyle M^{*}} , so this difference is equal to the number of augmenting paths for M {\\displaystyle M} in P {\\displaystyle P} .",
    "source_url": "https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:37:58.430726",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:37:58.430726",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:37:58.430726",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Tarjan%27s_off-line_lowest_common_ancestors_algorithm_1_1749015481830_6418",
    "text": "TarjanOLCA( r ) is first called on the root r . function TarjanOLCA(u) is MakeSet(u)\n    u.ancestor := u for each v in u.children do TarjanOLCA(v)\n        Union(u, v)\n        Find(u).ancestor := u\n    u.color := black for each v such that {u, v} in P do if v.color == black then print \"Tarjan's Lowest Common Ancestor of \" + u +\n                  \" and \" + v + \" is \" + Find(v).ancestor + \".\" Each node is initially white, and is colored black after it and all its children have been visited. For each node pair {u,v} to be investigated: When v is already black (viz. when v comes before u in a post-order traversal of the tree): After u is colored black, the lowest common ancestor of this pair is available as Find(v).ancestor , but only while the LCA of u and v is not colored black. Otherwise: Once v is colored black, the LCA will be available as Find(u).ancestor , while the LCA is not colored black.",
    "source_url": "https://en.wikipedia.org/wiki/Tarjan%27s_off-line_lowest_common_ancestors_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:01.830352",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:01.830352",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:01.830352",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Force-based_algorithms_(graph_drawing)_1_1749015484350_7169",
    "text": "A force-directed graph can involve forces other than mechanical springs and electrical repulsion. A force analogous to gravity may be used to pull vertices towards a fixed point of the drawing space; this may be used to pull together different connected components of a disconnected graph, which would otherwise tend to fly apart from each other because of the repulsive forces, and to draw nodes with greater centrality to more central positions in the drawing; [ 3 ] it may also affect the vertex spacing within a single component. Analogues of magnetic fields may be used for directed graphs. Repulsive forces may be placed on edges as well as on nodes in order to avoid overlap or near-overlap in the final drawing. In drawings with curved edges such as circular arcs or spline curves , forces may also be placed on the control points of these curves, for instance to improve their angular resolution .",
    "source_url": "https://en.wikipedia.org/wiki/Force-based_algorithms_(graph_drawing)",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:04.350792",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:04.350792",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:04.350792",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Dinic%27s_algorithm_1_1749015490139_1029",
    "text": "Definition [ edit ] Let G = ( ( V , E ) , c , f , s , t ) {\\displaystyle G=((V,E),c,f,s,t)} be a network with c ( u , v ) {\\displaystyle c(u,v)} and f ( u , v ) {\\displaystyle f(u,v)} the capacity and the flow of the edge ( u , v ) {\\displaystyle (u,v)} , respectively. The residual capacity is a mapping c f : V × V → R + {\\displaystyle c_{f}\\colon V\\times V\\to R^{+}} defined as, if ( u , v ) ∈ E {\\displaystyle (u,v)\\in E} , c f ( u , v ) = c ( u , v ) − f ( u , v ) {\\displaystyle c_{f}(u,v)=c(u,v)-f(u,v)} if ( v , u ) ∈ E {\\displaystyle (v,u)\\in E} , c f ( u , v ) = f ( v , u ) {\\displaystyle c_{f}(u,v)=f(v,u)} c f ( u , v ) = 0 {\\displaystyle c_{f}(u,v)=0} otherwise. The residual graph is an unweighted graph G f = ( ( V , E f ) , c f | E f , s , t ) {\\displaystyle G_{f}=((V,E_{f}),c_{f}|_{E_{f}},s,t)} , where E f = { ( u , v ) ∈ V × V : c f ( u , v ) > 0 } {\\displaystyle E_{f}=\\{(u,v)\\in V\\times V\\colon \\;c_{f}(u,v)>0\\}} .",
    "source_url": "https://en.wikipedia.org/wiki/Dinic%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:10.139857",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:10.139857",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:10.139857",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Dinic%27s_algorithm_1_1749015490172_7944",
    "text": "An augmenting path is an s {\\displaystyle s} – t {\\displaystyle t} path in the residual graph G f {\\displaystyle G_{f}} . Define dist ⁡ ( v ) {\\displaystyle \\operatorname {dist} (v)} to be the length of the shortest path from s {\\displaystyle s} to v {\\displaystyle v} in G f {\\displaystyle G_{f}} . Then the level graph of G f {\\displaystyle G_{f}} is the graph G L = ( ( V , E L ) , c f | E L , s , t ) {\\displaystyle G_{L}=((V,E_{L}),c_{f}|_{E_{L}},s,t)} , where E L = { ( u , v ) ∈ E f : dist ⁡ ( v ) = dist ⁡ ( u ) + 1 } {\\displaystyle E_{L}=\\{(u,v)\\in E_{f}\\colon \\;\\operatorname {dist} (v)=\\operatorname {dist} (u)+1\\}} . A blocking flow is an s {\\displaystyle s} – t {\\displaystyle t} flow f ′ {\\displaystyle f'} such that the graph G ′ = ( ( V , E L ′ ) , s , t ) {\\displaystyle G'=((V,E_{L}'),s,t)} with E L ′ = { ( u , v ) : f ′ ( u , v ) <",
    "source_url": "https://en.wikipedia.org/wiki/Dinic%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:10.172859",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:10.173859",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:10.173859",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Edmonds%E2%80%93Karp_algorithm_1_1749015492588_6561",
    "text": "(Initialize flow to zero) repeat (Run a breadth-first search (bfs) to find the shortest s-t path. We use 'pred' to store the edge taken to get to each vertex, so we can recover the path afterwards) q := queue ()\n        q.push(s)\n        pred := array (graph.length) while not empty(q) and pred[t] = null\n            cur := q.pop() for Edge e in graph[cur] do if pred[e.t] = null and e.t ≠ s and e.cap > e.flow then pred[e.t] := e\n                    q.push(e.t) if not (pred[t] = null) then (We found an augmenting path.",
    "source_url": "https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:12.588051",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:12.588051",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:12.588051",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Edmonds%E2%80%93Karp_algorithm_1_1749015492626_3187",
    "text": "then (We found an augmenting path. See how much flow we can send) df := ∞ for (e := pred[t]; e ≠ null; e := pred[e.s]) do df := min (df, e.cap - e.flow) (And update edges by that amount) for (e := pred[t]; e ≠ null; e := pred[e.s]) do e.flow  := e.flow + df\n                e.rev.flow := e.rev.flow - df\n            flow := flow + df until pred[t] = null (i.e., until no augmenting path was found) return flow Example [ edit ] Given a network of seven nodes, source A, sink G, and capacities as shown below: In the pairs f / c {\\displaystyle f/c} written on the edges, f {\\displaystyle f} is the current flow, and c {\\displaystyle c} is the capacity. The residual capacity from u {\\displaystyle u} to v {\\displaystyle v} is c f ( u , v ) = c ( u , v ) − f ( u , v ) {\\displaystyle c_{f}(u,v)=c(u,v)-f(u,v)} , the total capacity, minus the flow that is already used. If the net flow from u {\\displaystyle u} to v {\\displaystyle v} is negative, it contributes to the residual capacity.",
    "source_url": "https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:12.626917",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:12.626917",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:12.626917",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Edmonds%E2%80%93Karp_algorithm_1_1749015492661_6324",
    "text": "Path Capacity Resulting network A , D , E , G {\\displaystyle A,D,E,G} min ( c f ( A , D ) , c f ( D , E ) , c f ( E , G ) ) = min ( 3 − 0 , 2 − 0 , 1 − 0 ) = min ( 3 , 2 , 1 ) = 1 {\\displaystyle {\\begin{aligned}&\\min(c_{f}(A,D),c_{f}(D,E),c_{f}(E,G))\\\\=&\\min(3-0,2-0,1-0)\\\\=&\\min(3,2,1)=1\\end{aligned}}} A , D , F , G {\\displaystyle A,D,F,G} min ( c f ( A , D ) , c f ( D , F ) , c f ( F , G ) ) = min ( 3 − 1 , 6 − 0 , 9 − 0 ) = min ( 2 , 6 , 9 ) = 2 {\\displaystyle {\\begin{aligned}&\\min(c_{f}(A,D),c_{f}(D,F),c_{f}(F,G))\\\\=&\\min(3-1,6-0,9-0)\\\\=&\\min(2,6,9)=2\\end{aligned}}} A , B , C , D , F , G {\\displaystyle A,B,C,D,F,G} min ( c f ( A , B ) , c f ( B , C ) , c f ( C , D ) , c f ( D , F ) , c f ( F , G ) )",
    "source_url": "https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:12.661917",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:12.662916",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:12.662916",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Push%E2%80%93relabel_algorithm_1_1749015495289_3470",
    "text": "This is called an unsaturating or non-saturating push . Relabel [ edit ] The relabel operation applies on an active node u which is neither the source nor the sink without any admissible out-arcs in G f . It modifies 𝓁( u ) to be the minimum value such that an admissible out-arc is created. Note that this always increases 𝓁( u ) and never creates a steep arc, which is an arc ( u , v ) such that c f ( u , v ) > 0 , and 𝓁( u ) > 𝓁( v ) + 1 . relabel(u):\n    assert x f [u] > 0 and 𝓁[u] <= 𝓁[v] for all v such that c f [u][v] > 0\n    𝓁[u] = 1 + min(𝓁[v] for all v such that c f [u][v] > 0) Effects of push and relabel [ edit ] After a push or relabel operation, 𝓁 remains a valid labeling function with respect to f . For a push operation on an admissible arc ( u , v ) , it may add an arc ( v , u ) to E f , where 𝓁( v ) = 𝓁( u ) − 1 ≤ 𝓁( u ) + 1 ; it may also remove the arc ( u , v ) from E f , where it effectively removes the constraint 𝓁( u ) ≤ 𝓁( v ) + 1 .",
    "source_url": "https://en.wikipedia.org/wiki/Push%E2%80%93relabel_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:15.289470",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:15.290462",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:15.290462",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Edmonds%27_algorithm_1_1749015499640_1058",
    "text": "We first remove any edge from E {\\displaystyle E} whose destination is r {\\displaystyle r} . We may also replace any set of parallel edges (edges between the same pair of vertices in the same direction) by a single edge with weight equal to the minimum of the weights of these parallel edges. Now, for each node v {\\displaystyle v} other than the root, find the edge incoming to v {\\displaystyle v} of lowest weight (with ties broken arbitrarily). Denote the source of this edge by π ( v ) {\\displaystyle \\pi (v)} . If the set of edges P = { ( π ( v ) , v ) ∣ v ∈ V ∖ { r } } {\\displaystyle P=\\{(\\pi (v),v)\\mid v\\in V\\setminus \\{r\\}\\}} does not contain any cycles, then f ( D , r , w ) = P {\\displaystyle f(D,r,w)=P} . Otherwise, P {\\displaystyle P} contains at least one cycle. Arbitrarily choose one of these cycles and call it C {\\displaystyle C} .",
    "source_url": "https://en.wikipedia.org/wiki/Edmonds%27_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:19.640852",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:19.640852",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:19.640852",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Edmonds%27_algorithm_1_1749015499672_1126",
    "text": "Arbitrarily choose one of these cycles and call it C {\\displaystyle C} . We now define a new weighted directed graph D ′ = ⟨ V ′ , E ′ ⟩ {\\displaystyle D^{\\prime }=\\langle V^{\\prime },E^{\\prime }\\rangle } in which the cycle C {\\displaystyle C} is \"contracted\" into one node as follows: The nodes of V ′ {\\displaystyle V^{\\prime }} are the nodes of V {\\displaystyle V} not in C {\\displaystyle C} plus a new node denoted v C {\\displaystyle v_{C}} . If ( u , v ) {\\displaystyle (u,v)} is an edge in E {\\displaystyle E} with u ∉ C {\\displaystyle u\\notin C} and v ∈ C {\\displaystyle v\\in C} (an edge coming into the cycle), then include in E ′ {\\displaystyle E^{\\prime }} a new edge e = ( u , v C ) {\\displaystyle e=(u,v_{C})} , and define w ′ ( e ) = w ( u , v ) − w ( π ( v ) , v ) { \\displaystyle w^{\\prime }(e)=w(u,v)-w(\\pi (v),v)} .",
    "source_url": "https://en.wikipedia.org/wiki/Edmonds%27_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:19.672384",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:19.672384",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:19.672384",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Edmonds%27_algorithm_1_1749015499704_6864",
    "text": "\\displaystyle w^{\\prime }(e)=w(u,v)-w(\\pi (v),v)} . If ( u , v ) {\\displaystyle (u,v)} is an edge in E {\\displaystyle E} with u ∈ C {\\displaystyle u\\in C} and v ∉ C {\\displaystyle v\\notin C} (an edge going away from the cycle), then include in E ′ {\\displaystyle E^{\\prime }} a new edge e = ( v C , v ) {\\displaystyle e=(v_{C},v)} , and define w ′ ( e ) = w ( u , v ) {\\displaystyle w^{\\prime }(e)=w(u,v)} . If ( u , v ) {\\displaystyle (u,v)} is an edge in E {\\displaystyle E} with u ∉ C {\\displaystyle u\\notin C} and v ∉ C {\\displaystyle v\\notin C} (an edge unrelated to the cycle), then include in E ′ {\\displaystyle E^{\\prime }} a new edge e = ( u , v ) {\\displaystyle e=(u,v)} , and define w ′ ( e ) = w ( u , v ) {\\displaystyle w^{\\prime }(e)=w(u,v)} . For each edge in E ′ {\\displaystyle E^{\\prime }} , we remember which edge in E {\\displaystyle E} it corresponds to.",
    "source_url": "https://en.wikipedia.org/wiki/Edmonds%27_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:19.704507",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:19.704507",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:19.704507",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Edmonds%27_algorithm_1_1749015499736_4887",
    "text": "Now find a minimum spanning arborescence A ′ {\\displaystyle A^{\\prime }} of D ′ {\\displaystyle D^{\\prime }} using a call to f ( D ′ , r , w ′ ) {\\displaystyle f(D^{\\prime },r,w^{\\prime })} . Since A ′ {\\displaystyle A^{\\prime }} is a spanning arborescence, each vertex has exactly one incoming edge. Let ( u , v C ) {\\displaystyle (u,v_{C})} be the unique incoming edge to v C {\\displaystyle v_{C}} in A ′ {\\displaystyle A^{\\prime }} . This edge corresponds to an edge ( u , v ) ∈ E {\\displaystyle (u,v)\\in E} with v ∈ C {\\displaystyle v\\in C} . Remove the edge ( π ( v ) , v ) {\\displaystyle (\\pi (v),v)} from C {\\displaystyle C} , breaking the cycle. Mark each remaining edge in C {\\displaystyle C} . For each edge in A ′ {\\displaystyle A^{\\prime }} , mark its corresponding edge in E {\\displaystyle E} . Now we define f ( D , r , w ) {\\displaystyle f(D,r,w)} to be the set of marked edges, which form a minimum spanning arborescence.",
    "source_url": "https://en.wikipedia.org/wiki/Edmonds%27_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:19.736097",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:19.736097",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:19.736097",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bor%C5%AFvka%27s_algorithm_1_1749015501691_5550",
    "text": "A weighted undirected graph G = ( V , E ). output: F , a minimum spanning forest of G . Initialize a forest F to ( V , E ′ ) where E ′ = {}.",
    "source_url": "https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:21.691303",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:21.691303",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:21.691303",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Bor%C5%AFvka%27s_algorithm_1_1749015501722_4305",
    "text": "output: F , a minimum spanning forest of G . Initialize a forest F to ( V , E ′ ) where E ′ = {}. completed := false while not completed do Find the connected components of F and assign to each vertex its component\n        Initialize the cheapest edge for each component to \"None\" for each edge uv in E , where u and v are in different components of F :\n            let wx be the cheapest edge for the component of u if is-preferred-over( uv , wx ) then Set uv as the cheapest edge for the component of u let yz be the cheapest edge for the component of v if is-preferred-over( uv , yz ) then Set uv as the cheapest edge for the component of v if all components have cheapest edge set to \"None\" then // no more trees can be merged -- we are finished completed := true else completed := false for each component whose cheapest edge is not \"None\" do Add its cheapest edge to E' function is-preferred-over( edge1 , edge2 ) is return ( edge2 is \"None\") or\n           (weight( edge1 )",
    "source_url": "https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:21.722774",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:21.722774",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:21.722774",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Borůvka%27s_algorithm&oldid=1282617101_1_1749015502764_1989",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Patrick Welsh ( talk | contribs ) at 14:54, 27 March 2025 ( RCP reverted edits by 186.185.247.155 ( Talk ); changed back to last revision by JJMC89 bot III : Unconstructive edit) . The present address (URL) is a permanent link to this version. Revision as of 14:54, 27 March 2025 by Patrick Welsh ( talk | contribs ) ( RCP reverted edits by 186.185.247.155 ( Talk ); changed back to last re",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Borůvka%27s_algorithm&oldid=1282617101",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:22.764358",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:22.764358",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:22.765349",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Reverse-delete_algorithm_1_1749015504014_1253",
    "text": "The result sub-graph cannot contain a cycle since if it does then when moving along the edges we would encounter the max edge in the cycle and we would delete that edge. Thus g must be a spanning tree of the main graph G. Minimality [ edit ] We show that the following proposition P is true by induction: If F is the set of edges remained at the end of the while loop, then there is some minimum spanning tree that (its edges) are a subset of F . Clearly P holds before the start of the while loop .",
    "source_url": "https://en.wikipedia.org/wiki/Reverse-delete_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:24.014303",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:24.014303",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:24.014303",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Reverse-delete_algorithm_1_1749015504088_1814",
    "text": "assume e separates T into sub-graphs t1 and t2. Since the whole graph is connected after deleting e then there must exists a path between t1 and t2 (other than e) so there must exist a cycle C in the F (before removing e). now we must have another edge in this cycle (call it f) that is not in T but it is in F (since if all the cycle edges were in tree T then it would not be a tree anymore). we now claim that T' = T - e + f is the minimum spanning tree that is a subset of F. firstly we prove that T' is a spanning tree . we know by deleting an edge in a tree and adding another edge that does not cause a cycle we get another tree with the same vertices. since T was a spanning tree so T' must be a spanning tree too. since adding \" f \" does not cause any cycles since \"e\" is removed.(note that tree T contains all the vertices of the graph). secondly we prove T' is a minimum spanning tree . we have three cases for the edges \"e\" and \" f \". wt is the weight function. wt( f ) <",
    "source_url": "https://en.wikipedia.org/wiki/Reverse-delete_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:24.088616",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:24.088616",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:24.088616",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Graph_search_algorithm_1_1749015507137_9791",
    "text": "This section needs expansion . You can help by adding to it . ( December 2016 ) A universal traversal sequence is a sequence of instructions comprising a graph traversal for any regular graph with a set number of vertices and for any starting vertex. A probabilistic proof was used by Aleliunas et al. to show that there exists a universal traversal sequence with number of instructions proportional to O ( n 5 ) for any regular graph with n vertices. [ 6 ] The steps specified in the sequence are relative to the current node, not absolute. For example, if the current node is v j , and v j has d neighbors, then the traversal sequence will specify the next node to visit, v j +1 , as the i th neighbor of v j , where 1 ≤ i ≤ d . See also [ edit ] External memory graph traversal References [ edit ] ^ Rosenkrantz, Daniel J.; Stearns, Richard E.; Lewis, II, Philip M. (1977). \"An Analysis of Several Heuristics for the Traveling Salesman Problem\". SIAM Journal on Computing . 6 (3): 563– 581.",
    "source_url": "https://en.wikipedia.org/wiki/Graph_search_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:27.137106",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:27.138098",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:27.138098",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Bron–Kerbosch_algorithm&oldid=1266585620_1_1749015511087_1162",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by David Eppstein ( talk | contribs ) at 08:21, 1 January 2025 (Undid revision 1266557657 by Patar knight ( talk ) Redundant description that repeats itself redundantly; we have room to be less redundantly redundant and more specific) . The present address (URL) is a permanent link to this version. Revision as of 08:21, 1 January 2025 by David Eppstein ( talk | contribs ) (Undid revision 12",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Bron–Kerbosch_algorithm&oldid=1266585620",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:31.087261",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:31.087261",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:31.087261",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Kosaraju%27s_algorithm_1_1749015517583_3489",
    "text": "For each vertex u of the graph, mark u as unvisited. Let L be empty. For each vertex u of the graph do Visit(u) , where Visit(u) is the recursive subroutine: If u is unvisited then: Mark u as visited. For each out-neighbour v of u , do Visit(v) . Prepend u to L . Otherwise do nothing. For each element u of L in order, do Assign(u,u) where Assign(u,root) is the recursive subroutine: If u has not been assigned to a component then: Assign u as belonging to the component whose root is root . For each in-neighbour v of u , do Assign(v,root) . Otherwise do nothing. Trivial variations are to instead assign a component number to each vertex, or to construct per-component lists of the vertices that belong to it. The unvisited/visited indication may share storage location with the final assignment of root for a vertex.",
    "source_url": "https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:37.583917",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:37.583917",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:37.583917",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Kosaraju%27s_algorithm&oldid=1286892442_1_1749015518993_8855",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Ftiercel ( talk | contribs ) at 17:09, 22 April 2025 (Typo) . The present address (URL) is a permanent link to this version. Revision as of 17:09, 22 April 2025 by Ftiercel ( talk | contribs ) (Typo) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Method of finding a directed graph's strongly connected components This article includes a list of references ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Kosaraju%27s_algorithm&oldid=1286892442",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:38.993414",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:38.993414",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:38.993414",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Tarjan%27s_strongly_connected_components_algorithm_1_1749015520327_4102",
    "text": "The roots of these subtrees are called the \"roots\" of the strongly connected components. Any node of a strongly connected component might serve as a root, if it happens to be the first node of a component that is discovered by search. Stack invariant [ edit ] Nodes are placed on a stack in the order in which they are visited. When the depth-first search recursively visits a node v and its descendants, those nodes are not all necessarily popped from the stack when this recursive call returns. The crucial invariant property is that a node remains on the stack after it has been visited if and only if there exists a path in the input graph from it to some node earlier on the stack. In other words, it means that in the DFS a node would be only removed from the stack after all its connected paths have been traversed. When the DFS will backtrack it would remove the nodes on a single path and return to the root in order to start a new path.",
    "source_url": "https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:40.327467",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:40.327467",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:40.327467",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Tarjan%27s_strongly_connected_components_algorithm_1_1749015520423_7680",
    "text": "Set the depth index for v to the smallest unused index v .index := index v .lowlink := index index := index + 1 S .push( v ) v .onStack := true // Consider successors of v for each ( v , w ) in E do if w .index is undefined then // Successor w has not yet been visited; recurse on it strongconnect( w ) v .lowlink := min( v .lowlink, w .lowlink) else if w .onStack then // Successor w is in stack S and hence in the current SCC // If w is not on stack, then ( v , w ) is an edge pointing to an SCC already found and must be ignored // See below regarding the next line v .lowlink := min( v .lowlink, w .index) // If v is a root node, pop the stack and generate an SCC if v .lowlink = v .index then start a new strongly connected component repeat w := S .pop() w .onStack := false\n                add w to current strongly connected component while w ≠ v output the current strongly connected component The index variable is the depth-first search node number counter.",
    "source_url": "https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:40.423735",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:40.424280",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:40.424280",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Tarjan%27s_strongly_connected_components_algorithm_1_1749015520523_6163",
    "text": "{\\displaystyle O(|V|+|E|)} . In order to achieve this complexity, the test for whether w is on the stack should be done in constant time. This can be done as in the pseudocode above: store a flag on each node that indicates whether it is on the stack, and performing this test by examining the flag. Space Complexity : The Tarjan procedure requires two words of supplementary data per vertex for the index and lowlink fields, along with one bit for onStack and another for determining when index is undefined. In addition, one word is required on each stack frame to hold v and another for the current position in the edge list. Finally, the worst-case size of the stack S must be | V | {\\displaystyle |V|} (i.e. when the graph is one giant component). This gives a final analysis of O ( | V | ⋅ ( 2 + 5 w ) ) {\\displaystyle O(|V|\\cdot (2+5w))} where w {\\displaystyle w} is the machine word size. The variation of Nuutila and Soisalon-Soininen reduced this to O ( | V | ⋅ ( 1 + 4 w ) )",
    "source_url": "https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:40.523660",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:40.524041",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:40.524041",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_K-way_merge_algorithm_1_1749015527908_7599",
    "text": "This straightforward implementation results in a running time of Θ(kn). Note that this is mentioned only as a possibility, for the sake of discussion. Although it would work, it is not efficient. We can improve upon this by computing the smallest element faster. By using either heaps , tournament trees, or splay trees , the smallest element can be determined in O(log k) time. The resulting running times are therefore in O(n log k). The heap is more commonly used, although a tournament tree is faster in practice. A heap uses approximately 2*log(k) comparisons in each step because it handles the tree from the root down to the bottom and needs to compare both children of each node. Meanwhile, a tournament tree only needs log(k) comparisons because it starts on the bottom of the tree and works up to the root, only making a single comparison in each layer. The tournament tree should therefore be the preferred implementation. Heap [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/K-way_merge_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:47.908320",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:47.908320",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:47.908320",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_K-way_merge_algorithm_1_1749015528139_8774",
    "text": "Additionally, the number of lists to merge is assumed to be a power of two. function merge(L1, ..., Ln)\n    buildTree(heads of L1, ..., Ln) while tree has elements\n        winner := tree.winner\n        output winner.value\n        new := winner.index.next\n        replayGames(winner, new) // Replacement selection function replayGames(node, new)\n    loser, winner := playGame(node, new)\n    node.value := loser.value\n    node.index := loser.index if node ! = root\n        replayGames(node.parent, winner) function buildTree(elements)\n    nextLayer := new Array() while elements not empty\n        el1 := elements.take()\n        el2 := elements.take()\n        loser, winner := playGame(el1, el2)\n        parent := new Node(el1, el2, loser)\n        nextLayer.add(parent) if nextLayer.size == 1 return nextLayer // only root else return buildTree(nextLayer) Running time [ edit ] In the beginning, the tree is first created in time Θ(k).",
    "source_url": "https://en.wikipedia.org/wiki/K-way_merge_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:48.139442",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:48.139442",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:48.139442",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schensted_algorithm_1_1749015531137_9158",
    "text": "i have equal shapes for all i ). Because of the more passive role of the tableaux Q i , the final one Q n , which is part of the output and from which the previous Q i are easily read off, is called the recording tableau ; by contrast the tableaux P i are called insertion tableaux . Insertion [ edit ] Insertion of (4): • (4) replaces (5) in the first row • (5) replaces (8) in the second row • (8) creates the third row The basic procedure used to insert each σ i is called Schensted insertion or row-insertion (to distinguish it from a variant procedure called column-insertion). Its simplest form is defined in terms of \"incomplete standard tableaux\": like standard tableaux they have distinct entries, forming increasing rows and columns, but some values (still to be inserted) may be absent as entries. The procedure takes as arguments such a tableau T and a value x not present as entry of T ; it produces as output a new tableau denoted T ← x and a square s by which its shape has grown.",
    "source_url": "https://en.wikipedia.org/wiki/Schensted_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:51.137357",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:51.137357",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:51.137357",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schensted_algorithm_1_1749015531173_3434",
    "text": "The value x appears in the first row of T ← x , either having been added at the end (if no entries larger than x were present), or otherwise replacing the first entry y > x in the first row of T . In the former case s is the square where x is added, and the insertion is completed; in the latter case the replaced entry y is similarly inserted into the second row of T , and so on, until at some step the first case applies (which certainly happens if an empty row of T is reached). More formally, the following pseudocode describes the row-insertion of a new value x into T . [ 1 ] Set i = 1 and j to one more than the length of the first row of T . While j > 1 and x < T i , j −1 , decrease j by 1. (Now ( i , j ) is the first square in row i with either an entry larger than x in T , or no entry at all.) If the square ( i , j ) is empty in T , terminate after adding x to T in square ( i , j ) and setting s = ( i , j ) . Swap the values x and T i, j . (This inserts the old x into row",
    "source_url": "https://en.wikipedia.org/wiki/Schensted_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:51.173591",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:51.173591",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:51.173591",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schensted_algorithm_1_1749015531202_3977",
    "text": "= ( i , j ) . Swap the values x and T i, j . (This inserts the old x into row i , and saves the value it replaces for insertion into the next row.) Increase i by 1 and return to step 2. The shape of T grows by exactly one square, namely s . Correctness [ edit ] The fact that T ← x has increasing rows and columns, if the same holds for T , is not obvious from this procedure (entries in the same column are never even compared). It can however be seen as follows. At all times except immediately after step 4, the square ( i , j ) is either empty in T or holds a value greater than x ; step 5 re-establishes this property because ( i , j ) now is the square immediately below the one that originally contained x in T . Thus the effect of the replacement in step 4 on the value T i, j is to make it smaller; in particular it cannot become greater than its right or lower neighbours.",
    "source_url": "https://en.wikipedia.org/wiki/Schensted_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:51.202689",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:51.202689",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:51.202689",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Schensted_algorithm_1_1749015531349_9066",
    "text": "The length of the longest decreasing subsequence of σ 1 , ..., σ n is equal to the length of the first column of P (and of Q ), as follows from the previous two properties. The descent set { i : σ i > σ i +1 } of σ equals the descent set { i : i +1 is in a row strictly below the row of i } of Q . Identify subsequences of π with their sets of indices. It is a theorem of Greene that for any k ≥ 1 , the size of the largest set that can be written as the union of at most k increasing subsequences is λ 1 + ... + λ k . In particular, λ 1 equals the largest length of an increasing subsequence of π . If σ is an involution , then the number of fixed points of σ equals the number of columns of odd length in λ . Applications [ edit ] Application to the Erdős–Szekeres theorem [ edit ] The Robinson-Schensted correspondence can be used to give a simple proof of the Erdős–Szekeres theorem .",
    "source_url": "https://en.wikipedia.org/wiki/Schensted_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:51.349779",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:51.350781",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:51.350781",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Heap%27s_algorithm_1_1749015533942_8204",
    "text": "{\\displaystyle k!} permutations that end with the same n − k {\\displaystyle n-k} final elements. It does this by calling itself once with the k th {\\displaystyle k{\\text{th}}} element unaltered and then k − 1 {\\displaystyle k-1} times with the ( k th {\\displaystyle k{\\text{th}}} ) element exchanged for each of the initial k − 1 {\\displaystyle k-1} elements. The recursive calls modify the initial k − 1 {\\displaystyle k-1} elements and a rule is needed at each iteration to select which will be exchanged with the last. Heap's method says that this choice can be made by the parity of the number of elements operated on at this step. If k {\\displaystyle k} is even, then the final element is iteratively exchanged with each element index. If k {\\displaystyle k} is odd, the final element is always exchanged with the first. // Output the k! permutations of A in which the first k elements are permuted in all ways. // To get all permutations of A, use k := length of A. // //",
    "source_url": "https://en.wikipedia.org/wiki/Heap%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:53.942954",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:53.943955",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:53.943955",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Heap%27s_algorithm_1_1749015534083_1309",
    "text": "// Output the k! permutations of A in which the first k elements are permuted in all ways. // To get all permutations of A, use k := length of A. // // If, k > length of A, will try to access A out of bounds. // If k <= 0 there will be no output (empty array has no permutations) procedure permutations ( k : integer , A : array of any ) : if k = 1 then output ( A ) else for i := 0 ; i < k ; i += 1 do permutations ( k - 1 , A ) if k is even then swap ( A [ i ] , A [ k - 1 ]) else swap ( A [ 0 ] , A [ k - 1 ]) end if end for end if Claim: If array A has length n , then permutations(n, A) will result in either A being unchanged, if n is odd, or, if n is even, then A is rotated to the right by 1 (last element shifted in front of other elements). Base: If array A has length 1, then permutations(1, A) will output A and stop, so A is unchanged. Since 1 is odd, this is what was claimed, so the claim is true for arrays of length 1.",
    "source_url": "https://en.wikipedia.org/wiki/Heap%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:54.083311",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:54.083311",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:54.083311",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Heap%27s_algorithm_1_1749015534114_4761",
    "text": "Since 1 is odd, this is what was claimed, so the claim is true for arrays of length 1. Induction: If the claim is true for arrays of length l ≥ 1, then we show that the claim is true for arrays of length l +1 (together with the base case this proves that the claim is true for arrays of all lengths). Since the claim depends on whether l is odd or even, we prove each case separately. If l is odd, then, by the induction hypothesis, for an array A of length l , permutations(l, A) will not change A, and for the claim to hold for arrays of length l +1 (which is even), we need to show that permutations(l+1, A) rotates A to the right by 1 position. Doing permutations(l+1, A) will first do permutations(l, A) (leaving A unchanged since l is odd) and then in each iteration i of the for-loop, swap the elements in positions i and l (the last position) in A. The first swap puts element l (the last element) in position 0, and element 0 in position l .",
    "source_url": "https://en.wikipedia.org/wiki/Heap%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:54.114340",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:54.114340",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:54.115340",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Heap%27s_algorithm_1_1749015534143_4113",
    "text": "The first swap puts element l (the last element) in position 0, and element 0 in position l . The next swap puts the element in position l (where the previous iteration put original element 0) in position 1 and element 1 in position l . In the final iteration, the swap puts element l -1 is in position l , and the element in position l (where the previous iteration put original element l -2) in position l -1. To illustrate the above, look below for the case n = 4. 1,2,3,4 ... original array\n1,2,3,4 ... 1st iteration (permute subarray)\n4,2,3,1 ... 1st iteration (swap 1st element into last position)\n4,2,3,1 ... 2nd iteration (permute subarray)\n4,1,3,2 ... 2nd iteration (swap 2nd element into last position)\n4,1,3,2 ... 3rd iteration (permute subarray)\n4,1,2,3 ... 3rd iteration (swap 3rd element into last position)\n4,1,2,3 ... 4th iteration (permute subarray)\n4,1,2,3 ... 4th iteration (swap 4th element into last position)",
    "source_url": "https://en.wikipedia.org/wiki/Heap%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:54.143883",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:54.143883",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:54.143883",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Heap%27s_algorithm_1_1749015534173_8519",
    "text": "4th iteration (permute subarray)\n4,1,2,3 ... 4th iteration (swap 4th element into last position) The altered array is a rotated version of the original If l is even, then, by the induction hypothesis, for an array A of length l , permutations(l, A) rotates A to the right by 1 position, and for the claim to hold for arrays of length l +1 (which is odd), we need to show that permutations(l+1, A) leaves A unchanged. Doing permutations(l+1, A) will in each iteration i of the for-loop, first do permutations(l, A) (rotating the first l elements of A by 1 position since l is even) and then, swap the elements in positions 0 and l (the last position) in A. Rotating the first l elements and then swapping the first and last elements is equivalent to rotating the entire array. Since there are as many iterations of the loop as there are elements in the array, the entire array is rotated until each element returns to where it started.",
    "source_url": "https://en.wikipedia.org/wiki/Heap%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:54.173394",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:54.173394",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:54.173394",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Hirschberg%27s_algorithm_1_1749015536393_1195",
    "text": "We define NWScore ⁡ ( X , Y ) {\\displaystyle \\operatorname {NWScore} (X,Y)} , which returns the last line of the Needleman–Wunsch score matrix S c o r e ( i , j ) {\\displaystyle \\mathrm {Score} (i,j)} : function NWScore(X, Y)\n    Score(0, 0) = 0 // 2 * (length(Y) + 1) array for j = 1 to length(Y)\n        Score(0, j) = Score(0, j - 1) + Ins(Y j ) for i = 1 to length(X) // Init array\n        Score(1, 0) = Score(0, 0) + Del(X i ) for j = 1 to length(Y)\n            scoreSub = Score(0, j - 1) + Sub(X i , Y j )\n            scoreDel = Score(0, j) + Del(X i ) scoreIns = Score(1, j - 1) + Ins(Y j )\n            Score(1, j) = max(scoreSub, scoreDel, scoreIns) end // Copy Score[1] to Score[0]\n        Score(0, :) = Score(1, :) end for j = 0 to length(Y)\n        LastLine(j) = Score(1, j) return LastLine Note that at any point, NWScore {\\displaystyle \\operatorname {NWScore} } only requires the two most recent rows of the score matrix.",
    "source_url": "https://en.wikipedia.org/wiki/Hirschberg%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:56.393184",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:56.393184",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:56.393184",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Hirschberg%27s_algorithm_1_1749015536485_8341",
    "text": "Index y m i d {\\displaystyle \\mathrm {ymid} } is computed such that Y l = Y 1 : y m i d {\\displaystyle Y^{l}=Y_{1:\\mathrm {ymid} }} and Y r = Y y m i d + 1 : length ⁡ ( Y ) {\\displaystyle Y^{r}=Y_{\\mathrm {ymid} +1:\\operatorname {length} (Y)}} . Example [ edit ] Let X = AGTACGCA , Y = TATGC , Del ⁡ ( x ) = − 2 , Ins ⁡ ( y ) = − 2 , Sub ⁡ ( x , y ) = { + 2 , if x = y − 1 , if x ≠ y . {\\displaystyle {\\begin{aligned}X&={\\text{AGTACGCA}},\\\\Y&={\\text{TATGC}},\\\\\\operatorname {Del} (x)&=-2,\\\\\\operatorname {Ins} (y)&=-2,\\\\\\operatorname {Sub} (x,y)&={\\begin{cases}+2,&{\\text{if }}x=y\\\\-1,&{\\text{if }}x\\neq y.\\end{cases}}\\end{aligned}}} The optimal alignment is given by W = AGTACGCA\n Z = --TATGC- Indeed, this can be verified by backtracking its corresponding Needleman–Wunsch matrix: T   A   T   G   C 0 -2  -4  -6  -8 -10 A -2 -1   0  -2  -4  -6 G -4 -3  -2 -1   0  -2 T -6 -2 -4   0  -2 -1 A -8  -4 0 -2 -1  -3 C -10 -6 -2 -1 -3   1 G -12  -8  -4  -3 1 -1 C -14 -10 -6  -5",
    "source_url": "https://en.wikipedia.org/wiki/Hirschberg%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:56.485627",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:56.485627",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:56.485627",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Hirschberg%27s_algorithm_1_1749015536528_5203",
    "text": "-4   0  -2 -1 A -8  -4 0 -2 -1  -3 C -10 -6 -2 -1 -3   1 G -12  -8  -4  -3 1 -1 C -14 -10 -6  -5 -1 3 A -16 -12  -8  -7  -3 1 One starts with the top level call to Hirschberg ⁡ ( AGTACGCA , TATGC ) {\\displaystyle \\operatorname {Hirschberg} ({\\text{AGTACGCA}},{\\text{TATGC}})} , which splits the first argument in half: X = AGTA + CGCA {\\displaystyle X={\\text{AGTA}}+{\\text{CGCA}}} . The call to NWScore ⁡ ( AGTA , Y ) {\\displaystyle \\operatorname {NWScore} ({\\text{AGTA}},Y)} produces the following matrix: T   A   T   G   C 0  -2  -4  -6  -8 -10 A -2  -1   0  -2  -4  -6 G -4  -3  -2  -1   0  -2 T -6  -2  -4   0  -2 -1 A -8  -4   0  -2 -1  -3 Likewise, NWScore ⁡ ( rev ⁡ ( CGCA ) , rev ⁡ ( Y ) ) {\\displaystyle \\operatorname {NWScore} (\\operatorname {rev} ({\\text{CGCA}}),\\operatorname {rev} (Y))} generates the following matrix: C   G   T   A   T 0 -2  -4  -6  -8 -10 A -2 -1  -3  -5  -4  -6 C -4  0  -2  -4  -6 -5 G -6 -2   2   0  -2 -4 C -8 -4   0   1  -1  -3",
    "source_url": "https://en.wikipedia.org/wiki/Hirschberg%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:56.528116",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:56.528116",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:56.528116",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Needleman%E2%80%93Wunsch_algorithm_1_1749015539526_7006",
    "text": "If implementing the T-T = 4 rule from above the following similarity matrix is produced: A G C T A 1 −1 −1 −1 G −1 1 −1 −1 C −1 −1 1 −1 T −1 −1 −1 4 Different scoring matrices have been statistically constructed which give weight to different actions appropriate to a particular scenario. Having weighted scoring matrices is particularly important in protein sequence alignment due to the varying frequency of the different amino acids. There are two broad families of scoring matrices, each with further alterations for specific scenarios: PAM BLOSUM Gap penalty [ edit ] When aligning sequences there are often gaps (i.e. indels), sometimes large ones. Biologically, a large gap is more likely to occur as one large deletion as opposed to multiple single deletions. Hence two small indels should have a worse score than one large one. The simple and common way to do this is via a large gap-start score for a new indel and a smaller gap-extension score for every letter which extends the indel.",
    "source_url": "https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:38:59.526528",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:38:59.526528",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:38:59.526528",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Needleman–Wunsch_algorithm&oldid=1288993734_1_1749015541307_2325",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by David Eppstein ( talk | contribs ) at 21:05, 5 May 2025 (Undid revision 1288978994 by Deadwall ( talk ) WP:ELNO ) . The present address (URL) is a permanent link to this version. Revision as of 21:05, 5 May 2025 by David Eppstein ( talk | contribs ) (Undid revision 1288978994 by Deadwall ( talk ) WP:ELNO ) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Me",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Needleman–Wunsch_algorithm&oldid=1288993734",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:01.307708",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:01.307708",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:01.307708",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Ruzzo%E2%80%93Tompa_algorithm_1_1749015542463_7928",
    "text": "Nonpositive scores require no special processing, so the next score is read. A positive score is incorporated into a new sub-sequence I k {\\displaystyle I_{k}} of length one that is then integrated into the list by the following process: The list I {\\displaystyle I} is searched from right to left for the maximum value of j {\\displaystyle j} satisfying L j < L k {\\displaystyle L_{j}<L_{k}} If there is no such j {\\displaystyle j} , then add I k {\\displaystyle I_{k}} to the end of the list. If there is such a j {\\displaystyle j} , and R j ≥ R k {\\displaystyle R_{j}\\geq R_{k}} , then add I k {\\displaystyle I_{k}} to the end of the list. Otherwise (i.e., there is such a j, but R j < R k {\\displaystyle R_{j}<R_{k}} ), extend the subsequence I k {\\displaystyle I_{k}} to the left to encompass everything up to and including the leftmost score in I j {\\displaystyle I_{j}} . Delete subsequences I j , I j + 1 , … , I k",
    "source_url": "https://en.wikipedia.org/wiki/Ruzzo%E2%80%93Tompa_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:02.463962",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:02.463962",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:02.463962",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Kadane%27s_algorithm_1_1749015545378_1175",
    "text": "It can be solved in O ( n ) {\\displaystyle O(n)} time and O ( 1 ) {\\displaystyle O(1)} space. Formally, the task is to find indices i {\\displaystyle i} and j {\\displaystyle j} with 1 ≤ i ≤ j ≤ n {\\displaystyle 1\\leq i\\leq j\\leq n} , such that the sum ∑ x = i j A [ x ] {\\displaystyle \\sum _{x=i}^{j}A[x]} is as large as possible. (Some formulations of the problem also allow the empty subarray to be considered; by convention, the sum of all values of the empty subarray is zero.) Each number in the input array A could be positive, negative, or zero. [ 1 ] For example, for the array of values [−2, 1, −3, 4, −1, 2, 1, −5, 4], the contiguous subarray with the largest sum is [4, −1, 2, 1], with sum 6. Some properties of this problem are: If the array contains all non-negative numbers, then the problem is trivial; a maximum subarray is the entire array.",
    "source_url": "https://en.wikipedia.org/wiki/Kadane%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:05.378197",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:05.378197",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:05.378197",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Kadane%27s_algorithm_1_1749015545599_7905",
    "text": "Therefore, current_sum + A [ j ] {\\displaystyle +A[j]} [ note 5 ] is the maximum over all i ∈ { 1 , … , j − 1 } {\\displaystyle i\\in \\{1,\\ldots ,j-1\\}} of the sum A [ i ] + ⋯ + A [ j ] {\\displaystyle A[i]+\\cdots +A[j]} . To extend the latter maximum to cover also the case i = j {\\displaystyle i=j} , it is sufficient to consider also the singleton subarray A [ j … j ] {\\displaystyle A[j\\;\\ldots \\;j]} . This is done in line 6 by assigning max ( A [ j ] , {\\displaystyle \\max(A[j],} current_sum + A [ j ] ) {\\displaystyle +A[j])} as the new value of current_sum , which after that holds the maximum over all i ∈ { 1 , … , j } {\\displaystyle i\\in \\{1,\\ldots ,j\\}} of the sum A [ i ] + ⋯ + A [ j ] {\\displaystyle A[i]+\\cdots +A[j]} . Thus, the problem can be solved with the following code, [ 13 ] expressed in Python .",
    "source_url": "https://en.wikipedia.org/wiki/Kadane%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:05.599290",
    "symbols_found_in_chunk": 1,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:05.600298",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:05.600298",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Kadane%27s_algorithm_1_1749015545710_5224",
    "text": "[ note 6 ] current_sum = max ( 0 , current_sum + x ) As a loop invariant , in the j {\\displaystyle j} th step, the old value of current_sum holds the maximum over all i ∈ { 1 , … , j } {\\displaystyle i\\in \\{1,\\ldots ,j\\}} of the sum A [ i ] + ⋯ + A [ j − 1 ] {\\displaystyle A[i]+\\cdots +A[j-1]} . [ note 7 ] Therefore, current_sum + A [ j ] {\\displaystyle +A[j]} is the maximum over all i ∈ { 1 , … , j } {\\displaystyle i\\in \\{1,\\ldots ,j\\}} of the sum A [ i ] + ⋯ + A [ j ] {\\displaystyle A[i]+\\cdots +A[j]} . To extend the latter maximum to cover also the case i = j + 1 {\\displaystyle i=j+1} , it is sufficient to consider also the empty subarray A [ j + 1 … j ] {\\displaystyle A[j+1\\;\\ldots \\;j]} .",
    "source_url": "https://en.wikipedia.org/wiki/Kadane%27s_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:05.710598",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:05.710598",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:05.710598",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Todd%E2%80%93Coxeter_algorithm_1_1749015557226_8082",
    "text": "i g j {\\displaystyle C_{k}=C_{i}g_{j}} . The relation tables are used to detect when some of the cosets we have found are actually equivalent. One relation table for each relation in R {\\displaystyle R} is maintained. Let 1 = g n 1 g n 2 ⋯ g n t {\\displaystyle 1=g_{n_{1}}g_{n_{2}}\\cdots g_{n_{t}}} be a relation in R {\\displaystyle R} , where g n i ∈ X ′ {\\displaystyle g_{n_{i}}\\in X'} . The relation table has rows representing the cosets of H {\\displaystyle H} , as in the coset table. It has t columns, and the entry in the i th row and j th column is defined to be (if known) k , where C k = C i g n 1 g n 2 ⋯ g n j {\\displaystyle C_{k}=C_{i}g_{n_{1}}g_{n_{2}}\\cdots g_{n_{j}}} . In particular, the ( i , t ) {\\displaystyle (i,t)} 'th entry is initially i , since g n 1 g n 2 ⋯ g n t = 1 {\\displaystyle g_{n_{1}}g_{n_{2}}\\cdots g_{n_{t}}=1} .",
    "source_url": "https://en.wikipedia.org/wiki/Todd%E2%80%93Coxeter_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:17.226863",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:17.227862",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:17.227862",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Todd%E2%80%93Coxeter_algorithm_1_1749015557258_3479",
    "text": "Finally, the subgroup tables are similar to the relation tables, except that they keep track of possible relations of the generators of H {\\displaystyle H} . For each generator h n = g n 1 g n 2 ⋯ g n t {\\displaystyle h_{n}=g_{n_{1}}g_{n_{2}}\\cdots g_{n_{t}}} of H {\\displaystyle H} , with g n i ∈ X ′ {\\displaystyle g_{n_{i}}\\in X'} , we create a subgroup table. It has only one row, corresponding to the coset of H {\\displaystyle H} itself. It has t columns, and the entry in the j th column is defined (if known) to be k , where C k = H g n 1 g n 2 ⋯ g n j {\\displaystyle C_{k}=Hg_{n_{1}}g_{n_{2}}\\cdots g_{n_{j}}} . In particular, the last entry is H , since H g n 1 g n 2 ⋯ g n t = H h n = H {\\displaystyle Hg_{n_{1}}g_{n_{2}}\\cdots g_{n_{t}}=Hh_{n}=H} . When a row of a relation or subgroup table is completed, a new piece of information C i = C j g {\\displaystyle C_{i}=C_{j}g} , g ∈ X ′ {\\displaystyle g\\in X'} , is found. This is known as a deduction .",
    "source_url": "https://en.wikipedia.org/wiki/Todd%E2%80%93Coxeter_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:17.258874",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:17.259876",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:17.259876",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Todd%E2%80%93Coxeter_algorithm_1_1749015557289_6983",
    "text": "This is known as a deduction . From the deduction, we may be able to fill in additional entries of the relation and subgroup tables, resulting in possible additional deductions. We can fill in the entries of the coset table corresponding to the equations C i = C j g {\\displaystyle C_{i}=C_{j}g} and C j = C i g − 1 {\\displaystyle C_{j}=C_{i}g^{-1}} . However, when filling in the coset table, it is possible that we may already have an entry for the equation, but the entry has a different value. In this case, we have discovered that two of our cosets are actually the same, known as a coincidence . Suppose C i = C j {\\displaystyle C_{i}=C_{j}} , with i < j {\\displaystyle i<j} . We replace all instances of j in the tables with i . Then, we fill in all possible entries of the tables, possibly leading to more deductions and coincidences. If there are empty entries in the table after all deductions and coincidences have been taken care of, add a new coset to the tables and repeat the process.",
    "source_url": "https://en.wikipedia.org/wiki/Todd%E2%80%93Coxeter_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:17.289895",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:17.289895",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:17.289895",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pollard%27s_kangaroo_algorithm_1_1749015560868_5131",
    "text": "2. Choose an integer N {\\displaystyle N} and compute a sequence of group elements { x 0 , x 1 , … , x N } {\\displaystyle \\{x_{0},x_{1},\\ldots ,x_{N}\\}} according to: x 0 = α b {\\displaystyle x_{0}=\\alpha ^{b}\\,} x i + 1 = x i α f ( x i ) for i = 0 , 1 , … , N − 1 {\\displaystyle x_{i+1}=x_{i}\\alpha ^{f(x_{i})}{\\text{ for }}i=0,1,\\ldots ,N-1} 3. Compute d = ∑ i = 0 N − 1 f ( x i ) . {\\displaystyle d=\\sum _{i=0}^{N-1}f(x_{i}).} Observe that: x N = x 0 α d = α b + d . {\\displaystyle x_{N}=x_{0}\\alpha ^{d}=\\alpha ^{b+d}\\,.} 4. Begin computing a second sequence of group elements { y 0 , y 1 , … } {\\displaystyle \\{y_{0},y_{1},\\ldots \\}} according to: y 0 = β {\\displaystyle y_{0}=\\beta \\,} y i + 1 = y i α f ( y i ) for i = 0 , 1 , … , N − 1 {\\displaystyle y_{i+1}=y_{i}\\alpha ^{f(y_{i})}{\\text{ for }}i=0,1,\\ldots ,N-1} and a corresponding sequence of integers { d 0 , d 1 , … } {\\displaystyle \\{d_{0},d_{1},\\ldots \\}} according to: d n = ∑",
    "source_url": "https://en.wikipedia.org/wiki/Pollard%27s_kangaroo_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:20.868354",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:20.869353",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:20.869353",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pollard%27s_kangaroo_algorithm_1_1749015561085_5943",
    "text": "ISSN 0025-5718 . Archived (PDF) from the original on 2013-05-03 . Retrieved 2023-08-19 . (7 pages) ^ van Oorschot, Paul C. ; Wiener, Michael J. (1999). \"Parallel collision search with cryptanalytic applications\" . Journal of Cryptology . 12 (1). International Association for Cryptologic Research : 1– 28. doi : 10.1007/PL00003816 . ISSN 0933-2790 . ^ Pollard, John M. (2000-08-10) [1998-01-23, 1999-09-27]. \"Kangaroos, Monopoly and Discrete Logarithms\" (PDF) . Journal of Cryptology . 13 (4). Tidmarsh Cottage, Manor Farm Lane, Tidmarsh, Reading, UK: International Association for Cryptologic Research : 437– 447. doi : 10.1007/s001450010010 . ISSN 0933-2790 . Archived (PDF) from the original on 2023-08-18 . Retrieved 2023-08-19 . (11 pages) ^ Dawson, Terence J. (1977-08-01). \"Kangaroos\". Scientific American . Vol. 237, no. 2. Scientific American, Inc. pp. 78– 89. ISSN 0036-8733 . JSTOR 24954004 . ^ Pollard, John M. \"Jmptidcott2\" . Archived from the original on 2023-08-18 .",
    "source_url": "https://en.wikipedia.org/wiki/Pollard%27s_kangaroo_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:21.085104",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:21.085104",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:21.085104",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Pollard%27s_kangaroo_algorithm_1_1749015561569_3939",
    "text": "JSTOR 24954004 . ^ Pollard, John M. \"Jmptidcott2\" . Archived from the original on 2023-08-18 . Retrieved 2023-08-19 . ^ Pollard, John M. (July 2000). \"Kruskal's Card Trick\" (PDF) . The Mathematical Gazette . 84 (500). Tidmarsh Cottage, Manor Farm Lane, Tidmarsh, Reading, UK: The Mathematical Association : 265– 267. doi : 10.2307/3621657 . ISSN 0025-5572 . JSTOR 3621657 . 84.29. Archived (PDF) from the original on 2023-08-18 . Retrieved 2023-08-19 . (1+3 pages) Further reading [ edit ] Montenegro, Ravi [at Wikidata] ; Tetali, Prasad V. (2010-11-07) [2009-05-31]. How Long Does it Take to Catch a Wild Kangaroo? (PDF) . Proceedings of the forty-first annual ACM symposium on Theory of computing (STOC 2009). pp. 553– 560. arXiv : 0812.0789 . doi : 10.1145/1536414.1536490 . S2CID 12797847 . Archived (PDF) from the original on 2023-08-20 . Retrieved 2023-08-20 .",
    "source_url": "https://en.wikipedia.org/wiki/Pollard%27s_kangaroo_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:21.569980",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:21.569980",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:21.569980",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Pollard%27s_kangaroo_algorithm&oldid=1286840726_1_1749015562400_6199",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by The real JustSomeoneNo ( talk | contribs ) at 09:28, 22 April 2025 (Open access status updates in citations with OAbot #oabot) . The present address (URL) is a permanent link to this version. Revision as of 09:28, 22 April 2025 by The real JustSomeoneNo ( talk | contribs ) (Open access status updates in citations with OAbot #oabot) ( diff ) ← Previous revision | Latest revision (diff) | ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Pollard%27s_kangaroo_algorithm&oldid=1286840726",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:22.400324",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:22.401330",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:22.401330",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Category:Geometric_algorithms&oldid=906011471_1_1749015565811_4971",
    "text": "Jump to content Help From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by BrownHairedGirl ( talk | contribs ) at 00:40, 13 July 2019 (remove links to deleted portals) . The present address (URL) is a permanent link to this version. Revision as of 00:40, 13 July 2019 by BrownHairedGirl ( talk | contribs ) (remove links to deleted portals) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) Wikimedia Commons has media related to ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Category:Geometric_algorithms&oldid=906011471",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:25.811245",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:25.811245",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:25.811245",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Convex_hull_algorithms_1_1749015568779_7318",
    "text": "For the set x 1 , … , x n {\\displaystyle x_{1},\\dots ,x_{n}} numbers to sort consider the set ( x 1 , x 1 2 ) , … , ( x n , x n 2 ) {\\displaystyle (x_{1},x_{1}^{2}),\\dots ,(x_{n},x_{n}^{2})} of points in the plane. Since they lie on a parabola , which is a convex curve , it is easy to see that the vertices of the convex hull, when traversed along the boundary, produce the sorted order of the numbers x 1 , … , x n {\\displaystyle x_{1},\\dots ,x_{n}} . Clearly, linear time is required for the described transformation of numbers into points and then extracting their sorted order. Therefore, in the general case the convex hull of n {\\displaystyle n} points cannot be computed more quickly than sorting. The standard Ω ( n log ⁡ n ) {\\displaystyle \\Omega (n\\log n)} lower bound for sorting is proven in the decision tree model of computing, in which only numerical comparisons but not arithmetic operations can be performed; however, in this model, convex hulls cannot be computed at all.",
    "source_url": "https://en.wikipedia.org/wiki/Convex_hull_algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:28.779066",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:28.780067",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:28.780067",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Convex_hull_algorithms_1_1749015569017_3711",
    "text": "This method is based on the following idea. Find the two points with the lowest and highest x-coordinates, and the two points with the lowest and highest y-coordinates. (Each of these operations takes O ( n ).) These four points form a convex quadrilateral , and all points that lie in this quadrilateral (except for the four initially chosen vertices) are not part of the convex hull. Finding all of these points that lie in this quadrilateral is also O( n ), and thus, the entire operation is O( n ). Optionally, the points with smallest and largest sums of x- and y-coordinates as well as those with smallest and largest differences of x- and y-coordinates can also be added to the quadrilateral, thus forming an irregular convex octagon, whose insides can be safely discarded.",
    "source_url": "https://en.wikipedia.org/wiki/Convex_hull_algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:29.017032",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:29.017032",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:29.017032",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Kirkpatrick–Seidel_algorithm&oldid=1055313789_1_1749015577476_9083",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by Citation bot ( talk | contribs ) at 04:19, 15 November 2021 (Add: bibcode. | Use this bot . Report bugs . | Suggested by Abductive | #UCB_toolbar) . The present address (URL) is a permanent link to this version. Revision as of 04:19, 15 November 2021 by Citation bot ( talk | contribs ) (Add: bibcode. | Use this bot . Report bugs . | Suggested by Abductive | #UCB_toolbar) ( diff ) ← Previ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Kirkpatrick–Seidel_algorithm&oldid=1055313789",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:37.476247",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:37.477258",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:37.477258",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Gilbert%E2%80%93Johnson%E2%80%93Keerthi_distance_algorithm_1_1749015578899_1350",
    "text": "The simplices handled by NearestSimplex may each be any simplex sub-space of R n . For example in 3D, they may be a point, a line segment, a triangle, or a tetrahedron ; each defined by 1, 2, 3, or 4 points respectively. Pseudocode [ edit ] function GJK_intersection(shape p, shape q, vector initial_axis):\n    vector  A = Support(p, initial_axis) − Support(q, −initial_axis) simplex s = {A}\n    vector  D = −A loop :\n        A = Support(p, D) − Support(q, −D) if dot(A, D) < 0:\n            reject\n        s = s ∪ {A}\n        s, D, contains_origin := NearestSimplex(s) if contains_origin:\n            accept Illustration [ edit ] The two types of collision and corresponding CSO face: face-vertex (top) and edge-edge (bottom).",
    "source_url": "https://en.wikipedia.org/wiki/Gilbert%E2%80%93Johnson%E2%80%93Keerthi_distance_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:38.899939",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:38.899939",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:38.899939",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_index.php?title=Bentley–Ottmann_algorithm&oldid=1276541838_1_1749015586983_5305",
    "text": "Jump to content From Wikipedia, the free encyclopedia This is the current revision of this page, as edited by John of Reading ( talk | contribs ) at 13:18, 19 February 2025 ( → top : Typo fixing, replaced: -atinos → -ations) . The present address (URL) is a permanent link to this version. Revision as of 13:18, 19 February 2025 by John of Reading ( talk | contribs ) ( → top : Typo fixing, replaced: -atinos → -ations) ( diff ) ← Previous revision | Latest revision (diff) | Newer revision → (diff) ",
    "source_url": "https://en.wikipedia.org/w/index.php?title=Bentley–Ottmann_algorithm&oldid=1276541838",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:46.983787",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:46.984787",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:46.984787",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Minimum_bounding_box_algorithms_1_1749015589711_1502",
    "text": "The other four faces need only contain a point of the convex hull. Again, the points which they contain need not be distinct: a single hull point lying in the corner of the box already satisfies three of these four criteria. It follows in the most general case where no convex hull vertices lie in edges of the minimal enclosing box, that at least 8 convex hull points must lie within faces of the box: two endpoints of each of the two edges, and four more points, one for each of the remaining four box faces. Conversely, if the convex hull consists of 7 or fewer vertices, at least one of them must lie within an edge of the hull's minimal enclosing box. [ 4 ] It is also possible to approximate the minimum bounding box volume, to within any constant factor greater than one, in linear time .",
    "source_url": "https://en.wikipedia.org/wiki/Minimum_bounding_box_algorithms",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:49.711620",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:49.712321",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:49.712321",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shoelace_algorithm_1_1749015594902_3276",
    "text": "= P n , P n + 1 = P 1 {\\displaystyle P_{0}=P_{n},P_{n+1}=P_{1}} . The formulas: The area of the given polygon can be expressed by a variety of formulas, which are connected by simple operations (see below): If the polygon is negatively oriented , then the result A {\\displaystyle A} of the formulas is negative. In any case | A | {\\displaystyle |A|} is the sought area of the polygon. [ 8 ] Trapezoid formula [ edit ] The trapezoid formula sums up a sequence of oriented areas A i = 1 2 ( y i + y i + 1 ) ( x i − x i + 1 ) {\\displaystyle A_{i}={\\tfrac {1}{2}}(y_{i}+y_{i+1})(x_{i}-x_{i+1})} of trapezoids with P i P i + 1 {\\displaystyle P_{i}P_{i+1}} as one of its four edges (see below): A = 1 2 ∑ i = 1 n ( y i + y i + 1 ) ( x i − x i + 1 ) = 1 2 ( ( y 1 + y 2 ) ( x 1 − x 2 ) + ⋯ + ( y n + y 1 ) (",
    "source_url": "https://en.wikipedia.org/wiki/Shoelace_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:54.902948",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:54.902948",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:54.902948",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shoelace_algorithm_1_1749015594935_9952",
    "text": "x i − x i + 1 ) = 1 2 ( ( y 1 + y 2 ) ( x 1 − x 2 ) + ⋯ + ( y n + y 1 ) ( x n − x 1 ) ) {\\displaystyle {\\begin{aligned}A&={\\frac {1}{2}}\\sum _{i=1}^{n}(y_{i}+y_{i+1})(x_{i}-x_{i+1})\\\\&={\\frac {1}{2}}{\\Big (}(y_{1}+y_{2})(x_{1}-x_{2})+\\cdots +(y_{n}+y_{1})(x_{n}-x_{1}){\\Big )}\\end{aligned}}} Triangle formula [ edit ] The triangle formula sums up the oriented areas A i {\\displaystyle A_{i}} of triangles O P i P i + 1 {\\displaystyle OP_{i}P_{i+1}} : [ 9 ] A = 1 2 ∑ i = 1 n ( x i y i + 1 − x i + 1 y i ) = 1 2 ∑ i = 1 n | x i x i + 1 y i y i + 1 | = 1 2 ∑ i = 1 n | x i y i x i + 1 y i + 1 | = 1 2 ( x 1 y 2 − x 2 y 1 + x 2 y 3 − x 3 y 2 + ⋯ + x n y 1",
    "source_url": "https://en.wikipedia.org/wiki/Shoelace_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:54.935330",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:54.935330",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:54.935330",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shoelace_algorithm_1_1749015595008_6604",
    "text": "1 x 2 x 3 ⋯ x n x 1 y 1 y 2 y 3 ⋯ y n y 1 | {\\displaystyle {\\begin{aligned}2A&={\\begin{vmatrix}x_{1}&x_{2}\\\\y_{1}&y_{2}\\end{vmatrix}}+{\\begin{vmatrix}x_{2}&x_{3}\\\\y_{2}&y_{3}\\end{vmatrix}}+\\cdots +{\\begin{vmatrix}x_{n}&x_{1}\\\\y_{n}&y_{1}\\end{vmatrix}}\\\\[10mu]&={\\begin{vmatrix}x_{1}&x_{2}&x_{3}\\cdots &x_{n}&x_{1}\\\\y_{1}&y_{2}&y_{3}\\cdots &y_{n}&y_{1}\\end{vmatrix}}\\end{aligned}}} Sometimes this determinant is transposed (written vertically, in two columns), as shown in the diagram. Other formulas [ edit ] A = 1 2 ∑ i = 1 n y i ( x i − 1 − x i + 1 ) = 1 2 ( y 1 ( x n − x 2 ) + y 2 ( x 1 − x 3 ) + ⋯ + y n ( x n − 1 − x 1 ) ) {\\displaystyle {\\begin{aligned}A&={\\frac {1}{2}}\\sum _{i=1}^{n}y_{i}(x_{i-1}-x_{i+1})\\\\&={\\frac {1}{2}}{\\Big (}y_{1}(x_{n}-x_{2})+y_{2}(x_{1}-x_{3})+\\cdots +y_{n}(x_{n-1}-x_{1}){\\Big )}\\end{aligned}}} A = 1 2 ∑ i = 1 n x i ( y i + 1 − y i − 1 ) {\\displaystyle A={\\frac {1}{2}}\\sum _{i=1}^{n}x_{i}(y_{i+1}-y_{i-1})} Exterior Algebra [ edit ]",
    "source_url": "https://en.wikipedia.org/wiki/Shoelace_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:55.009558",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:55.009558",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:55.009558",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shoelace_algorithm_1_1749015595045_7611",
    "text": "A particularly concise statement of the formula can be given in terms of the exterior algebra . Let v 1 , v 2 , … , v n {\\displaystyle \\mathbf {v} _{1},\\mathbf {v} _{2},\\dots ,\\mathbf {v} _{n}} be the consecutive vertices of the polygon. The Cartesian coordinate expansion of the outer product with respect to the standard ordered orthonormal plane basis ( x , y ) {\\displaystyle (\\mathbf {x} ,\\mathbf {y} )} gives v i ∧ v i + 1 = ( x i y i + 1 − x i + 1 y i ) x ∧ y {\\displaystyle \\mathbf {v} _{i}\\wedge \\mathbf {v} _{i+1}=(x_{i}y_{i+1}-x_{i+1}y_{i})\\;\\mathbf {x} \\wedge \\mathbf {y} } and the oriented area is given as follows. A = 1 2 ∑ i = 1 n v i ∧ v i + 1 = 1 2 ∑ i = 1 n ( x i y i + 1 − x i + 1 y i ) x ∧ y {\\displaystyle A={\\frac {1}{2}}\\sum _{i=1}^{n}v_{i}\\wedge v_{i+1}={\\frac {1}{2}}\\sum _{i=1}^{n}(x_{i}y_{i+1}-x_{i+1}y_{i})\\;\\mathbf {x} \\wedge \\mathbf {y} } Note that the area is given as a multiple of the unit area x ∧ y {\\displaystyle \\mathbf {x} \\wedge \\mathbf {y} } .",
    "source_url": "https://en.wikipedia.org/wiki/Shoelace_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:55.045793",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:55.045793",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:55.045793",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shoelace_algorithm_1_1749015595077_3288",
    "text": "x ∧ y {\\displaystyle \\mathbf {x} \\wedge \\mathbf {y} } . Example Horizontal shoelace form for the example. Example [ edit ] For the area of the pentagon with P 1 = ( 1 , 6 ) , P 2 = ( 3 , 1 ) , P 3 = ( 7 , 2 ) , P 4 = ( 4 , 4 ) , P 5 = ( 8 , 5 ) {\\displaystyle {\\begin{aligned}&P_{1}=(1,6),P_{2}=(3,1),P_{3}=(7,2),\\\\&P_{4}=(4,4),P_{5}=(8,5)\\end{aligned}}} one gets 2 A = | 1 3 6 1 | + | 3 7 1 2 | + | 7 4 2 4 | + | 4 8 4 5 | + | 8 1 5 6 | = ( 1 − 18 ) + ( 6 − 7 ) + ( 28 − 8 ) + ( 20 − 32 ) + ( 48 − 5 ) = 33 A = 16.5 {\\displaystyle {\\begin{aligned}2A&={\\begin{vmatrix}1&3\\\\6&1\\end{vmatrix}}+{\\begin{vmatrix}3&7\\\\1&2\\end{vmatrix}}+{\\begin{vmatrix}7&4\\\\2&4\\end{vmatrix}}+{\\begin{vmatrix}4&8\\\\4&5\\end{vmatrix}}+{\\begin{vmatrix}8&1\\\\5&6\\end{vmatrix}}\\\\&=(1-18)\\;+(6-7)\\;+(28-8)\\;+(20-32)\\;+(48-5)=33\\\\A&=16.5\\end{aligned}}} The advantage of the shoelace form: Only 6 columns have to be written for calculating the 5 determinants with 10 columns.",
    "source_url": "https://en.wikipedia.org/wiki/Shoelace_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:55.077519",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:55.077519",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:55.077519",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shoelace_algorithm_1_1749015595110_9542",
    "text": "Deriving the formulas [ edit ] Trapezoid formula [ edit ] Deriving the trapezoid formula The edge P i , P i + 1 {\\displaystyle P_{i},P_{i+1}} determines the trapezoid ( x i , y i ) , ( x i + 1 , y i + 1 ) , ( x i , 0 ) , ( x i + 1 , 0 ) {\\displaystyle (x_{i},y_{i}),(x_{i+1},y_{i+1}),(x_{i},0),(x_{i+1},0)} with its oriented area A i = 1 2 ( y i + y i + 1 ) ( x i − x i + 1 ) {\\displaystyle A_{i}={\\tfrac {1}{2}}(y_{i}+y_{i+1})(x_{i}-x_{i+1})} In case of x i < x i + 1 {\\displaystyle x_{i}<x_{i+1}} the number A i {\\displaystyle A_{i}} is negative, otherwise positive or A i = 0 {\\displaystyle A_{i}=0} if x i = x i + 1 {\\displaystyle x_{i}=x_{i+1}} . In the diagram the orientation  of an edge is shown by an arrow. The color shows the sign of A i {\\displaystyle A_{i}} : red means A i < 0 {\\displaystyle A_{i}<0} , green indicates A i > 0 {\\displaystyle A_{i}>0} . In the first case the trapezoid is called negative in the second case positive .",
    "source_url": "https://en.wikipedia.org/wiki/Shoelace_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:55.110386",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:55.111386",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:55.111386",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shoelace_algorithm_1_1749015595142_1866",
    "text": "In the first case the trapezoid is called negative in the second case positive . The negative trapezoids delete those parts of positive trapezoids, which are outside the polygon. In case of a convex polygon (in the diagram the upper example) this is obvious: The polygon area is the sum of the areas of the positive trapezoids (green edges) minus the  areas of the negative trapezoids (red edges). In the non convex case one has to consider the situation more \ncarefully (see diagram). In any case the result is A = ∑ i = 1 n A i = 1 2 ∑ i = 1 n ( y i + y i + 1 ) ( x i − x i + 1 ) {\\displaystyle A=\\sum _{i=1}^{n}A_{i}={\\frac {1}{2}}\\sum _{i=1}^{n}(y_{i}+y_{i+1})(x_{i}-x_{i+1})} Triangle form, determinant form [ edit ] Triangle form: The color of the edges indicate, which triangle area  is positive (green) and negative (red) respectively. Eliminating the brackets and using ∑ i = 1 n x i y i = ∑ i = 1 n x i + 1 y i",
    "source_url": "https://en.wikipedia.org/wiki/Shoelace_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:55.142031",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:55.142031",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:55.142031",
    "decision_type": "FOLLOW_HYBRID"
  },
  {
    "id": "FOLLOW_HYBRID_Shoelace_algorithm_1_1749015595175_5659",
    "text": "Eliminating the brackets and using ∑ i = 1 n x i y i = ∑ i = 1 n x i + 1 y i + 1 {\\textstyle \\sum _{i=1}^{n}x_{i}y_{i}=\\sum _{i=1}^{n}x_{i+1}y_{i+1}} (see convention P n + 1 = P 1 {\\displaystyle P_{n+1}=P_{1}} above), one gets the determinant form of the area formula: A = 1 2 ∑ i = 1 n ( x i y i + 1 − x i + 1 y i ) = 1 2 ∑ i = 1 n | x i x i + 1 y i y i + 1 | {\\displaystyle A={\\frac {1}{2}}\\sum _{i=1}^{n}(x_{i}y_{i+1}-x_{i+1}y_{i})={\\frac {1}{2}}\\sum _{i=1}^{n}{\\begin{vmatrix}x_{i}&x_{i+1}\\\\y_{i}&y_{i+1}\\end{vmatrix}}} Because one half of the i-th determinant is the oriented area of the triangle O , P i , P i + 1 {\\displaystyle O,P_{i},P_{i+1}} this version of the area formula is called triangle form . Other formulas [ edit ] With ∑ i = 1 n x i y i + 1 = ∑ i = 1 n x i − 1 y i {\\textstyle \\sum _{i=1}^{n}x_{i}y_{i+1}=\\sum _{i=1}^{n}x_{i-1}y_{i}\\ } (see convention P 0 = P n , P n + 1 = P 1 {\\displaystyle P_{0}=P_{n},P_{n+1}=P_{1}} above) one gets 2 A = ∑",
    "source_url": "https://en.wikipedia.org/wiki/Shoelace_algorithm",
    "logic_score": 0.0,
    "symbolic_score": 0.0,
    "confidence_score": 0.0,
    "processing_phase": 1,
    "timestamp": "2025-06-04T05:39:55.175218",
    "symbols_found_in_chunk": 0,
    "decision_history": [
      {
        "decision": "FOLLOW_HYBRID",
        "timestamp": "2025-06-04T05:39:55.176124",
        "weights": {
          "static": 0.893,
          "dynamic": 0.107
        }
      }
    ],
    "last_decision": "FOLLOW_HYBRID",
    "history_length": 1,
    "stored_at": "2025-06-04T05:39:55.176124",
    "decision_type": "FOLLOW_HYBRID"
  }
]